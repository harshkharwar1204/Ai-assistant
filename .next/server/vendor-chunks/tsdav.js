"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/tsdav";
exports.ids = ["vendor-chunks/tsdav"];
exports.modules = {

/***/ "(rsc)/./node_modules/tsdav/dist/tsdav.esm.js":
/*!**********************************************!*\
  !*** ./node_modules/tsdav/dist/tsdav.esm.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DAVAttributeMap: () => (/* binding */ DAVAttributeMap),\n/* harmony export */   DAVClient: () => (/* binding */ DAVClient),\n/* harmony export */   DAVNamespace: () => (/* binding */ DAVNamespace),\n/* harmony export */   DAVNamespaceShort: () => (/* binding */ DAVNamespaceShort),\n/* harmony export */   addressBookMultiGet: () => (/* binding */ addressBookMultiGet),\n/* harmony export */   addressBookQuery: () => (/* binding */ addressBookQuery),\n/* harmony export */   calendarMultiGet: () => (/* binding */ calendarMultiGet),\n/* harmony export */   calendarQuery: () => (/* binding */ calendarQuery),\n/* harmony export */   cleanupFalsy: () => (/* binding */ cleanupFalsy),\n/* harmony export */   collectionQuery: () => (/* binding */ collectionQuery),\n/* harmony export */   createAccount: () => (/* binding */ createAccount),\n/* harmony export */   createCalendarObject: () => (/* binding */ createCalendarObject),\n/* harmony export */   createDAVClient: () => (/* binding */ createDAVClient),\n/* harmony export */   createObject: () => (/* binding */ createObject),\n/* harmony export */   createVCard: () => (/* binding */ createVCard),\n/* harmony export */   davRequest: () => (/* binding */ davRequest),\n/* harmony export */   \"default\": () => (/* binding */ index),\n/* harmony export */   deleteCalendarObject: () => (/* binding */ deleteCalendarObject),\n/* harmony export */   deleteObject: () => (/* binding */ deleteObject),\n/* harmony export */   deleteVCard: () => (/* binding */ deleteVCard),\n/* harmony export */   fetchAddressBooks: () => (/* binding */ fetchAddressBooks),\n/* harmony export */   fetchCalendarObjects: () => (/* binding */ fetchCalendarObjects),\n/* harmony export */   fetchCalendarUserAddresses: () => (/* binding */ fetchCalendarUserAddresses),\n/* harmony export */   fetchCalendars: () => (/* binding */ fetchCalendars),\n/* harmony export */   fetchOauthTokens: () => (/* binding */ fetchOauthTokens),\n/* harmony export */   fetchVCards: () => (/* binding */ fetchVCards),\n/* harmony export */   freeBusyQuery: () => (/* binding */ freeBusyQuery),\n/* harmony export */   getBasicAuthHeaders: () => (/* binding */ getBasicAuthHeaders),\n/* harmony export */   getBearerAuthHeaders: () => (/* binding */ getBearerAuthHeaders),\n/* harmony export */   getDAVAttribute: () => (/* binding */ getDAVAttribute),\n/* harmony export */   getOauthHeaders: () => (/* binding */ getOauthHeaders),\n/* harmony export */   isCollectionDirty: () => (/* binding */ isCollectionDirty),\n/* harmony export */   makeCalendar: () => (/* binding */ makeCalendar),\n/* harmony export */   propfind: () => (/* binding */ propfind),\n/* harmony export */   refreshAccessToken: () => (/* binding */ refreshAccessToken),\n/* harmony export */   smartCollectionSync: () => (/* binding */ smartCollectionSync),\n/* harmony export */   supportedReportSet: () => (/* binding */ supportedReportSet),\n/* harmony export */   syncCalendars: () => (/* binding */ syncCalendars),\n/* harmony export */   syncCollection: () => (/* binding */ syncCollection),\n/* harmony export */   updateCalendarObject: () => (/* binding */ updateCalendarObject),\n/* harmony export */   updateObject: () => (/* binding */ updateObject),\n/* harmony export */   updateVCard: () => (/* binding */ updateVCard),\n/* harmony export */   urlContains: () => (/* binding */ urlContains),\n/* harmony export */   urlEquals: () => (/* binding */ urlEquals)\n/* harmony export */ });\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\");\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var xml_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! xml-js */ \"(rsc)/./node_modules/xml-js/lib/index.js\");\n/* harmony import */ var xml_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(xml_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var cross_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cross-fetch */ \"(rsc)/./node_modules/cross-fetch/dist/node-ponyfill.js\");\n/* harmony import */ var cross_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(cross_fetch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var base_64__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! base-64 */ \"(rsc)/./node_modules/base-64/base64.js\");\n/* harmony import */ var base_64__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(base_64__WEBPACK_IMPORTED_MODULE_3__);\n\n\n\n\n\nvar DAVNamespace;\n(function (DAVNamespace) {\n    DAVNamespace[\"CALENDAR_SERVER\"] = \"http://calendarserver.org/ns/\";\n    DAVNamespace[\"CALDAV_APPLE\"] = \"http://apple.com/ns/ical/\";\n    DAVNamespace[\"CALDAV\"] = \"urn:ietf:params:xml:ns:caldav\";\n    DAVNamespace[\"CARDDAV\"] = \"urn:ietf:params:xml:ns:carddav\";\n    DAVNamespace[\"DAV\"] = \"DAV:\";\n})(DAVNamespace || (DAVNamespace = {}));\nconst DAVAttributeMap = {\n    [DAVNamespace.CALDAV]: 'xmlns:c',\n    [DAVNamespace.CARDDAV]: 'xmlns:card',\n    [DAVNamespace.CALENDAR_SERVER]: 'xmlns:cs',\n    [DAVNamespace.CALDAV_APPLE]: 'xmlns:ca',\n    [DAVNamespace.DAV]: 'xmlns:d',\n};\nvar DAVNamespaceShort;\n(function (DAVNamespaceShort) {\n    DAVNamespaceShort[\"CALDAV\"] = \"c\";\n    DAVNamespaceShort[\"CARDDAV\"] = \"card\";\n    DAVNamespaceShort[\"CALENDAR_SERVER\"] = \"cs\";\n    DAVNamespaceShort[\"CALDAV_APPLE\"] = \"ca\";\n    DAVNamespaceShort[\"DAV\"] = \"d\";\n})(DAVNamespaceShort || (DAVNamespaceShort = {}));\nvar ICALObjects;\n(function (ICALObjects) {\n    ICALObjects[\"VEVENT\"] = \"VEVENT\";\n    ICALObjects[\"VTODO\"] = \"VTODO\";\n    ICALObjects[\"VJOURNAL\"] = \"VJOURNAL\";\n    ICALObjects[\"VFREEBUSY\"] = \"VFREEBUSY\";\n    ICALObjects[\"VTIMEZONE\"] = \"VTIMEZONE\";\n    ICALObjects[\"VALARM\"] = \"VALARM\";\n})(ICALObjects || (ICALObjects = {}));\n\nconst camelCase = (str) => str.replace(/([-_]\\w)/g, (g) => g[1].toUpperCase());\n\n/**\n * Cloudflare Workers and some modern environments have a native fetch on globalThis.\n * We prefer it over cross-fetch to avoid compatibility issues with the polyfill.\n */\nconst getFetch = () => {\n    if (typeof globalThis !== 'undefined' && typeof globalThis.fetch === 'function') {\n        return globalThis.fetch.bind(globalThis);\n    }\n    // Fallback to cross-fetch\n    return (cross_fetch__WEBPACK_IMPORTED_MODULE_2___default());\n};\nconst fetch = getFetch();\n\nconst nativeType = (value) => {\n    const nValue = Number(value);\n    if (!Number.isNaN(nValue)) {\n        return nValue;\n    }\n    const bValue = value.toLowerCase();\n    if (bValue === 'true') {\n        return true;\n    }\n    if (bValue === 'false') {\n        return false;\n    }\n    return value;\n};\n\nconst urlEquals = (urlA, urlB) => {\n    if (!urlA && !urlB) {\n        return true;\n    }\n    if (!urlA || !urlB) {\n        return false;\n    }\n    const trimmedUrlA = urlA.trim();\n    const trimmedUrlB = urlB.trim();\n    if (Math.abs(trimmedUrlA.length - trimmedUrlB.length) > 1) {\n        return false;\n    }\n    const strippedUrlA = trimmedUrlA.slice(-1) === '/' ? trimmedUrlA.slice(0, -1) : trimmedUrlA;\n    const strippedUrlB = trimmedUrlB.slice(-1) === '/' ? trimmedUrlB.slice(0, -1) : trimmedUrlB;\n    return urlA.includes(strippedUrlB) || urlB.includes(strippedUrlA);\n};\nconst urlContains = (urlA, urlB) => {\n    if (!urlA && !urlB) {\n        return true;\n    }\n    if (!urlA || !urlB) {\n        return false;\n    }\n    const trimmedUrlA = urlA.trim();\n    const trimmedUrlB = urlB.trim();\n    const strippedUrlA = trimmedUrlA.slice(-1) === '/' ? trimmedUrlA.slice(0, -1) : trimmedUrlA;\n    const strippedUrlB = trimmedUrlB.slice(-1) === '/' ? trimmedUrlB.slice(0, -1) : trimmedUrlB;\n    return urlA.includes(strippedUrlB) || urlB.includes(strippedUrlA);\n};\nconst getDAVAttribute = (nsArr) => nsArr.reduce((prev, curr) => ({ ...prev, [DAVAttributeMap[curr]]: curr }), {});\nconst cleanupFalsy = (obj) => Object.entries(obj).reduce((prev, [key, value]) => {\n    if (value)\n        return { ...prev, [key]: value };\n    return prev;\n}, {});\nconst conditionalParam = (key, param) => {\n    if (param) {\n        return {\n            [key]: param,\n        };\n    }\n    return {};\n};\nconst excludeHeaders = (headers, headersToExclude) => {\n    if (!headers) {\n        return {};\n    }\n    if (!headersToExclude || headersToExclude.length === 0) {\n        return headers;\n    }\n    return Object.fromEntries(Object.entries(headers).filter(([key]) => !headersToExclude.includes(key)));\n};\n\nvar requestHelpers = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    cleanupFalsy: cleanupFalsy,\n    conditionalParam: conditionalParam,\n    excludeHeaders: excludeHeaders,\n    getDAVAttribute: getDAVAttribute,\n    urlContains: urlContains,\n    urlEquals: urlEquals\n});\n\nconst debug$5 = debug__WEBPACK_IMPORTED_MODULE_0___default()('tsdav:request');\nconst davRequest = async (params) => {\n    var _a;\n    const { url, init, convertIncoming = true, parseOutgoing = true, fetchOptions = {}, fetch: fetchOverride, } = params;\n    const requestFetch = fetchOverride !== null && fetchOverride !== void 0 ? fetchOverride : fetch;\n    const { headers = {}, body, namespace, method, attributes } = init;\n    const xmlBody = convertIncoming\n        ? xml_js__WEBPACK_IMPORTED_MODULE_1___default().js2xml({\n            _declaration: { _attributes: { version: '1.0', encoding: 'utf-8' } },\n            ...body,\n            _attributes: attributes,\n        }, {\n            compact: true,\n            spaces: 2,\n            elementNameFn: (name) => {\n                // add namespace to all keys without namespace\n                if (namespace && !/^.+:.+/.test(name)) {\n                    return `${namespace}:${name}`;\n                }\n                return name;\n            },\n        })\n        : body;\n    // debug('outgoing xml:');\n    // debug(`${method} ${url}`);\n    // debug(\n    //   `headers: ${JSON.stringify(\n    //     {\n    //       'Content-Type': 'text/xml;charset=UTF-8',\n    //       ...cleanupFalsy(headers),\n    //     },\n    //     null,\n    //     2\n    //   )}`\n    // );\n    // debug(xmlBody);\n    const fetchOptionsWithoutHeaders = {\n        ...fetchOptions,\n    };\n    delete fetchOptionsWithoutHeaders.headers;\n    const davResponse = await requestFetch(url, {\n        headers: {\n            'Content-Type': 'text/xml;charset=UTF-8',\n            ...cleanupFalsy(headers),\n            ...(fetchOptions.headers || {}),\n        },\n        body: xmlBody,\n        method,\n        ...fetchOptionsWithoutHeaders,\n    });\n    const resText = await davResponse.text();\n    // filter out invalid responses\n    // debug('response xml:');\n    // debug(resText);\n    // debug(davResponse);\n    if (!davResponse.ok ||\n        !((_a = davResponse.headers.get('content-type')) === null || _a === void 0 ? void 0 : _a.includes('xml')) ||\n        !parseOutgoing ||\n        !resText) {\n        return [\n            {\n                href: davResponse.url,\n                ok: davResponse.ok,\n                status: davResponse.status,\n                statusText: davResponse.statusText,\n                raw: resText,\n            },\n        ];\n    }\n    const result = xml_js__WEBPACK_IMPORTED_MODULE_1___default().xml2js(resText, {\n        compact: true,\n        trim: true,\n        textFn: (value, parentElement) => {\n            try {\n                // This is needed for xml-js design reasons\n                // eslint-disable-next-line no-underscore-dangle\n                const parentOfParent = parentElement._parent;\n                const pOpKeys = Object.keys(parentOfParent);\n                const keyNo = pOpKeys.length;\n                const keyName = pOpKeys[keyNo - 1];\n                const arrOfKey = parentOfParent[keyName];\n                const arrOfKeyLen = arrOfKey.length;\n                if (arrOfKeyLen > 0) {\n                    const arr = arrOfKey;\n                    const arrIndex = arrOfKey.length - 1;\n                    arr[arrIndex] = nativeType(value);\n                }\n                else {\n                    parentOfParent[keyName] = nativeType(value);\n                }\n            }\n            catch (e) {\n                debug$5(e.stack);\n            }\n        },\n        // remove namespace & camelCase\n        elementNameFn: (attributeName) => camelCase(attributeName.replace(/^.+:/, '')),\n        attributesFn: (value) => {\n            const newVal = { ...value };\n            delete newVal.xmlns;\n            return newVal;\n        },\n        ignoreDeclaration: true,\n    });\n    const responseBodies = Array.isArray(result.multistatus.response)\n        ? result.multistatus.response\n        : [result.multistatus.response];\n    return responseBodies.map((responseBody) => {\n        var _a, _b;\n        const statusRegex = /^\\S+\\s(?<status>\\d+)\\s(?<statusText>.+)$/;\n        if (!responseBody) {\n            return {\n                status: davResponse.status,\n                statusText: davResponse.statusText,\n                ok: davResponse.ok,\n            };\n        }\n        const matchArr = statusRegex.exec(responseBody.status);\n        return {\n            raw: result,\n            href: responseBody.href,\n            status: (matchArr === null || matchArr === void 0 ? void 0 : matchArr.groups) ? Number.parseInt(matchArr === null || matchArr === void 0 ? void 0 : matchArr.groups.status, 10) : davResponse.status,\n            statusText: (_b = (_a = matchArr === null || matchArr === void 0 ? void 0 : matchArr.groups) === null || _a === void 0 ? void 0 : _a.statusText) !== null && _b !== void 0 ? _b : davResponse.statusText,\n            ok: !responseBody.error,\n            error: responseBody.error,\n            responsedescription: responseBody.responsedescription,\n            props: (Array.isArray(responseBody.propstat)\n                ? responseBody.propstat\n                : [responseBody.propstat]).reduce((prev, curr) => {\n                return {\n                    ...prev,\n                    ...curr === null || curr === void 0 ? void 0 : curr.prop,\n                };\n            }, {}),\n        };\n    });\n};\nconst propfind = async (params) => {\n    const { url, props, depth, headers, headersToExclude, fetchOptions = {}, fetch: fetchOverride, } = params;\n    return davRequest({\n        url,\n        init: {\n            method: 'PROPFIND',\n            headers: excludeHeaders(cleanupFalsy({ depth, ...headers }), headersToExclude),\n            namespace: DAVNamespaceShort.DAV,\n            body: {\n                propfind: {\n                    _attributes: getDAVAttribute([\n                        DAVNamespace.CALDAV,\n                        DAVNamespace.CALDAV_APPLE,\n                        DAVNamespace.CALENDAR_SERVER,\n                        DAVNamespace.CARDDAV,\n                        DAVNamespace.DAV,\n                    ]),\n                    prop: props,\n                },\n            },\n        },\n        fetchOptions,\n        fetch: fetchOverride,\n    });\n};\nconst createObject = async (params) => {\n    const { url, data, headers, headersToExclude, fetchOptions = {}, fetch: fetchOverride } = params;\n    const requestFetch = fetchOverride !== null && fetchOverride !== void 0 ? fetchOverride : fetch;\n    return requestFetch(url, {\n        method: 'PUT',\n        body: data,\n        headers: excludeHeaders(headers, headersToExclude),\n        ...fetchOptions,\n    });\n};\nconst updateObject = async (params) => {\n    const { url, data, etag, headers, headersToExclude, fetchOptions = {}, fetch: fetchOverride, } = params;\n    const requestFetch = fetchOverride !== null && fetchOverride !== void 0 ? fetchOverride : fetch;\n    return requestFetch(url, {\n        method: 'PUT',\n        body: data,\n        headers: excludeHeaders(cleanupFalsy({ 'If-Match': etag, ...headers }), headersToExclude),\n        ...fetchOptions,\n    });\n};\nconst deleteObject = async (params) => {\n    const { url, headers, etag, headersToExclude, fetchOptions = {}, fetch: fetchOverride } = params;\n    const requestFetch = fetchOverride !== null && fetchOverride !== void 0 ? fetchOverride : fetch;\n    return requestFetch(url, {\n        method: 'DELETE',\n        headers: excludeHeaders(cleanupFalsy({ 'If-Match': etag, ...headers }), headersToExclude),\n        ...fetchOptions,\n    });\n};\n\nvar request = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    createObject: createObject,\n    davRequest: davRequest,\n    deleteObject: deleteObject,\n    propfind: propfind,\n    updateObject: updateObject\n});\n\nfunction hasFields(obj, fields) {\n    const inObj = (object) => fields.every((f) => object[f]);\n    if (Array.isArray(obj)) {\n        return obj.every((o) => inObj(o));\n    }\n    return inObj(obj);\n}\nconst findMissingFieldNames = (obj, fields) => fields.reduce((prev, curr) => (obj[curr] ? prev : `${prev.length ? `${prev},` : ''}${curr.toString()}`), '');\n\n/* eslint-disable no-underscore-dangle */\nconst debug$4 = debug__WEBPACK_IMPORTED_MODULE_0___default()('tsdav:collection');\nconst collectionQuery = async (params) => {\n    const { url, body, depth, defaultNamespace = DAVNamespaceShort.DAV, headers, headersToExclude, fetchOptions = {}, fetch: fetchOverride, } = params;\n    const queryResults = await davRequest({\n        url,\n        init: {\n            method: 'REPORT',\n            headers: excludeHeaders(cleanupFalsy({ depth, ...headers }), headersToExclude),\n            namespace: defaultNamespace,\n            body,\n        },\n        fetchOptions,\n        fetch: fetchOverride,\n    });\n    const errorResponse = queryResults.find((res) => !res.ok || (res.status && res.status >= 400));\n    if (errorResponse) {\n        throw new Error(`Collection query failed: ${errorResponse.status} ${errorResponse.statusText}. ${errorResponse.raw ? `Raw response: ${errorResponse.raw}` : ''}`);\n    }\n    // empty query result\n    if (queryResults.length === 1 &&\n        !queryResults[0].raw &&\n        queryResults[0].status &&\n        queryResults[0].status < 300) {\n        return [];\n    }\n    return queryResults;\n};\nconst makeCollection = async (params) => {\n    const { url, props, depth, headers, headersToExclude, fetchOptions = {}, fetch: fetchOverride, } = params;\n    return davRequest({\n        url,\n        init: {\n            method: 'MKCOL',\n            headers: excludeHeaders(cleanupFalsy({ depth, ...headers }), headersToExclude),\n            namespace: DAVNamespaceShort.DAV,\n            body: props\n                ? {\n                    mkcol: {\n                        set: {\n                            prop: props,\n                        },\n                    },\n                }\n                : undefined,\n        },\n        fetchOptions,\n        fetch: fetchOverride,\n    });\n};\nconst supportedReportSet = async (params) => {\n    var _a, _b, _c, _d, _e;\n    const { collection, headers, headersToExclude, fetchOptions = {}, fetch: fetchOverride } = params;\n    const res = await propfind({\n        url: collection.url,\n        props: {\n            [`${DAVNamespaceShort.DAV}:supported-report-set`]: {},\n        },\n        depth: '0',\n        headers: excludeHeaders(headers, headersToExclude),\n        fetchOptions,\n        fetch: fetchOverride,\n    });\n    return ((_e = (_d = (_c = (_b = (_a = res[0]) === null || _a === void 0 ? void 0 : _a.props) === null || _b === void 0 ? void 0 : _b.supportedReportSet) === null || _c === void 0 ? void 0 : _c.supportedReport) === null || _d === void 0 ? void 0 : _d.map((sr) => Object.keys(sr.report)[0])) !== null && _e !== void 0 ? _e : []);\n};\nconst isCollectionDirty = async (params) => {\n    var _a, _b, _c;\n    const { collection, headers, headersToExclude, fetchOptions = {}, fetch: fetchOverride } = params;\n    const responses = await propfind({\n        url: collection.url,\n        props: {\n            [`${DAVNamespaceShort.CALENDAR_SERVER}:getctag`]: {},\n        },\n        depth: '0',\n        headers: excludeHeaders(headers, headersToExclude),\n        fetchOptions,\n        fetch: fetchOverride,\n    });\n    const res = responses.filter((r) => urlContains(collection.url, r.href))[0];\n    if (!res) {\n        throw new Error('Collection does not exist on server');\n    }\n    return {\n        isDirty: `${collection.ctag}` !== `${(_a = res.props) === null || _a === void 0 ? void 0 : _a.getctag}`,\n        newCtag: (_c = (_b = res.props) === null || _b === void 0 ? void 0 : _b.getctag) === null || _c === void 0 ? void 0 : _c.toString(),\n    };\n};\n/**\n * This is for webdav sync-collection only\n */\nconst syncCollection = (params) => {\n    const { url, props, headers, syncLevel, syncToken, headersToExclude, fetchOptions, fetch: fetchOverride, } = params;\n    return davRequest({\n        url,\n        init: {\n            method: 'REPORT',\n            namespace: DAVNamespaceShort.DAV,\n            headers: excludeHeaders({ ...headers }, headersToExclude),\n            body: {\n                'sync-collection': {\n                    _attributes: getDAVAttribute([\n                        DAVNamespace.CALDAV,\n                        DAVNamespace.CARDDAV,\n                        DAVNamespace.DAV,\n                    ]),\n                    'sync-level': syncLevel,\n                    'sync-token': syncToken,\n                    [`${DAVNamespaceShort.DAV}:prop`]: props,\n                },\n            },\n        },\n        fetchOptions,\n        fetch: fetchOverride,\n    });\n};\n/** remote collection to local */\nconst smartCollectionSync = async (params) => {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;\n    const { collection, method, headers, headersToExclude, account, detailedResult, fetchOptions = {}, fetch: fetchOverride, } = params;\n    const requiredFields = ['accountType', 'homeUrl'];\n    if (!account || !hasFields(account, requiredFields)) {\n        if (!account) {\n            throw new Error('no account for smartCollectionSync');\n        }\n        throw new Error(`account must have ${findMissingFieldNames(account, requiredFields)} before smartCollectionSync`);\n    }\n    const syncMethod = method !== null && method !== void 0 ? method : (((_a = collection.reports) === null || _a === void 0 ? void 0 : _a.includes('syncCollection')) ? 'webdav' : 'basic');\n    debug$4(`smart collection sync with type ${account.accountType} and method ${syncMethod}`);\n    if (syncMethod === 'webdav') {\n        const result = await syncCollection({\n            url: collection.url,\n            props: {\n                [`${DAVNamespaceShort.DAV}:getetag`]: {},\n                [`${account.accountType === 'caldav' ? DAVNamespaceShort.CALDAV : DAVNamespaceShort.CARDDAV}:${account.accountType === 'caldav' ? 'calendar-data' : 'address-data'}`]: {},\n                [`${DAVNamespaceShort.DAV}:displayname`]: {},\n            },\n            syncLevel: 1,\n            syncToken: collection.syncToken,\n            headers: excludeHeaders(headers, headersToExclude),\n            fetchOptions,\n            fetch: fetchOverride,\n        });\n        const objectResponses = result.filter((r) => {\n            var _a;\n            const extName = account.accountType === 'caldav' ? '.ics' : '.vcf';\n            return ((_a = r.href) === null || _a === void 0 ? void 0 : _a.slice(-4)) === extName;\n        });\n        const changedObjectUrls = objectResponses.filter((o) => o.status !== 404).map((r) => r.href);\n        const deletedObjectUrls = objectResponses.filter((o) => o.status === 404).map((r) => r.href);\n        const multiGetObjectResponse = changedObjectUrls.length\n            ? ((_c = (await ((_b = collection === null || collection === void 0 ? void 0 : collection.objectMultiGet) === null || _b === void 0 ? void 0 : _b.call(collection, {\n                url: collection.url,\n                props: {\n                    [`${DAVNamespaceShort.DAV}:getetag`]: {},\n                    [`${account.accountType === 'caldav'\n                        ? DAVNamespaceShort.CALDAV\n                        : DAVNamespaceShort.CARDDAV}:${account.accountType === 'caldav' ? 'calendar-data' : 'address-data'}`]: {},\n                },\n                objectUrls: changedObjectUrls,\n                depth: '1',\n                headers: excludeHeaders(headers, headersToExclude),\n                fetchOptions,\n                fetch: fetchOverride,\n            })))) !== null && _c !== void 0 ? _c : [])\n            : [];\n        const remoteObjects = multiGetObjectResponse.map((res) => {\n            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n            return {\n                url: (_a = res.href) !== null && _a !== void 0 ? _a : '',\n                etag: (_b = res.props) === null || _b === void 0 ? void 0 : _b.getetag,\n                data: (account === null || account === void 0 ? void 0 : account.accountType) === 'caldav'\n                    ? ((_e = (_d = (_c = res.props) === null || _c === void 0 ? void 0 : _c.calendarData) === null || _d === void 0 ? void 0 : _d._cdata) !== null && _e !== void 0 ? _e : (_f = res.props) === null || _f === void 0 ? void 0 : _f.calendarData)\n                    : ((_j = (_h = (_g = res.props) === null || _g === void 0 ? void 0 : _g.addressData) === null || _h === void 0 ? void 0 : _h._cdata) !== null && _j !== void 0 ? _j : (_k = res.props) === null || _k === void 0 ? void 0 : _k.addressData),\n            };\n        });\n        const localObjects = (_d = collection.objects) !== null && _d !== void 0 ? _d : [];\n        // no existing url\n        const created = remoteObjects.filter((o) => localObjects.every((lo) => !urlContains(lo.url, o.url)));\n        // debug(`created objects: ${created.map((o) => o.url).join('\\n')}`);\n        // have same url, but etag different\n        const updated = localObjects.reduce((prev, curr) => {\n            const found = remoteObjects.find((ro) => urlContains(ro.url, curr.url));\n            if (found && found.etag && found.etag !== curr.etag) {\n                return [...prev, found];\n            }\n            return prev;\n        }, []);\n        // debug(`updated objects: ${updated.map((o) => o.url).join('\\n')}`);\n        const deleted = deletedObjectUrls.map((o) => ({\n            url: o,\n            etag: '',\n        }));\n        // debug(`deleted objects: ${deleted.map((o) => o.url).join('\\n')}`);\n        const unchanged = localObjects.filter((lo) => remoteObjects.some((ro) => urlContains(lo.url, ro.url) && ro.etag === lo.etag));\n        return {\n            ...collection,\n            objects: detailedResult\n                ? { created, updated, deleted }\n                : [...unchanged, ...created, ...updated],\n            // all syncToken in the results are the same so we use the first one here\n            syncToken: (_h = (_g = (_f = (_e = result[0]) === null || _e === void 0 ? void 0 : _e.raw) === null || _f === void 0 ? void 0 : _f.multistatus) === null || _g === void 0 ? void 0 : _g.syncToken) !== null && _h !== void 0 ? _h : collection.syncToken,\n        };\n    }\n    if (syncMethod === 'basic') {\n        const { isDirty, newCtag } = await isCollectionDirty({\n            collection,\n            headers: excludeHeaders(headers, headersToExclude),\n            fetchOptions,\n            fetch: fetchOverride,\n        });\n        const localObjects = (_j = collection.objects) !== null && _j !== void 0 ? _j : [];\n        const remoteObjects = (_m = (await ((_l = (_k = collection).fetchObjects) === null || _l === void 0 ? void 0 : _l.call(_k, {\n            collection,\n            headers: excludeHeaders(headers, headersToExclude),\n            fetchOptions,\n            fetch: fetchOverride,\n        })))) !== null && _m !== void 0 ? _m : [];\n        // no existing url\n        const created = remoteObjects.filter((ro) => localObjects.every((lo) => !urlContains(lo.url, ro.url)));\n        // debug(`created objects: ${created.map((o) => o.url).join('\\n')}`);\n        // have same url, but etag different\n        const updated = localObjects.reduce((prev, curr) => {\n            const found = remoteObjects.find((ro) => urlContains(ro.url, curr.url));\n            if (found && found.etag && found.etag !== curr.etag) {\n                return [...prev, found];\n            }\n            return prev;\n        }, []);\n        // debug(`updated objects: ${updated.map((o) => o.url).join('\\n')}`);\n        // does not present in remote\n        const deleted = localObjects.filter((cal) => remoteObjects.every((ro) => !urlContains(ro.url, cal.url)));\n        // debug(`deleted objects: ${deleted.map((o) => o.url).join('\\n')}`);\n        const unchanged = localObjects.filter((lo) => remoteObjects.some((ro) => urlContains(lo.url, ro.url) && ro.etag === lo.etag));\n        if (isDirty) {\n            return {\n                ...collection,\n                objects: detailedResult\n                    ? { created, updated, deleted }\n                    : [...unchanged, ...created, ...updated],\n                ctag: newCtag,\n            };\n        }\n    }\n    return detailedResult\n        ? {\n            ...collection,\n            objects: {\n                created: [],\n                updated: [],\n                deleted: [],\n            },\n        }\n        : collection;\n};\n\nvar collection = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    collectionQuery: collectionQuery,\n    isCollectionDirty: isCollectionDirty,\n    makeCollection: makeCollection,\n    smartCollectionSync: smartCollectionSync,\n    supportedReportSet: supportedReportSet,\n    syncCollection: syncCollection\n});\n\n/* eslint-disable no-underscore-dangle */\nconst debug$3 = debug__WEBPACK_IMPORTED_MODULE_0___default()('tsdav:addressBook');\nconst addressBookQuery = async (params) => {\n    const { url, props, filters, depth, headers, headersToExclude, fetchOptions = {}, fetch: fetchOverride, } = params;\n    return collectionQuery({\n        url,\n        body: {\n            'addressbook-query': cleanupFalsy({\n                _attributes: getDAVAttribute([DAVNamespace.CARDDAV, DAVNamespace.DAV]),\n                [`${DAVNamespaceShort.DAV}:prop`]: props,\n                filter: filters !== null && filters !== void 0 ? filters : {\n                    'prop-filter': {\n                        _attributes: {\n                            name: 'FN',\n                        },\n                    },\n                },\n            }),\n        },\n        defaultNamespace: DAVNamespaceShort.CARDDAV,\n        depth,\n        headers: excludeHeaders(headers, headersToExclude),\n        fetchOptions,\n        fetch: fetchOverride,\n    });\n};\nconst addressBookMultiGet = async (params) => {\n    const { url, props, objectUrls, depth, headers, headersToExclude, fetchOptions = {}, fetch: fetchOverride, } = params;\n    return collectionQuery({\n        url,\n        body: {\n            'addressbook-multiget': cleanupFalsy({\n                _attributes: getDAVAttribute([DAVNamespace.DAV, DAVNamespace.CARDDAV]),\n                [`${DAVNamespaceShort.DAV}:prop`]: props,\n                [`${DAVNamespaceShort.DAV}:href`]: objectUrls,\n            }),\n        },\n        defaultNamespace: DAVNamespaceShort.CARDDAV,\n        depth,\n        headers: excludeHeaders(headers, headersToExclude),\n        fetchOptions,\n        fetch: fetchOverride,\n    });\n};\nconst fetchAddressBooks = async (params) => {\n    const { account, headers, props: customProps, headersToExclude, fetchOptions = {}, fetch: fetchOverride, } = params !== null && params !== void 0 ? params : {};\n    const requiredFields = ['homeUrl', 'rootUrl'];\n    if (!account || !hasFields(account, requiredFields)) {\n        if (!account) {\n            throw new Error('no account for fetchAddressBooks');\n        }\n        throw new Error(`account must have ${findMissingFieldNames(account, requiredFields)} before fetchAddressBooks`);\n    }\n    const res = await propfind({\n        url: account.homeUrl,\n        props: customProps !== null && customProps !== void 0 ? customProps : {\n            [`${DAVNamespaceShort.DAV}:displayname`]: {},\n            [`${DAVNamespaceShort.CALENDAR_SERVER}:getctag`]: {},\n            [`${DAVNamespaceShort.DAV}:resourcetype`]: {},\n            [`${DAVNamespaceShort.DAV}:sync-token`]: {},\n        },\n        depth: '1',\n        headers: excludeHeaders(headers, headersToExclude),\n        fetchOptions,\n        fetch: fetchOverride,\n    });\n    return Promise.all(res\n        .filter((r) => { var _a, _b; return Object.keys((_b = (_a = r.props) === null || _a === void 0 ? void 0 : _a.resourcetype) !== null && _b !== void 0 ? _b : {}).includes('addressbook'); })\n        .map((rs) => {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n        const displayName = (_c = (_b = (_a = rs.props) === null || _a === void 0 ? void 0 : _a.displayname) === null || _b === void 0 ? void 0 : _b._cdata) !== null && _c !== void 0 ? _c : (_d = rs.props) === null || _d === void 0 ? void 0 : _d.displayname;\n        debug$3(`Found address book named ${typeof displayName === 'string' ? displayName : ''},\n             props: ${JSON.stringify(rs.props)}`);\n        return {\n            url: new URL((_e = rs.href) !== null && _e !== void 0 ? _e : '', (_f = account.rootUrl) !== null && _f !== void 0 ? _f : '').href,\n            ctag: (_g = rs.props) === null || _g === void 0 ? void 0 : _g.getctag,\n            displayName: typeof displayName === 'string' ? displayName : '',\n            resourcetype: Object.keys((_h = rs.props) === null || _h === void 0 ? void 0 : _h.resourcetype),\n            syncToken: (_j = rs.props) === null || _j === void 0 ? void 0 : _j.syncToken,\n        };\n    })\n        .map(async (addr) => ({\n        ...addr,\n        reports: await supportedReportSet({\n            collection: addr,\n            headers: excludeHeaders(headers, headersToExclude),\n            fetchOptions,\n            fetch: fetchOverride,\n        }),\n    })));\n};\nconst fetchVCards = async (params) => {\n    const { addressBook, headers, objectUrls, headersToExclude, urlFilter = (url) => url, useMultiGet = true, fetchOptions = {}, fetch: fetchOverride, } = params;\n    debug$3(`Fetching vcards from ${addressBook === null || addressBook === void 0 ? void 0 : addressBook.url}`);\n    const requiredFields = ['url'];\n    if (!addressBook || !hasFields(addressBook, requiredFields)) {\n        if (!addressBook) {\n            throw new Error('cannot fetchVCards for undefined addressBook');\n        }\n        throw new Error(`addressBook must have ${findMissingFieldNames(addressBook, requiredFields)} before fetchVCards`);\n    }\n    const vcardUrls = (objectUrls !== null && objectUrls !== void 0 ? objectUrls : \n    // fetch all objects of the calendar\n    (await addressBookQuery({\n        url: addressBook.url,\n        props: { [`${DAVNamespaceShort.DAV}:getetag`]: {} },\n        depth: '1',\n        headers: excludeHeaders(headers, headersToExclude),\n        fetchOptions,\n        fetch: fetchOverride,\n    })).map((res) => { var _a; return (_a = res.href) !== null && _a !== void 0 ? _a : ''; }))\n        .map((url) => (url.startsWith('http') || !url ? url : new URL(url, addressBook.url).href))\n        .filter((url) => url && !urlEquals(url, addressBook.url))\n        .filter(urlFilter)\n        .map((url) => new URL(url).pathname);\n    let vCardResults = [];\n    if (vcardUrls.length > 0) {\n        if (useMultiGet) {\n            vCardResults = await addressBookMultiGet({\n                url: addressBook.url,\n                props: {\n                    [`${DAVNamespaceShort.DAV}:getetag`]: {},\n                    [`${DAVNamespaceShort.CARDDAV}:address-data`]: {},\n                },\n                objectUrls: vcardUrls,\n                depth: '1',\n                headers: excludeHeaders(headers, headersToExclude),\n                fetchOptions,\n                fetch: fetchOverride,\n            });\n        }\n        else {\n            vCardResults = await addressBookQuery({\n                url: addressBook.url,\n                props: {\n                    [`${DAVNamespaceShort.DAV}:getetag`]: {},\n                    [`${DAVNamespaceShort.CARDDAV}:address-data`]: {},\n                },\n                depth: '1',\n                headers: excludeHeaders(headers, headersToExclude),\n                fetchOptions,\n                fetch: fetchOverride,\n            });\n        }\n    }\n    return vCardResults.map((res) => {\n        var _a, _b, _c, _d, _e, _f;\n        return ({\n            url: new URL((_a = res.href) !== null && _a !== void 0 ? _a : '', addressBook.url).href,\n            etag: (_b = res.props) === null || _b === void 0 ? void 0 : _b.getetag,\n            data: (_e = (_d = (_c = res.props) === null || _c === void 0 ? void 0 : _c.addressData) === null || _d === void 0 ? void 0 : _d._cdata) !== null && _e !== void 0 ? _e : (_f = res.props) === null || _f === void 0 ? void 0 : _f.addressData,\n        });\n    });\n};\nconst createVCard = async (params) => {\n    const { addressBook, vCardString, filename, headers, headersToExclude, fetchOptions = {}, fetch: fetchOverride, } = params;\n    return createObject({\n        url: new URL(filename, addressBook.url).href,\n        data: vCardString,\n        headers: excludeHeaders({\n            'content-type': 'text/vcard; charset=utf-8',\n            'If-None-Match': '*',\n            ...headers,\n        }, headersToExclude),\n        fetchOptions,\n        fetch: fetchOverride,\n    });\n};\nconst updateVCard = async (params) => {\n    const { vCard, headers, headersToExclude, fetchOptions = {}, fetch: fetchOverride } = params;\n    return updateObject({\n        url: vCard.url,\n        data: vCard.data,\n        etag: vCard.etag,\n        headers: excludeHeaders({\n            'content-type': 'text/vcard; charset=utf-8',\n            ...headers,\n        }, headersToExclude),\n        fetchOptions,\n        fetch: fetchOverride,\n    });\n};\nconst deleteVCard = async (params) => {\n    const { vCard, headers, headersToExclude, fetchOptions = {}, fetch: fetchOverride } = params;\n    return deleteObject({\n        url: vCard.url,\n        etag: vCard.etag,\n        headers: excludeHeaders(headers, headersToExclude),\n        fetchOptions,\n        fetch: fetchOverride,\n    });\n};\n\nvar addressBook = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    addressBookMultiGet: addressBookMultiGet,\n    addressBookQuery: addressBookQuery,\n    createVCard: createVCard,\n    deleteVCard: deleteVCard,\n    fetchAddressBooks: fetchAddressBooks,\n    fetchVCards: fetchVCards,\n    updateVCard: updateVCard\n});\n\n/* eslint-disable no-underscore-dangle */\nconst debug$2 = debug__WEBPACK_IMPORTED_MODULE_0___default()('tsdav:calendar');\nconst fetchCalendarUserAddresses = async (params) => {\n    var _a, _b, _c;\n    const { account, headers, headersToExclude, fetchOptions = {}, fetch: fetchOverride } = params;\n    const requiredFields = ['principalUrl', 'rootUrl'];\n    if (!hasFields(account, requiredFields)) {\n        throw new Error(`account must have ${findMissingFieldNames(account, requiredFields)} before fetchUserAddresses`);\n    }\n    debug$2(`Fetch user addresses from ${account.principalUrl}`);\n    const responses = await propfind({\n        url: account.principalUrl,\n        props: { [`${DAVNamespaceShort.CALDAV}:calendar-user-address-set`]: {} },\n        depth: '0',\n        headers: excludeHeaders(headers, headersToExclude),\n        fetchOptions,\n        fetch: fetchOverride,\n    });\n    const matched = responses.find((r) => urlContains(account.principalUrl, r.href));\n    if (!matched || !matched.ok) {\n        throw new Error('cannot find calendarUserAddresses');\n    }\n    const addresses = ((_c = (_b = (_a = matched === null || matched === void 0 ? void 0 : matched.props) === null || _a === void 0 ? void 0 : _a.calendarUserAddressSet) === null || _b === void 0 ? void 0 : _b.href) === null || _c === void 0 ? void 0 : _c.filter(Boolean)) || [];\n    debug$2(`Fetched calendar user addresses ${addresses}`);\n    return addresses;\n};\nconst calendarQuery = async (params) => {\n    const { url, props, filters, timezone, depth, headers, headersToExclude, fetchOptions = {}, fetch: fetchOverride, } = params;\n    return collectionQuery({\n        url,\n        body: {\n            'calendar-query': cleanupFalsy({\n                _attributes: getDAVAttribute([\n                    DAVNamespace.CALDAV,\n                    DAVNamespace.CALENDAR_SERVER,\n                    DAVNamespace.CALDAV_APPLE,\n                    DAVNamespace.DAV,\n                ]),\n                [`${DAVNamespaceShort.DAV}:prop`]: props,\n                filter: filters,\n                timezone,\n            }),\n        },\n        defaultNamespace: DAVNamespaceShort.CALDAV,\n        depth,\n        headers: excludeHeaders(headers, headersToExclude),\n        fetchOptions,\n        fetch: fetchOverride,\n    });\n};\nconst calendarMultiGet = async (params) => {\n    const { url, props, objectUrls, filters, timezone, depth, headers, headersToExclude, fetchOptions = {}, fetch: fetchOverride, } = params;\n    return collectionQuery({\n        url,\n        body: {\n            'calendar-multiget': cleanupFalsy({\n                _attributes: getDAVAttribute([DAVNamespace.DAV, DAVNamespace.CALDAV]),\n                [`${DAVNamespaceShort.DAV}:prop`]: props,\n                [`${DAVNamespaceShort.DAV}:href`]: objectUrls,\n                filter: filters,\n                timezone,\n            }),\n        },\n        defaultNamespace: DAVNamespaceShort.CALDAV,\n        depth,\n        headers: excludeHeaders(headers, headersToExclude),\n        fetchOptions,\n        fetch: fetchOverride,\n    });\n};\nconst makeCalendar = async (params) => {\n    const { url, props, depth, headers, headersToExclude, fetchOptions = {}, fetch: fetchOverride, } = params;\n    return davRequest({\n        url,\n        init: {\n            method: 'MKCALENDAR',\n            headers: excludeHeaders(cleanupFalsy({ depth, ...headers }), headersToExclude),\n            namespace: DAVNamespaceShort.DAV,\n            body: {\n                [`${DAVNamespaceShort.CALDAV}:mkcalendar`]: {\n                    _attributes: getDAVAttribute([\n                        DAVNamespace.DAV,\n                        DAVNamespace.CALDAV,\n                        DAVNamespace.CALDAV_APPLE,\n                    ]),\n                    set: {\n                        prop: props,\n                    },\n                },\n            },\n        },\n        fetchOptions,\n        fetch: fetchOverride,\n    });\n};\nconst fetchCalendars = async (params) => {\n    const { headers, account, props: customProps, projectedProps, headersToExclude, fetchOptions = {}, fetch: fetchOverride, } = params !== null && params !== void 0 ? params : {};\n    const requiredFields = ['homeUrl', 'rootUrl'];\n    if (!account || !hasFields(account, requiredFields)) {\n        if (!account) {\n            throw new Error('no account for fetchCalendars');\n        }\n        throw new Error(`account must have ${findMissingFieldNames(account, requiredFields)} before fetchCalendars`);\n    }\n    const res = await propfind({\n        url: account.homeUrl,\n        props: customProps !== null && customProps !== void 0 ? customProps : {\n            [`${DAVNamespaceShort.CALDAV}:calendar-description`]: {},\n            [`${DAVNamespaceShort.CALDAV}:calendar-timezone`]: {},\n            [`${DAVNamespaceShort.DAV}:displayname`]: {},\n            [`${DAVNamespaceShort.CALDAV_APPLE}:calendar-color`]: {},\n            [`${DAVNamespaceShort.CALENDAR_SERVER}:getctag`]: {},\n            [`${DAVNamespaceShort.DAV}:resourcetype`]: {},\n            [`${DAVNamespaceShort.CALDAV}:supported-calendar-component-set`]: {},\n            [`${DAVNamespaceShort.DAV}:sync-token`]: {},\n        },\n        depth: '1',\n        headers: excludeHeaders(headers, headersToExclude),\n        fetchOptions,\n        fetch: fetchOverride,\n    });\n    return Promise.all(res\n        .filter((r) => { var _a, _b; return Object.keys((_b = (_a = r.props) === null || _a === void 0 ? void 0 : _a.resourcetype) !== null && _b !== void 0 ? _b : {}).includes('calendar'); })\n        .filter((rc) => {\n        var _a, _b, _c, _d, _e, _f;\n        // filter out none iCal format calendars.\n        const components = Array.isArray((_b = (_a = rc.props) === null || _a === void 0 ? void 0 : _a.supportedCalendarComponentSet) === null || _b === void 0 ? void 0 : _b.comp)\n            ? (_c = rc.props) === null || _c === void 0 ? void 0 : _c.supportedCalendarComponentSet.comp.map((sc) => sc._attributes.name)\n            : [(_f = (_e = (_d = rc.props) === null || _d === void 0 ? void 0 : _d.supportedCalendarComponentSet) === null || _e === void 0 ? void 0 : _e.comp) === null || _f === void 0 ? void 0 : _f._attributes.name];\n        return components.some((c) => Object.values(ICALObjects).includes(c));\n    })\n        .map((rs) => {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;\n        // debug(`Found calendar ${rs.props?.displayname}`);\n        const description = (_a = rs.props) === null || _a === void 0 ? void 0 : _a.calendarDescription;\n        const timezone = (_b = rs.props) === null || _b === void 0 ? void 0 : _b.calendarTimezone;\n        return {\n            description: typeof description === 'string' ? description : '',\n            timezone: typeof timezone === 'string' ? timezone : '',\n            url: new URL((_c = rs.href) !== null && _c !== void 0 ? _c : '', (_d = account.rootUrl) !== null && _d !== void 0 ? _d : '').href,\n            ctag: (_e = rs.props) === null || _e === void 0 ? void 0 : _e.getctag,\n            calendarColor: (_f = rs.props) === null || _f === void 0 ? void 0 : _f.calendarColor,\n            displayName: (_h = (_g = rs.props) === null || _g === void 0 ? void 0 : _g.displayname._cdata) !== null && _h !== void 0 ? _h : (_j = rs.props) === null || _j === void 0 ? void 0 : _j.displayname,\n            components: Array.isArray((_k = rs.props) === null || _k === void 0 ? void 0 : _k.supportedCalendarComponentSet.comp)\n                ? (_l = rs.props) === null || _l === void 0 ? void 0 : _l.supportedCalendarComponentSet.comp.map((sc) => sc._attributes.name)\n                : [(_o = (_m = rs.props) === null || _m === void 0 ? void 0 : _m.supportedCalendarComponentSet.comp) === null || _o === void 0 ? void 0 : _o._attributes.name],\n            resourcetype: Object.keys((_p = rs.props) === null || _p === void 0 ? void 0 : _p.resourcetype),\n            syncToken: (_q = rs.props) === null || _q === void 0 ? void 0 : _q.syncToken,\n            ...conditionalParam('projectedProps', Object.fromEntries(Object.entries((_r = rs.props) !== null && _r !== void 0 ? _r : {}).filter(([key]) => projectedProps === null || projectedProps === void 0 ? void 0 : projectedProps[key]))),\n        };\n    })\n        .map(async (cal) => ({\n        ...cal,\n        reports: await supportedReportSet({\n            collection: cal,\n            headers: excludeHeaders(headers, headersToExclude),\n            fetchOptions,\n            fetch: fetchOverride,\n        }),\n    })));\n};\nconst fetchCalendarObjects = async (params) => {\n    const { calendar, objectUrls, filters: customFilters, timeRange, headers, expand, urlFilter = (url) => Boolean(url === null || url === void 0 ? void 0 : url.includes('.ics')), useMultiGet = true, headersToExclude, fetchOptions = {}, fetch: fetchOverride, } = params;\n    if (timeRange) {\n        // validate timeRange\n        const ISO_8601 = /^\\d{4}(-\\d\\d(-\\d\\d(T\\d\\d:\\d\\d(:\\d\\d)?(\\.\\d+)?(([+-]\\d\\d:\\d\\d)|Z)?)?)?)?$/i;\n        const ISO_8601_FULL = /^\\d{4}-\\d\\d-\\d\\dT\\d\\d:\\d\\d:\\d\\d(\\.\\d+)?(([+-]\\d\\d:\\d\\d)|Z)?$/i;\n        if ((!ISO_8601.test(timeRange.start) || !ISO_8601.test(timeRange.end)) &&\n            (!ISO_8601_FULL.test(timeRange.start) || !ISO_8601_FULL.test(timeRange.end))) {\n            throw new Error('invalid timeRange format, not in ISO8601');\n        }\n    }\n    debug$2(`Fetching calendar objects from ${calendar === null || calendar === void 0 ? void 0 : calendar.url}`);\n    const requiredFields = ['url'];\n    if (!calendar || !hasFields(calendar, requiredFields)) {\n        if (!calendar) {\n            throw new Error('cannot fetchCalendarObjects for undefined calendar');\n        }\n        throw new Error(`calendar must have ${findMissingFieldNames(calendar, requiredFields)} before fetchCalendarObjects`);\n    }\n    // default to fetch all\n    const filters = customFilters !== null && customFilters !== void 0 ? customFilters : [\n        {\n            'comp-filter': {\n                _attributes: {\n                    name: 'VCALENDAR',\n                },\n                'comp-filter': {\n                    _attributes: {\n                        name: 'VEVENT',\n                    },\n                    ...(timeRange\n                        ? {\n                            'time-range': {\n                                _attributes: {\n                                    start: `${new Date(timeRange.start)\n                                        .toISOString()\n                                        .slice(0, 19)\n                                        .replace(/[-:.]/g, '')}Z`,\n                                    end: `${new Date(timeRange.end)\n                                        .toISOString()\n                                        .slice(0, 19)\n                                        .replace(/[-:.]/g, '')}Z`,\n                                },\n                            },\n                        }\n                        : {}),\n                },\n            },\n        },\n    ];\n    let initialResponses = [];\n    const calendarObjectUrls = (objectUrls !== null && objectUrls !== void 0 ? objectUrls : \n    // fetch all objects of the calendar\n    (initialResponses = await calendarQuery({\n        url: calendar.url,\n        props: {\n            [`${DAVNamespaceShort.DAV}:getetag`]: {},\n            ...(expand && timeRange\n                ? {\n                    [`${DAVNamespaceShort.CALDAV}:calendar-data`]: {\n                        [`${DAVNamespaceShort.CALDAV}:expand`]: {\n                            _attributes: {\n                                start: `${new Date(timeRange.start)\n                                    .toISOString()\n                                    .slice(0, 19)\n                                    .replace(/[-:.]/g, '')}Z`,\n                                end: `${new Date(timeRange.end)\n                                    .toISOString()\n                                    .slice(0, 19)\n                                    .replace(/[-:.]/g, '')}Z`,\n                            },\n                        },\n                    },\n                }\n                : {}),\n        },\n        filters,\n        depth: '1',\n        headers: excludeHeaders(headers, headersToExclude),\n        fetchOptions,\n        fetch: fetchOverride,\n    })).map((res) => { var _a; return (_a = res.href) !== null && _a !== void 0 ? _a : ''; }))\n        .map((url) => (url.startsWith('http') || !url ? url : new URL(url, calendar.url).href)) // patch up to full url if url is not full\n        .filter(urlFilter) // custom filter function on calendar objects\n        .map((url) => new URL(url).pathname); // obtain pathname of the url\n    let calendarObjectResults = [];\n    if (calendarObjectUrls.length > 0) {\n        if (expand && !objectUrls) {\n            calendarObjectResults = initialResponses.filter((res) => {\n                var _a, _b;\n                const fullUrl = ((_a = res.href) !== null && _a !== void 0 ? _a : '').startsWith('http')\n                    ? res.href\n                    : new URL((_b = res.href) !== null && _b !== void 0 ? _b : '', calendar.url).href;\n                return urlFilter(fullUrl !== null && fullUrl !== void 0 ? fullUrl : '');\n            });\n        }\n        else if (!useMultiGet) {\n            calendarObjectResults = await calendarQuery({\n                url: calendar.url,\n                props: {\n                    [`${DAVNamespaceShort.DAV}:getetag`]: {},\n                    [`${DAVNamespaceShort.CALDAV}:calendar-data`]: {\n                        ...(expand && timeRange\n                            ? {\n                                [`${DAVNamespaceShort.CALDAV}:expand`]: {\n                                    _attributes: {\n                                        start: `${new Date(timeRange.start)\n                                            .toISOString()\n                                            .slice(0, 19)\n                                            .replace(/[-:.]/g, '')}Z`,\n                                        end: `${new Date(timeRange.end)\n                                            .toISOString()\n                                            .slice(0, 19)\n                                            .replace(/[-:.]/g, '')}Z`,\n                                    },\n                                },\n                            }\n                            : {}),\n                    },\n                },\n                filters,\n                depth: '1',\n                headers: excludeHeaders(headers, headersToExclude),\n                fetchOptions,\n                fetch: fetchOverride,\n            });\n        }\n        else {\n            calendarObjectResults = await calendarMultiGet({\n                url: calendar.url,\n                props: {\n                    [`${DAVNamespaceShort.DAV}:getetag`]: {},\n                    [`${DAVNamespaceShort.CALDAV}:calendar-data`]: {\n                        ...(expand && timeRange\n                            ? {\n                                [`${DAVNamespaceShort.CALDAV}:expand`]: {\n                                    _attributes: {\n                                        start: `${new Date(timeRange.start)\n                                            .toISOString()\n                                            .slice(0, 19)\n                                            .replace(/[-:.]/g, '')}Z`,\n                                        end: `${new Date(timeRange.end)\n                                            .toISOString()\n                                            .slice(0, 19)\n                                            .replace(/[-:.]/g, '')}Z`,\n                                    },\n                                },\n                            }\n                            : {}),\n                    },\n                },\n                objectUrls: calendarObjectUrls,\n                depth: '1',\n                headers: excludeHeaders(headers, headersToExclude),\n                fetchOptions,\n                fetch: fetchOverride,\n            });\n        }\n    }\n    return calendarObjectResults.map((res) => {\n        var _a, _b, _c, _d, _e, _f;\n        return ({\n            url: new URL((_a = res.href) !== null && _a !== void 0 ? _a : '', calendar.url).href,\n            etag: `${(_b = res.props) === null || _b === void 0 ? void 0 : _b.getetag}`,\n            data: (_e = (_d = (_c = res.props) === null || _c === void 0 ? void 0 : _c.calendarData) === null || _d === void 0 ? void 0 : _d._cdata) !== null && _e !== void 0 ? _e : (_f = res.props) === null || _f === void 0 ? void 0 : _f.calendarData,\n        });\n    });\n};\nconst createCalendarObject = async (params) => {\n    const { calendar, iCalString, filename, headers, headersToExclude, fetchOptions = {}, fetch: fetchOverride, } = params;\n    return createObject({\n        url: new URL(filename, calendar.url).href,\n        data: iCalString,\n        headers: excludeHeaders({\n            'content-type': 'text/calendar; charset=utf-8',\n            'If-None-Match': '*',\n            ...headers,\n        }, headersToExclude),\n        fetchOptions,\n        fetch: fetchOverride,\n    });\n};\nconst updateCalendarObject = async (params) => {\n    const { calendarObject, headers, headersToExclude, fetchOptions = {}, fetch: fetchOverride, } = params;\n    return updateObject({\n        url: calendarObject.url,\n        data: calendarObject.data,\n        etag: calendarObject.etag,\n        headers: excludeHeaders({\n            'content-type': 'text/calendar; charset=utf-8',\n            ...headers,\n        }, headersToExclude),\n        fetchOptions,\n        fetch: fetchOverride,\n    });\n};\nconst deleteCalendarObject = async (params) => {\n    const { calendarObject, headers, headersToExclude, fetchOptions = {}, fetch: fetchOverride, } = params;\n    return deleteObject({\n        url: calendarObject.url,\n        etag: calendarObject.etag,\n        headers: excludeHeaders(headers, headersToExclude),\n        fetchOptions,\n        fetch: fetchOverride,\n    });\n};\n/**\n * Sync remote calendars to local\n */\nconst syncCalendars = async (params) => {\n    var _a;\n    const { oldCalendars, account, detailedResult, headers, headersToExclude, fetchOptions = {}, fetch: fetchOverride, } = params;\n    if (!account) {\n        throw new Error('Must have account before syncCalendars');\n    }\n    const localCalendars = (_a = oldCalendars !== null && oldCalendars !== void 0 ? oldCalendars : account.calendars) !== null && _a !== void 0 ? _a : [];\n    const remoteCalendars = await fetchCalendars({\n        account,\n        headers: excludeHeaders(headers, headersToExclude),\n        fetchOptions,\n        fetch: fetchOverride,\n    });\n    // no existing url\n    const created = remoteCalendars.filter((rc) => localCalendars.every((lc) => !urlContains(lc.url, rc.url)));\n    debug$2(`new calendars: ${created.map((cc) => cc.displayName)}`);\n    // have same url, but syncToken/ctag different\n    const updated = localCalendars.reduce((prev, curr) => {\n        const found = remoteCalendars.find((rc) => urlContains(rc.url, curr.url));\n        if (found &&\n            ((found.syncToken && `${found.syncToken}` !== `${curr.syncToken}`) ||\n                (found.ctag && `${found.ctag}` !== `${curr.ctag}`))) {\n            return [...prev, found];\n        }\n        return prev;\n    }, []);\n    debug$2(`updated calendars: ${updated.map((cc) => cc.displayName)}`);\n    const updatedWithObjects = await Promise.all(updated.map(async (u) => {\n        const result = await smartCollectionSync({\n            collection: { ...u, objectMultiGet: calendarMultiGet },\n            method: 'webdav',\n            headers: excludeHeaders(headers, headersToExclude),\n            account,\n            fetchOptions,\n            fetch: fetchOverride,\n        });\n        return result;\n    }));\n    // does not present in remote\n    const deleted = localCalendars.filter((cal) => remoteCalendars.every((rc) => !urlContains(rc.url, cal.url)));\n    debug$2(`deleted calendars: ${deleted.map((cc) => cc.displayName)}`);\n    const unchanged = localCalendars.filter((cal) => remoteCalendars.some((rc) => urlContains(rc.url, cal.url) &&\n        ((rc.syncToken && `${rc.syncToken}` !== `${cal.syncToken}`) ||\n            (rc.ctag && `${rc.ctag}` !== `${cal.ctag}`))));\n    // debug(`unchanged calendars: ${unchanged.map((cc) => cc.displayName)}`);\n    return detailedResult\n        ? {\n            created,\n            updated,\n            deleted,\n        }\n        : [...unchanged, ...created, ...updatedWithObjects];\n};\nconst freeBusyQuery = async (params) => {\n    const { url, timeRange, depth, headers, headersToExclude, fetchOptions = {}, fetch: fetchOverride, } = params;\n    if (timeRange) {\n        // validate timeRange\n        const ISO_8601 = /^\\d{4}(-\\d\\d(-\\d\\d(T\\d\\d:\\d\\d(:\\d\\d)?(\\.\\d+)?(([+-]\\d\\d:\\d\\d)|Z)?)?)?)?$/i;\n        const ISO_8601_FULL = /^\\d{4}-\\d\\d-\\d\\dT\\d\\d:\\d\\d:\\d\\d(\\.\\d+)?(([+-]\\d\\d:\\d\\d)|Z)?$/i;\n        if ((!ISO_8601.test(timeRange.start) || !ISO_8601.test(timeRange.end)) &&\n            (!ISO_8601_FULL.test(timeRange.start) || !ISO_8601_FULL.test(timeRange.end))) {\n            throw new Error('invalid timeRange format, not in ISO8601');\n        }\n    }\n    else {\n        throw new Error('timeRange is required');\n    }\n    const result = await collectionQuery({\n        url,\n        body: {\n            'free-busy-query': cleanupFalsy({\n                _attributes: getDAVAttribute([DAVNamespace.CALDAV]),\n                [`${DAVNamespaceShort.CALDAV}:time-range`]: {\n                    _attributes: {\n                        start: `${new Date(timeRange.start).toISOString().slice(0, 19).replace(/[-:.]/g, '')}Z`,\n                        end: `${new Date(timeRange.end).toISOString().slice(0, 19).replace(/[-:.]/g, '')}Z`,\n                    },\n                },\n            }),\n        },\n        defaultNamespace: DAVNamespaceShort.CALDAV,\n        depth,\n        headers: excludeHeaders(headers, headersToExclude),\n        fetchOptions,\n        fetch: fetchOverride,\n    });\n    return result[0];\n};\n\nvar calendar = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    calendarMultiGet: calendarMultiGet,\n    calendarQuery: calendarQuery,\n    createCalendarObject: createCalendarObject,\n    deleteCalendarObject: deleteCalendarObject,\n    fetchCalendarObjects: fetchCalendarObjects,\n    fetchCalendarUserAddresses: fetchCalendarUserAddresses,\n    fetchCalendars: fetchCalendars,\n    freeBusyQuery: freeBusyQuery,\n    makeCalendar: makeCalendar,\n    syncCalendars: syncCalendars,\n    updateCalendarObject: updateCalendarObject\n});\n\nconst debug$1 = debug__WEBPACK_IMPORTED_MODULE_0___default()('tsdav:account');\nconst serviceDiscovery = async (params) => {\n    var _a, _b;\n    debug$1('Service discovery...');\n    const { account, headers, headersToExclude, fetchOptions = {}, fetch: fetchOverride } = params;\n    const requestFetch = fetchOverride !== null && fetchOverride !== void 0 ? fetchOverride : fetch;\n    const endpoint = new URL(account.serverUrl);\n    const uri = new URL(`/.well-known/${account.accountType}`, endpoint);\n    uri.protocol = (_a = endpoint.protocol) !== null && _a !== void 0 ? _a : 'http';\n    try {\n        const response = await requestFetch(uri.href, {\n            headers: {\n                ...excludeHeaders(headers, headersToExclude),\n                'Content-Type': 'text/xml;charset=UTF-8',\n            },\n            method: 'PROPFIND',\n            body: `<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<d:propfind xmlns:d=\"DAV:\">\n  <d:prop>\n    <d:resourcetype/>\n  </d:prop>\n</d:propfind>`,\n            redirect: 'manual',\n            ...fetchOptions,\n        });\n        if (response.status >= 300 && response.status < 400) {\n            // http redirect.\n            const location = response.headers.get('Location');\n            if (typeof location === 'string' && location.length) {\n                debug$1(`Service discovery redirected to ${location}`);\n                const serviceURL = new URL(location, endpoint);\n                if (serviceURL.hostname === uri.hostname && uri.port && !serviceURL.port) {\n                    serviceURL.port = uri.port;\n                }\n                serviceURL.protocol = (_b = endpoint.protocol) !== null && _b !== void 0 ? _b : 'http';\n                return serviceURL.href;\n            }\n        }\n    }\n    catch (err) {\n        debug$1(`Service discovery failed: ${err.stack}`);\n    }\n    return endpoint.href;\n};\nconst fetchPrincipalUrl = async (params) => {\n    var _a, _b, _c, _d, _e;\n    const { account, headers, headersToExclude, fetchOptions = {}, fetch: fetchOverride } = params;\n    const requiredFields = ['rootUrl'];\n    if (!hasFields(account, requiredFields)) {\n        throw new Error(`account must have ${findMissingFieldNames(account, requiredFields)} before fetchPrincipalUrl`);\n    }\n    debug$1(`Fetching principal url from path ${account.rootUrl}`);\n    const [response] = await propfind({\n        url: account.rootUrl,\n        props: {\n            [`${DAVNamespaceShort.DAV}:current-user-principal`]: {},\n        },\n        depth: '0',\n        headers: excludeHeaders(headers, headersToExclude),\n        fetchOptions,\n        fetch: fetchOverride,\n    });\n    if (!response.ok) {\n        debug$1(`Fetch principal url failed: ${response.statusText}`);\n        if (response.status === 401) {\n            throw new Error('Invalid credentials');\n        }\n    }\n    debug$1(`Fetched principal url ${(_b = (_a = response.props) === null || _a === void 0 ? void 0 : _a.currentUserPrincipal) === null || _b === void 0 ? void 0 : _b.href}`);\n    return new URL((_e = (_d = (_c = response.props) === null || _c === void 0 ? void 0 : _c.currentUserPrincipal) === null || _d === void 0 ? void 0 : _d.href) !== null && _e !== void 0 ? _e : '', account.rootUrl).href;\n};\nconst fetchHomeUrl = async (params) => {\n    var _a, _b;\n    const { account, headers, headersToExclude, fetchOptions = {}, fetch: fetchOverride } = params;\n    const requiredFields = ['principalUrl', 'rootUrl'];\n    if (!hasFields(account, requiredFields)) {\n        throw new Error(`account must have ${findMissingFieldNames(account, requiredFields)} before fetchHomeUrl`);\n    }\n    debug$1(`Fetch home url from ${account.principalUrl}`);\n    const responses = await propfind({\n        url: account.principalUrl,\n        props: account.accountType === 'caldav'\n            ? { [`${DAVNamespaceShort.CALDAV}:calendar-home-set`]: {} }\n            : { [`${DAVNamespaceShort.CARDDAV}:addressbook-home-set`]: {} },\n        depth: '0',\n        headers: excludeHeaders(headers, headersToExclude),\n        fetchOptions,\n        fetch: fetchOverride,\n    });\n    const matched = responses.find((r) => urlContains(account.principalUrl, r.href));\n    if (!matched || !matched.ok) {\n        debug$1(`Fetch home url failed with status ${matched === null || matched === void 0 ? void 0 : matched.statusText} and error ${JSON.stringify(responses.map((r) => r.error))}`);\n        throw new Error('cannot find homeUrl');\n    }\n    const result = new URL(account.accountType === 'caldav'\n        ? (_a = matched === null || matched === void 0 ? void 0 : matched.props) === null || _a === void 0 ? void 0 : _a.calendarHomeSet.href\n        : (_b = matched === null || matched === void 0 ? void 0 : matched.props) === null || _b === void 0 ? void 0 : _b.addressbookHomeSet.href, account.rootUrl).href;\n    debug$1(`Fetched home url ${result}`);\n    return result;\n};\nconst createAccount = async (params) => {\n    const { account, headers, loadCollections = false, loadObjects = false, headersToExclude, fetchOptions = {}, fetch: fetchOverride, } = params;\n    const newAccount = { ...account };\n    newAccount.rootUrl = await serviceDiscovery({\n        account,\n        headers: excludeHeaders(headers, headersToExclude),\n        fetchOptions,\n        fetch: fetchOverride,\n    });\n    newAccount.principalUrl = await fetchPrincipalUrl({\n        account: newAccount,\n        headers: excludeHeaders(headers, headersToExclude),\n        fetchOptions,\n        fetch: fetchOverride,\n    });\n    newAccount.homeUrl = await fetchHomeUrl({\n        account: newAccount,\n        headers: excludeHeaders(headers, headersToExclude),\n        fetchOptions,\n        fetch: fetchOverride,\n    });\n    // to load objects you must first load collections\n    if (loadCollections || loadObjects) {\n        if (account.accountType === 'caldav') {\n            newAccount.calendars = await fetchCalendars({\n                headers: excludeHeaders(headers, headersToExclude),\n                account: newAccount,\n                fetchOptions,\n                fetch: fetchOverride,\n            });\n        }\n        else if (account.accountType === 'carddav') {\n            newAccount.addressBooks = await fetchAddressBooks({\n                headers: excludeHeaders(headers, headersToExclude),\n                account: newAccount,\n                fetchOptions,\n                fetch: fetchOverride,\n            });\n        }\n    }\n    if (loadObjects) {\n        if (account.accountType === 'caldav' && newAccount.calendars) {\n            newAccount.calendars = await Promise.all(newAccount.calendars.map(async (cal) => ({\n                ...cal,\n                objects: await fetchCalendarObjects({\n                    calendar: cal,\n                    headers: excludeHeaders(headers, headersToExclude),\n                    fetchOptions,\n                    fetch: fetchOverride,\n                }),\n            })));\n        }\n        else if (account.accountType === 'carddav' && newAccount.addressBooks) {\n            newAccount.addressBooks = await Promise.all(newAccount.addressBooks.map(async (addr) => ({\n                ...addr,\n                objects: await fetchVCards({\n                    addressBook: addr,\n                    headers: excludeHeaders(headers, headersToExclude),\n                    fetchOptions,\n                    fetch: fetchOverride,\n                }),\n            })));\n        }\n    }\n    return newAccount;\n};\n\nvar account = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    createAccount: createAccount,\n    fetchHomeUrl: fetchHomeUrl,\n    fetchPrincipalUrl: fetchPrincipalUrl,\n    serviceDiscovery: serviceDiscovery\n});\n\nconst debug = debug__WEBPACK_IMPORTED_MODULE_0___default()('tsdav:authHelper');\n/**\n * Provide given params as default params to given function with optional params.\n *\n * suitable only for one param functions\n * params are shallow merged\n */\nconst defaultParam = (fn, params) => (...args) => {\n    return fn({ ...params, ...args[0] });\n};\nconst getBasicAuthHeaders = (credentials) => {\n    debug(`Basic auth token generated: ${(0,base_64__WEBPACK_IMPORTED_MODULE_3__.encode)(`${credentials.username}:${credentials.password}`)}`);\n    return {\n        authorization: `Basic ${(0,base_64__WEBPACK_IMPORTED_MODULE_3__.encode)(`${credentials.username}:${credentials.password}`)}`,\n    };\n};\nconst getBearerAuthHeaders = (credentials) => {\n    return {\n        authorization: `Bearer ${credentials.accessToken}`,\n    };\n};\nconst fetchOauthTokens = async (credentials, fetchOptions, fetchOverride) => {\n    const requireFields = [\n        'authorizationCode',\n        'redirectUrl',\n        'clientId',\n        'clientSecret',\n        'tokenUrl',\n    ];\n    if (!hasFields(credentials, requireFields)) {\n        throw new Error(`Oauth credentials missing: ${findMissingFieldNames(credentials, requireFields)}`);\n    }\n    const param = new URLSearchParams({\n        grant_type: 'authorization_code',\n        code: credentials.authorizationCode,\n        redirect_uri: credentials.redirectUrl,\n        client_id: credentials.clientId,\n        client_secret: credentials.clientSecret,\n    });\n    debug(credentials.tokenUrl);\n    debug(param.toString());\n    const requestFetch = fetchOverride !== null && fetchOverride !== void 0 ? fetchOverride : fetch;\n    const response = await requestFetch(credentials.tokenUrl, {\n        method: 'POST',\n        body: param.toString(),\n        headers: {\n            'content-length': `${param.toString().length}`,\n            'content-type': 'application/x-www-form-urlencoded',\n        },\n        ...(fetchOptions !== null && fetchOptions !== void 0 ? fetchOptions : {}),\n    });\n    if (response.ok) {\n        const tokens = await response.json();\n        return tokens;\n    }\n    debug(`Fetch Oauth tokens failed: ${await response.text()}`);\n    return {};\n};\nconst refreshAccessToken = async (credentials, fetchOptions, fetchOverride) => {\n    const requireFields = [\n        'refreshToken',\n        'clientId',\n        'clientSecret',\n        'tokenUrl',\n    ];\n    if (!hasFields(credentials, requireFields)) {\n        throw new Error(`Oauth credentials missing: ${findMissingFieldNames(credentials, requireFields)}`);\n    }\n    const param = new URLSearchParams({\n        client_id: credentials.clientId,\n        client_secret: credentials.clientSecret,\n        refresh_token: credentials.refreshToken,\n        grant_type: 'refresh_token',\n    });\n    const requestFetch = fetchOverride !== null && fetchOverride !== void 0 ? fetchOverride : fetch;\n    const response = await requestFetch(credentials.tokenUrl, {\n        method: 'POST',\n        body: param.toString(),\n        headers: {\n            'Content-Type': 'application/x-www-form-urlencoded',\n        },\n        ...(fetchOptions !== null && fetchOptions !== void 0 ? fetchOptions : {}),\n    });\n    if (response.ok) {\n        const tokens = await response.json();\n        return tokens;\n    }\n    debug(`Refresh access token failed: ${await response.text()}`);\n    return {};\n};\nconst getOauthHeaders = async (credentials, fetchOptions, fetchOverride) => {\n    var _a;\n    debug('Fetching oauth headers');\n    let tokens = {};\n    if (!credentials.refreshToken) {\n        // No refresh token, fetch new tokens\n        tokens = await fetchOauthTokens(credentials, fetchOptions, fetchOverride);\n    }\n    else if ((credentials.refreshToken && !credentials.accessToken) ||\n        Date.now() > ((_a = credentials.expiration) !== null && _a !== void 0 ? _a : 0)) {\n        // have refresh token, but no accessToken, fetch access token only\n        // or have both, but accessToken was expired\n        tokens = await refreshAccessToken(credentials, fetchOptions, fetchOverride);\n    }\n    // now we should have valid access token\n    debug(`Oauth tokens fetched: ${tokens.access_token}`);\n    return {\n        tokens,\n        headers: {\n            authorization: `Bearer ${tokens.access_token}`,\n        },\n    };\n};\n\nvar authHelpers = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    defaultParam: defaultParam,\n    fetchOauthTokens: fetchOauthTokens,\n    getBasicAuthHeaders: getBasicAuthHeaders,\n    getBearerAuthHeaders: getBearerAuthHeaders,\n    getOauthHeaders: getOauthHeaders,\n    refreshAccessToken: refreshAccessToken\n});\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nconst createDAVClient = async (params) => {\n    var _a;\n    const { serverUrl, credentials, authMethod, defaultAccountType, authFunction, fetch: fetchOverride, } = params;\n    let authHeaders = {};\n    switch (authMethod) {\n        case 'Basic':\n            authHeaders = getBasicAuthHeaders(credentials);\n            break;\n        case 'Bearer':\n            authHeaders = getBearerAuthHeaders(credentials);\n            break;\n        case 'Oauth':\n            authHeaders = (await getOauthHeaders(credentials, undefined, fetchOverride)).headers;\n            break;\n        case 'Digest':\n            authHeaders = {\n                Authorization: `Digest ${credentials.digestString}`,\n            };\n            break;\n        case 'Custom':\n            authHeaders = (_a = (await (authFunction === null || authFunction === void 0 ? void 0 : authFunction(credentials)))) !== null && _a !== void 0 ? _a : {};\n            break;\n        default:\n            throw new Error('Invalid auth method');\n    }\n    const defaultAccount = defaultAccountType\n        ? await createAccount({\n            account: { serverUrl, credentials, accountType: defaultAccountType },\n            headers: authHeaders,\n            fetch: fetchOverride,\n        })\n        : undefined;\n    const davRequest$1 = async (params0) => {\n        const { init, fetch: fetchOverride2, ...rest } = params0;\n        const { headers, ...restInit } = init;\n        return davRequest({\n            ...rest,\n            init: {\n                ...restInit,\n                headers: {\n                    ...authHeaders,\n                    ...headers,\n                },\n            },\n            fetch: fetchOverride2 !== null && fetchOverride2 !== void 0 ? fetchOverride2 : fetchOverride,\n        });\n    };\n    const createObject$1 = defaultParam(createObject, {\n        url: serverUrl,\n        headers: authHeaders,\n        fetch: fetchOverride,\n    });\n    const updateObject$1 = defaultParam(updateObject, {\n        headers: authHeaders,\n        url: serverUrl,\n        fetch: fetchOverride,\n    });\n    const deleteObject$1 = defaultParam(deleteObject, {\n        headers: authHeaders,\n        url: serverUrl,\n        fetch: fetchOverride,\n    });\n    const propfind$1 = defaultParam(propfind, { headers: authHeaders, fetch: fetchOverride });\n    // account\n    const createAccount$1 = async (params0) => {\n        const { account, headers, loadCollections, loadObjects, fetch: fetchOverride2 } = params0;\n        return createAccount({\n            account: { serverUrl, credentials, ...account },\n            headers: { ...authHeaders, ...headers },\n            loadCollections,\n            loadObjects,\n            fetch: fetchOverride2 !== null && fetchOverride2 !== void 0 ? fetchOverride2 : fetchOverride,\n        });\n    };\n    // collection\n    const collectionQuery$1 = defaultParam(collectionQuery, {\n        headers: authHeaders,\n        fetch: fetchOverride,\n    });\n    const makeCollection$1 = defaultParam(makeCollection, {\n        headers: authHeaders,\n        fetch: fetchOverride,\n    });\n    const syncCollection$1 = defaultParam(syncCollection, {\n        headers: authHeaders,\n        fetch: fetchOverride,\n    });\n    const supportedReportSet$1 = defaultParam(supportedReportSet, {\n        headers: authHeaders,\n        fetch: fetchOverride,\n    });\n    const isCollectionDirty$1 = defaultParam(isCollectionDirty, {\n        headers: authHeaders,\n        fetch: fetchOverride,\n    });\n    const smartCollectionSync$1 = defaultParam(smartCollectionSync, {\n        headers: authHeaders,\n        account: defaultAccount,\n        fetch: fetchOverride,\n    });\n    // calendar\n    const calendarQuery$1 = defaultParam(calendarQuery, {\n        headers: authHeaders,\n        fetch: fetchOverride,\n    });\n    const calendarMultiGet$1 = defaultParam(calendarMultiGet, {\n        headers: authHeaders,\n        fetch: fetchOverride,\n    });\n    const makeCalendar$1 = defaultParam(makeCalendar, {\n        headers: authHeaders,\n        fetch: fetchOverride,\n    });\n    const fetchCalendars$1 = defaultParam(fetchCalendars, {\n        headers: authHeaders,\n        account: defaultAccount,\n        fetch: fetchOverride,\n    });\n    const fetchCalendarUserAddresses$1 = defaultParam(fetchCalendarUserAddresses, {\n        headers: authHeaders,\n        account: defaultAccount,\n        fetch: fetchOverride,\n    });\n    const fetchCalendarObjects$1 = defaultParam(fetchCalendarObjects, {\n        headers: authHeaders,\n        fetch: fetchOverride,\n    });\n    const createCalendarObject$1 = defaultParam(createCalendarObject, {\n        headers: authHeaders,\n        fetch: fetchOverride,\n    });\n    const updateCalendarObject$1 = defaultParam(updateCalendarObject, {\n        headers: authHeaders,\n        fetch: fetchOverride,\n    });\n    const deleteCalendarObject$1 = defaultParam(deleteCalendarObject, {\n        headers: authHeaders,\n        fetch: fetchOverride,\n    });\n    const syncCalendars$1 = defaultParam(syncCalendars, {\n        account: defaultAccount,\n        headers: authHeaders,\n        fetch: fetchOverride,\n    });\n    // addressBook\n    const addressBookQuery$1 = defaultParam(addressBookQuery, {\n        headers: authHeaders,\n        fetch: fetchOverride,\n    });\n    const addressBookMultiGet$1 = defaultParam(addressBookMultiGet, {\n        headers: authHeaders,\n        fetch: fetchOverride,\n    });\n    const fetchAddressBooks$1 = defaultParam(fetchAddressBooks, {\n        account: defaultAccount,\n        headers: authHeaders,\n        fetch: fetchOverride,\n    });\n    const fetchVCards$1 = defaultParam(fetchVCards, {\n        headers: authHeaders,\n        fetch: fetchOverride,\n    });\n    const createVCard$1 = defaultParam(createVCard, {\n        headers: authHeaders,\n        fetch: fetchOverride,\n    });\n    const updateVCard$1 = defaultParam(updateVCard, {\n        headers: authHeaders,\n        fetch: fetchOverride,\n    });\n    const deleteVCard$1 = defaultParam(deleteVCard, {\n        headers: authHeaders,\n        fetch: fetchOverride,\n    });\n    return {\n        davRequest: davRequest$1,\n        propfind: propfind$1,\n        createAccount: createAccount$1,\n        createObject: createObject$1,\n        updateObject: updateObject$1,\n        deleteObject: deleteObject$1,\n        calendarQuery: calendarQuery$1,\n        addressBookQuery: addressBookQuery$1,\n        collectionQuery: collectionQuery$1,\n        makeCollection: makeCollection$1,\n        calendarMultiGet: calendarMultiGet$1,\n        makeCalendar: makeCalendar$1,\n        syncCollection: syncCollection$1,\n        supportedReportSet: supportedReportSet$1,\n        isCollectionDirty: isCollectionDirty$1,\n        smartCollectionSync: smartCollectionSync$1,\n        fetchCalendars: fetchCalendars$1,\n        fetchCalendarUserAddresses: fetchCalendarUserAddresses$1,\n        fetchCalendarObjects: fetchCalendarObjects$1,\n        createCalendarObject: createCalendarObject$1,\n        updateCalendarObject: updateCalendarObject$1,\n        deleteCalendarObject: deleteCalendarObject$1,\n        syncCalendars: syncCalendars$1,\n        fetchAddressBooks: fetchAddressBooks$1,\n        addressBookMultiGet: addressBookMultiGet$1,\n        fetchVCards: fetchVCards$1,\n        createVCard: createVCard$1,\n        updateVCard: updateVCard$1,\n        deleteVCard: deleteVCard$1,\n    };\n};\nclass DAVClient {\n    constructor(params) {\n        var _a, _b, _c;\n        this.serverUrl = params.serverUrl;\n        this.credentials = params.credentials;\n        this.authMethod = (_a = params.authMethod) !== null && _a !== void 0 ? _a : 'Basic';\n        this.accountType = (_b = params.defaultAccountType) !== null && _b !== void 0 ? _b : 'caldav';\n        this.authFunction = params.authFunction;\n        this.fetchOptions = (_c = params.fetchOptions) !== null && _c !== void 0 ? _c : {};\n        this.fetchOverride = params.fetch;\n    }\n    async login() {\n        var _a;\n        switch (this.authMethod) {\n            case 'Basic':\n                this.authHeaders = getBasicAuthHeaders(this.credentials);\n                break;\n            case 'Bearer':\n                this.authHeaders = getBearerAuthHeaders(this.credentials);\n                break;\n            case 'Oauth':\n                this.authHeaders = (await getOauthHeaders(this.credentials, this.fetchOptions, this.fetchOverride)).headers;\n                break;\n            case 'Digest':\n                this.authHeaders = {\n                    Authorization: `Digest ${this.credentials.digestString}`,\n                };\n                break;\n            case 'Custom':\n                this.authHeaders = await ((_a = this.authFunction) === null || _a === void 0 ? void 0 : _a.call(this, this.credentials));\n                break;\n            default:\n                throw new Error('Invalid auth method');\n        }\n        this.account = this.accountType\n            ? await createAccount({\n                account: {\n                    serverUrl: this.serverUrl,\n                    credentials: this.credentials,\n                    accountType: this.accountType,\n                },\n                headers: this.authHeaders,\n                fetchOptions: this.fetchOptions,\n                fetch: this.fetchOverride,\n            })\n            : undefined;\n    }\n    async davRequest(params0) {\n        const { init, fetch: fetchOverride2, ...rest } = params0;\n        const { headers, ...restInit } = init;\n        return davRequest({\n            ...rest,\n            init: {\n                ...restInit,\n                headers: {\n                    ...this.authHeaders,\n                    ...headers,\n                },\n            },\n            fetchOptions: this.fetchOptions,\n            fetch: fetchOverride2 !== null && fetchOverride2 !== void 0 ? fetchOverride2 : this.fetchOverride,\n        });\n    }\n    async createObject(...params) {\n        return defaultParam(createObject, {\n            url: this.serverUrl,\n            headers: this.authHeaders,\n            fetchOptions: this.fetchOptions,\n            fetch: this.fetchOverride,\n        })(params[0]);\n    }\n    async updateObject(...params) {\n        return defaultParam(updateObject, {\n            url: this.serverUrl,\n            headers: this.authHeaders,\n            fetchOptions: this.fetchOptions,\n            fetch: this.fetchOverride,\n        })(params[0]);\n    }\n    async deleteObject(...params) {\n        return defaultParam(deleteObject, {\n            url: this.serverUrl,\n            headers: this.authHeaders,\n            fetchOptions: this.fetchOptions,\n            fetch: this.fetchOverride,\n        })(params[0]);\n    }\n    async propfind(...params) {\n        return defaultParam(propfind, {\n            headers: this.authHeaders,\n            fetchOptions: this.fetchOptions,\n            fetch: this.fetchOverride,\n        })(params[0]);\n    }\n    async createAccount(params0) {\n        const { account, headers, loadCollections, loadObjects, fetchOptions, fetch } = params0;\n        return createAccount({\n            account: { serverUrl: this.serverUrl, credentials: this.credentials, ...account },\n            headers: { ...this.authHeaders, ...headers },\n            loadCollections,\n            loadObjects,\n            fetchOptions: fetchOptions !== null && fetchOptions !== void 0 ? fetchOptions : this.fetchOptions,\n            fetch: fetch !== null && fetch !== void 0 ? fetch : this.fetchOverride,\n        });\n    }\n    async collectionQuery(...params) {\n        return defaultParam(collectionQuery, {\n            headers: this.authHeaders,\n            fetchOptions: this.fetchOptions,\n            fetch: this.fetchOverride,\n        })(params[0]);\n    }\n    async makeCollection(...params) {\n        return defaultParam(makeCollection, {\n            headers: this.authHeaders,\n            fetchOptions: this.fetchOptions,\n            fetch: this.fetchOverride,\n        })(params[0]);\n    }\n    async syncCollection(...params) {\n        return defaultParam(syncCollection, {\n            headers: this.authHeaders,\n            fetchOptions: this.fetchOptions,\n            fetch: this.fetchOverride,\n        })(params[0]);\n    }\n    async supportedReportSet(...params) {\n        return defaultParam(supportedReportSet, {\n            headers: this.authHeaders,\n            fetchOptions: this.fetchOptions,\n            fetch: this.fetchOverride,\n        })(params[0]);\n    }\n    async isCollectionDirty(...params) {\n        return defaultParam(isCollectionDirty, {\n            headers: this.authHeaders,\n            fetchOptions: this.fetchOptions,\n            fetch: this.fetchOverride,\n        })(params[0]);\n    }\n    async smartCollectionSync(...params) {\n        return defaultParam(smartCollectionSync, {\n            headers: this.authHeaders,\n            fetchOptions: this.fetchOptions,\n            fetch: this.fetchOverride,\n            account: this.account,\n        })(params[0]);\n    }\n    async calendarQuery(...params) {\n        return defaultParam(calendarQuery, {\n            headers: this.authHeaders,\n            fetchOptions: this.fetchOptions,\n            fetch: this.fetchOverride,\n        })(params[0]);\n    }\n    async makeCalendar(...params) {\n        return defaultParam(makeCalendar, {\n            headers: this.authHeaders,\n            fetchOptions: this.fetchOptions,\n            fetch: this.fetchOverride,\n        })(params[0]);\n    }\n    async calendarMultiGet(...params) {\n        return defaultParam(calendarMultiGet, {\n            headers: this.authHeaders,\n            fetchOptions: this.fetchOptions,\n            fetch: this.fetchOverride,\n        })(params[0]);\n    }\n    async fetchCalendars(...params) {\n        return defaultParam(fetchCalendars, {\n            headers: this.authHeaders,\n            account: this.account,\n            fetchOptions: this.fetchOptions,\n            fetch: this.fetchOverride,\n        })(params === null || params === void 0 ? void 0 : params[0]);\n    }\n    async fetchCalendarUserAddresses(...params) {\n        return defaultParam(fetchCalendarUserAddresses, {\n            headers: this.authHeaders,\n            account: this.account,\n            fetchOptions: this.fetchOptions,\n            fetch: this.fetchOverride,\n        })(params === null || params === void 0 ? void 0 : params[0]);\n    }\n    async fetchCalendarObjects(...params) {\n        return defaultParam(fetchCalendarObjects, {\n            headers: this.authHeaders,\n            fetchOptions: this.fetchOptions,\n            fetch: this.fetchOverride,\n        })(params[0]);\n    }\n    async createCalendarObject(...params) {\n        return defaultParam(createCalendarObject, {\n            headers: this.authHeaders,\n            fetchOptions: this.fetchOptions,\n            fetch: this.fetchOverride,\n        })(params[0]);\n    }\n    async updateCalendarObject(...params) {\n        return defaultParam(updateCalendarObject, {\n            headers: this.authHeaders,\n            fetchOptions: this.fetchOptions,\n            fetch: this.fetchOverride,\n        })(params[0]);\n    }\n    async deleteCalendarObject(...params) {\n        return defaultParam(deleteCalendarObject, {\n            headers: this.authHeaders,\n            fetchOptions: this.fetchOptions,\n            fetch: this.fetchOverride,\n        })(params[0]);\n    }\n    async syncCalendars(...params) {\n        return defaultParam(syncCalendars, {\n            headers: this.authHeaders,\n            account: this.account,\n            fetchOptions: this.fetchOptions,\n            fetch: this.fetchOverride,\n        })(params[0]);\n    }\n    async addressBookQuery(...params) {\n        return defaultParam(addressBookQuery, {\n            headers: this.authHeaders,\n            fetchOptions: this.fetchOptions,\n            fetch: this.fetchOverride,\n        })(params[0]);\n    }\n    async addressBookMultiGet(...params) {\n        return defaultParam(addressBookMultiGet, {\n            headers: this.authHeaders,\n            fetchOptions: this.fetchOptions,\n            fetch: this.fetchOverride,\n        })(params[0]);\n    }\n    async fetchAddressBooks(...params) {\n        return defaultParam(fetchAddressBooks, {\n            headers: this.authHeaders,\n            account: this.account,\n            fetchOptions: this.fetchOptions,\n            fetch: this.fetchOverride,\n        })(params === null || params === void 0 ? void 0 : params[0]);\n    }\n    async fetchVCards(...params) {\n        return defaultParam(fetchVCards, {\n            headers: this.authHeaders,\n            fetchOptions: this.fetchOptions,\n            fetch: this.fetchOverride,\n        })(params[0]);\n    }\n    async createVCard(...params) {\n        return defaultParam(createVCard, {\n            headers: this.authHeaders,\n            fetchOptions: this.fetchOptions,\n            fetch: this.fetchOverride,\n        })(params[0]);\n    }\n    async updateVCard(...params) {\n        return defaultParam(updateVCard, {\n            headers: this.authHeaders,\n            fetchOptions: this.fetchOptions,\n            fetch: this.fetchOverride,\n        })(params[0]);\n    }\n    async deleteVCard(...params) {\n        return defaultParam(deleteVCard, {\n            headers: this.authHeaders,\n            fetchOptions: this.fetchOptions,\n            fetch: this.fetchOverride,\n        })(params[0]);\n    }\n}\n\nvar client = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    DAVClient: DAVClient,\n    createDAVClient: createDAVClient\n});\n\nvar index = {\n    DAVNamespace,\n    DAVNamespaceShort,\n    DAVAttributeMap,\n    ...client,\n    ...request,\n    ...collection,\n    ...account,\n    ...addressBook,\n    ...calendar,\n    ...authHelpers,\n    ...requestHelpers,\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdHNkYXYvZGlzdC90c2Rhdi5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE4QjtBQUNEO0FBQ1E7QUFDSjs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9DQUFvQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4Q0FBOEM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0NBQWtDOztBQUVuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG9EQUFVO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLHdDQUF3QyxLQUFLO0FBQ2hIO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxDQUFDLElBQUk7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELGdCQUFnQiw0Q0FBUztBQUN6QjtBQUNBO0FBQ0EsWUFBWSwwRUFB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QUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU4dUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wZXJzb25hbC1saWZlLW9zLy4vbm9kZV9tb2R1bGVzL3RzZGF2L2Rpc3QvdHNkYXYuZXNtLmpzP2Q1MTgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGdldExvZ2dlciBmcm9tICdkZWJ1Zyc7XG5pbXBvcnQgY29udmVydCBmcm9tICd4bWwtanMnO1xuaW1wb3J0IGNyb3NzRmV0Y2ggZnJvbSAnY3Jvc3MtZmV0Y2gnO1xuaW1wb3J0IHsgZW5jb2RlIH0gZnJvbSAnYmFzZS02NCc7XG5cbnZhciBEQVZOYW1lc3BhY2U7XG4oZnVuY3Rpb24gKERBVk5hbWVzcGFjZSkge1xuICAgIERBVk5hbWVzcGFjZVtcIkNBTEVOREFSX1NFUlZFUlwiXSA9IFwiaHR0cDovL2NhbGVuZGFyc2VydmVyLm9yZy9ucy9cIjtcbiAgICBEQVZOYW1lc3BhY2VbXCJDQUxEQVZfQVBQTEVcIl0gPSBcImh0dHA6Ly9hcHBsZS5jb20vbnMvaWNhbC9cIjtcbiAgICBEQVZOYW1lc3BhY2VbXCJDQUxEQVZcIl0gPSBcInVybjppZXRmOnBhcmFtczp4bWw6bnM6Y2FsZGF2XCI7XG4gICAgREFWTmFtZXNwYWNlW1wiQ0FSRERBVlwiXSA9IFwidXJuOmlldGY6cGFyYW1zOnhtbDpuczpjYXJkZGF2XCI7XG4gICAgREFWTmFtZXNwYWNlW1wiREFWXCJdID0gXCJEQVY6XCI7XG59KShEQVZOYW1lc3BhY2UgfHwgKERBVk5hbWVzcGFjZSA9IHt9KSk7XG5jb25zdCBEQVZBdHRyaWJ1dGVNYXAgPSB7XG4gICAgW0RBVk5hbWVzcGFjZS5DQUxEQVZdOiAneG1sbnM6YycsXG4gICAgW0RBVk5hbWVzcGFjZS5DQVJEREFWXTogJ3htbG5zOmNhcmQnLFxuICAgIFtEQVZOYW1lc3BhY2UuQ0FMRU5EQVJfU0VSVkVSXTogJ3htbG5zOmNzJyxcbiAgICBbREFWTmFtZXNwYWNlLkNBTERBVl9BUFBMRV06ICd4bWxuczpjYScsXG4gICAgW0RBVk5hbWVzcGFjZS5EQVZdOiAneG1sbnM6ZCcsXG59O1xudmFyIERBVk5hbWVzcGFjZVNob3J0O1xuKGZ1bmN0aW9uIChEQVZOYW1lc3BhY2VTaG9ydCkge1xuICAgIERBVk5hbWVzcGFjZVNob3J0W1wiQ0FMREFWXCJdID0gXCJjXCI7XG4gICAgREFWTmFtZXNwYWNlU2hvcnRbXCJDQVJEREFWXCJdID0gXCJjYXJkXCI7XG4gICAgREFWTmFtZXNwYWNlU2hvcnRbXCJDQUxFTkRBUl9TRVJWRVJcIl0gPSBcImNzXCI7XG4gICAgREFWTmFtZXNwYWNlU2hvcnRbXCJDQUxEQVZfQVBQTEVcIl0gPSBcImNhXCI7XG4gICAgREFWTmFtZXNwYWNlU2hvcnRbXCJEQVZcIl0gPSBcImRcIjtcbn0pKERBVk5hbWVzcGFjZVNob3J0IHx8IChEQVZOYW1lc3BhY2VTaG9ydCA9IHt9KSk7XG52YXIgSUNBTE9iamVjdHM7XG4oZnVuY3Rpb24gKElDQUxPYmplY3RzKSB7XG4gICAgSUNBTE9iamVjdHNbXCJWRVZFTlRcIl0gPSBcIlZFVkVOVFwiO1xuICAgIElDQUxPYmplY3RzW1wiVlRPRE9cIl0gPSBcIlZUT0RPXCI7XG4gICAgSUNBTE9iamVjdHNbXCJWSk9VUk5BTFwiXSA9IFwiVkpPVVJOQUxcIjtcbiAgICBJQ0FMT2JqZWN0c1tcIlZGUkVFQlVTWVwiXSA9IFwiVkZSRUVCVVNZXCI7XG4gICAgSUNBTE9iamVjdHNbXCJWVElNRVpPTkVcIl0gPSBcIlZUSU1FWk9ORVwiO1xuICAgIElDQUxPYmplY3RzW1wiVkFMQVJNXCJdID0gXCJWQUxBUk1cIjtcbn0pKElDQUxPYmplY3RzIHx8IChJQ0FMT2JqZWN0cyA9IHt9KSk7XG5cbmNvbnN0IGNhbWVsQ2FzZSA9IChzdHIpID0+IHN0ci5yZXBsYWNlKC8oWy1fXVxcdykvZywgKGcpID0+IGdbMV0udG9VcHBlckNhc2UoKSk7XG5cbi8qKlxuICogQ2xvdWRmbGFyZSBXb3JrZXJzIGFuZCBzb21lIG1vZGVybiBlbnZpcm9ubWVudHMgaGF2ZSBhIG5hdGl2ZSBmZXRjaCBvbiBnbG9iYWxUaGlzLlxuICogV2UgcHJlZmVyIGl0IG92ZXIgY3Jvc3MtZmV0Y2ggdG8gYXZvaWQgY29tcGF0aWJpbGl0eSBpc3N1ZXMgd2l0aCB0aGUgcG9seWZpbGwuXG4gKi9cbmNvbnN0IGdldEZldGNoID0gKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGdsb2JhbFRoaXMuZmV0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXMuZmV0Y2guYmluZChnbG9iYWxUaGlzKTtcbiAgICB9XG4gICAgLy8gRmFsbGJhY2sgdG8gY3Jvc3MtZmV0Y2hcbiAgICByZXR1cm4gY3Jvc3NGZXRjaDtcbn07XG5jb25zdCBmZXRjaCA9IGdldEZldGNoKCk7XG5cbmNvbnN0IG5hdGl2ZVR5cGUgPSAodmFsdWUpID0+IHtcbiAgICBjb25zdCBuVmFsdWUgPSBOdW1iZXIodmFsdWUpO1xuICAgIGlmICghTnVtYmVyLmlzTmFOKG5WYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIG5WYWx1ZTtcbiAgICB9XG4gICAgY29uc3QgYlZhbHVlID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoYlZhbHVlID09PSAndHJ1ZScpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChiVmFsdWUgPT09ICdmYWxzZScpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59O1xuXG5jb25zdCB1cmxFcXVhbHMgPSAodXJsQSwgdXJsQikgPT4ge1xuICAgIGlmICghdXJsQSAmJiAhdXJsQikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCF1cmxBIHx8ICF1cmxCKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgdHJpbW1lZFVybEEgPSB1cmxBLnRyaW0oKTtcbiAgICBjb25zdCB0cmltbWVkVXJsQiA9IHVybEIudHJpbSgpO1xuICAgIGlmIChNYXRoLmFicyh0cmltbWVkVXJsQS5sZW5ndGggLSB0cmltbWVkVXJsQi5sZW5ndGgpID4gMSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHN0cmlwcGVkVXJsQSA9IHRyaW1tZWRVcmxBLnNsaWNlKC0xKSA9PT0gJy8nID8gdHJpbW1lZFVybEEuc2xpY2UoMCwgLTEpIDogdHJpbW1lZFVybEE7XG4gICAgY29uc3Qgc3RyaXBwZWRVcmxCID0gdHJpbW1lZFVybEIuc2xpY2UoLTEpID09PSAnLycgPyB0cmltbWVkVXJsQi5zbGljZSgwLCAtMSkgOiB0cmltbWVkVXJsQjtcbiAgICByZXR1cm4gdXJsQS5pbmNsdWRlcyhzdHJpcHBlZFVybEIpIHx8IHVybEIuaW5jbHVkZXMoc3RyaXBwZWRVcmxBKTtcbn07XG5jb25zdCB1cmxDb250YWlucyA9ICh1cmxBLCB1cmxCKSA9PiB7XG4gICAgaWYgKCF1cmxBICYmICF1cmxCKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoIXVybEEgfHwgIXVybEIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB0cmltbWVkVXJsQSA9IHVybEEudHJpbSgpO1xuICAgIGNvbnN0IHRyaW1tZWRVcmxCID0gdXJsQi50cmltKCk7XG4gICAgY29uc3Qgc3RyaXBwZWRVcmxBID0gdHJpbW1lZFVybEEuc2xpY2UoLTEpID09PSAnLycgPyB0cmltbWVkVXJsQS5zbGljZSgwLCAtMSkgOiB0cmltbWVkVXJsQTtcbiAgICBjb25zdCBzdHJpcHBlZFVybEIgPSB0cmltbWVkVXJsQi5zbGljZSgtMSkgPT09ICcvJyA/IHRyaW1tZWRVcmxCLnNsaWNlKDAsIC0xKSA6IHRyaW1tZWRVcmxCO1xuICAgIHJldHVybiB1cmxBLmluY2x1ZGVzKHN0cmlwcGVkVXJsQikgfHwgdXJsQi5pbmNsdWRlcyhzdHJpcHBlZFVybEEpO1xufTtcbmNvbnN0IGdldERBVkF0dHJpYnV0ZSA9IChuc0FycikgPT4gbnNBcnIucmVkdWNlKChwcmV2LCBjdXJyKSA9PiAoeyAuLi5wcmV2LCBbREFWQXR0cmlidXRlTWFwW2N1cnJdXTogY3VyciB9KSwge30pO1xuY29uc3QgY2xlYW51cEZhbHN5ID0gKG9iaikgPT4gT2JqZWN0LmVudHJpZXMob2JqKS5yZWR1Y2UoKHByZXYsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGlmICh2YWx1ZSlcbiAgICAgICAgcmV0dXJuIHsgLi4ucHJldiwgW2tleV06IHZhbHVlIH07XG4gICAgcmV0dXJuIHByZXY7XG59LCB7fSk7XG5jb25zdCBjb25kaXRpb25hbFBhcmFtID0gKGtleSwgcGFyYW0pID0+IHtcbiAgICBpZiAocGFyYW0pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFtrZXldOiBwYXJhbSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHt9O1xufTtcbmNvbnN0IGV4Y2x1ZGVIZWFkZXJzID0gKGhlYWRlcnMsIGhlYWRlcnNUb0V4Y2x1ZGUpID0+IHtcbiAgICBpZiAoIWhlYWRlcnMpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBpZiAoIWhlYWRlcnNUb0V4Y2x1ZGUgfHwgaGVhZGVyc1RvRXhjbHVkZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMoaGVhZGVycykuZmlsdGVyKChba2V5XSkgPT4gIWhlYWRlcnNUb0V4Y2x1ZGUuaW5jbHVkZXMoa2V5KSkpO1xufTtcblxudmFyIHJlcXVlc3RIZWxwZXJzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBjbGVhbnVwRmFsc3k6IGNsZWFudXBGYWxzeSxcbiAgICBjb25kaXRpb25hbFBhcmFtOiBjb25kaXRpb25hbFBhcmFtLFxuICAgIGV4Y2x1ZGVIZWFkZXJzOiBleGNsdWRlSGVhZGVycyxcbiAgICBnZXREQVZBdHRyaWJ1dGU6IGdldERBVkF0dHJpYnV0ZSxcbiAgICB1cmxDb250YWluczogdXJsQ29udGFpbnMsXG4gICAgdXJsRXF1YWxzOiB1cmxFcXVhbHNcbn0pO1xuXG5jb25zdCBkZWJ1ZyQ1ID0gZ2V0TG9nZ2VyKCd0c2RhdjpyZXF1ZXN0Jyk7XG5jb25zdCBkYXZSZXF1ZXN0ID0gYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB7IHVybCwgaW5pdCwgY29udmVydEluY29taW5nID0gdHJ1ZSwgcGFyc2VPdXRnb2luZyA9IHRydWUsIGZldGNoT3B0aW9ucyA9IHt9LCBmZXRjaDogZmV0Y2hPdmVycmlkZSwgfSA9IHBhcmFtcztcbiAgICBjb25zdCByZXF1ZXN0RmV0Y2ggPSBmZXRjaE92ZXJyaWRlICE9PSBudWxsICYmIGZldGNoT3ZlcnJpZGUgIT09IHZvaWQgMCA/IGZldGNoT3ZlcnJpZGUgOiBmZXRjaDtcbiAgICBjb25zdCB7IGhlYWRlcnMgPSB7fSwgYm9keSwgbmFtZXNwYWNlLCBtZXRob2QsIGF0dHJpYnV0ZXMgfSA9IGluaXQ7XG4gICAgY29uc3QgeG1sQm9keSA9IGNvbnZlcnRJbmNvbWluZ1xuICAgICAgICA/IGNvbnZlcnQuanMyeG1sKHtcbiAgICAgICAgICAgIF9kZWNsYXJhdGlvbjogeyBfYXR0cmlidXRlczogeyB2ZXJzaW9uOiAnMS4wJywgZW5jb2Rpbmc6ICd1dGYtOCcgfSB9LFxuICAgICAgICAgICAgLi4uYm9keSxcbiAgICAgICAgICAgIF9hdHRyaWJ1dGVzOiBhdHRyaWJ1dGVzLFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBjb21wYWN0OiB0cnVlLFxuICAgICAgICAgICAgc3BhY2VzOiAyLFxuICAgICAgICAgICAgZWxlbWVudE5hbWVGbjogKG5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBhZGQgbmFtZXNwYWNlIHRvIGFsbCBrZXlzIHdpdGhvdXQgbmFtZXNwYWNlXG4gICAgICAgICAgICAgICAgaWYgKG5hbWVzcGFjZSAmJiAhL14uKzouKy8udGVzdChuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYCR7bmFtZXNwYWNlfToke25hbWV9YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KVxuICAgICAgICA6IGJvZHk7XG4gICAgLy8gZGVidWcoJ291dGdvaW5nIHhtbDonKTtcbiAgICAvLyBkZWJ1ZyhgJHttZXRob2R9ICR7dXJsfWApO1xuICAgIC8vIGRlYnVnKFxuICAgIC8vICAgYGhlYWRlcnM6ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgLy8gICAgIHtcbiAgICAvLyAgICAgICAnQ29udGVudC1UeXBlJzogJ3RleHQveG1sO2NoYXJzZXQ9VVRGLTgnLFxuICAgIC8vICAgICAgIC4uLmNsZWFudXBGYWxzeShoZWFkZXJzKSxcbiAgICAvLyAgICAgfSxcbiAgICAvLyAgICAgbnVsbCxcbiAgICAvLyAgICAgMlxuICAgIC8vICAgKX1gXG4gICAgLy8gKTtcbiAgICAvLyBkZWJ1Zyh4bWxCb2R5KTtcbiAgICBjb25zdCBmZXRjaE9wdGlvbnNXaXRob3V0SGVhZGVycyA9IHtcbiAgICAgICAgLi4uZmV0Y2hPcHRpb25zLFxuICAgIH07XG4gICAgZGVsZXRlIGZldGNoT3B0aW9uc1dpdGhvdXRIZWFkZXJzLmhlYWRlcnM7XG4gICAgY29uc3QgZGF2UmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0RmV0Y2godXJsLCB7XG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAndGV4dC94bWw7Y2hhcnNldD1VVEYtOCcsXG4gICAgICAgICAgICAuLi5jbGVhbnVwRmFsc3koaGVhZGVycyksXG4gICAgICAgICAgICAuLi4oZmV0Y2hPcHRpb25zLmhlYWRlcnMgfHwge30pLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiB4bWxCb2R5LFxuICAgICAgICBtZXRob2QsXG4gICAgICAgIC4uLmZldGNoT3B0aW9uc1dpdGhvdXRIZWFkZXJzLFxuICAgIH0pO1xuICAgIGNvbnN0IHJlc1RleHQgPSBhd2FpdCBkYXZSZXNwb25zZS50ZXh0KCk7XG4gICAgLy8gZmlsdGVyIG91dCBpbnZhbGlkIHJlc3BvbnNlc1xuICAgIC8vIGRlYnVnKCdyZXNwb25zZSB4bWw6Jyk7XG4gICAgLy8gZGVidWcocmVzVGV4dCk7XG4gICAgLy8gZGVidWcoZGF2UmVzcG9uc2UpO1xuICAgIGlmICghZGF2UmVzcG9uc2Uub2sgfHxcbiAgICAgICAgISgoX2EgPSBkYXZSZXNwb25zZS5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pbmNsdWRlcygneG1sJykpIHx8XG4gICAgICAgICFwYXJzZU91dGdvaW5nIHx8XG4gICAgICAgICFyZXNUZXh0KSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaHJlZjogZGF2UmVzcG9uc2UudXJsLFxuICAgICAgICAgICAgICAgIG9rOiBkYXZSZXNwb25zZS5vayxcbiAgICAgICAgICAgICAgICBzdGF0dXM6IGRhdlJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICAgICAgICBzdGF0dXNUZXh0OiBkYXZSZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgICAgIHJhdzogcmVzVGV4dCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF07XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGNvbnZlcnQueG1sMmpzKHJlc1RleHQsIHtcbiAgICAgICAgY29tcGFjdDogdHJ1ZSxcbiAgICAgICAgdHJpbTogdHJ1ZSxcbiAgICAgICAgdGV4dEZuOiAodmFsdWUsIHBhcmVudEVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBuZWVkZWQgZm9yIHhtbC1qcyBkZXNpZ24gcmVhc29uc1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlcnNjb3JlLWRhbmdsZVxuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudE9mUGFyZW50ID0gcGFyZW50RWxlbWVudC5fcGFyZW50O1xuICAgICAgICAgICAgICAgIGNvbnN0IHBPcEtleXMgPSBPYmplY3Qua2V5cyhwYXJlbnRPZlBhcmVudCk7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5Tm8gPSBwT3BLZXlzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlOYW1lID0gcE9wS2V5c1trZXlObyAtIDFdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyck9mS2V5ID0gcGFyZW50T2ZQYXJlbnRba2V5TmFtZV07XG4gICAgICAgICAgICAgICAgY29uc3QgYXJyT2ZLZXlMZW4gPSBhcnJPZktleS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGFyck9mS2V5TGVuID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhcnIgPSBhcnJPZktleTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJySW5kZXggPSBhcnJPZktleS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICBhcnJbYXJySW5kZXhdID0gbmF0aXZlVHlwZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRPZlBhcmVudFtrZXlOYW1lXSA9IG5hdGl2ZVR5cGUodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgZGVidWckNShlLnN0YWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gcmVtb3ZlIG5hbWVzcGFjZSAmIGNhbWVsQ2FzZVxuICAgICAgICBlbGVtZW50TmFtZUZuOiAoYXR0cmlidXRlTmFtZSkgPT4gY2FtZWxDYXNlKGF0dHJpYnV0ZU5hbWUucmVwbGFjZSgvXi4rOi8sICcnKSksXG4gICAgICAgIGF0dHJpYnV0ZXNGbjogKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuZXdWYWwgPSB7IC4uLnZhbHVlIH07XG4gICAgICAgICAgICBkZWxldGUgbmV3VmFsLnhtbG5zO1xuICAgICAgICAgICAgcmV0dXJuIG5ld1ZhbDtcbiAgICAgICAgfSxcbiAgICAgICAgaWdub3JlRGVjbGFyYXRpb246IHRydWUsXG4gICAgfSk7XG4gICAgY29uc3QgcmVzcG9uc2VCb2RpZXMgPSBBcnJheS5pc0FycmF5KHJlc3VsdC5tdWx0aXN0YXR1cy5yZXNwb25zZSlcbiAgICAgICAgPyByZXN1bHQubXVsdGlzdGF0dXMucmVzcG9uc2VcbiAgICAgICAgOiBbcmVzdWx0Lm11bHRpc3RhdHVzLnJlc3BvbnNlXTtcbiAgICByZXR1cm4gcmVzcG9uc2VCb2RpZXMubWFwKChyZXNwb25zZUJvZHkpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3Qgc3RhdHVzUmVnZXggPSAvXlxcUytcXHMoPzxzdGF0dXM+XFxkKylcXHMoPzxzdGF0dXNUZXh0Pi4rKSQvO1xuICAgICAgICBpZiAoIXJlc3BvbnNlQm9keSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdGF0dXM6IGRhdlJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICAgICAgICBzdGF0dXNUZXh0OiBkYXZSZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgICAgIG9rOiBkYXZSZXNwb25zZS5vayxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWF0Y2hBcnIgPSBzdGF0dXNSZWdleC5leGVjKHJlc3BvbnNlQm9keS5zdGF0dXMpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmF3OiByZXN1bHQsXG4gICAgICAgICAgICBocmVmOiByZXNwb25zZUJvZHkuaHJlZixcbiAgICAgICAgICAgIHN0YXR1czogKG1hdGNoQXJyID09PSBudWxsIHx8IG1hdGNoQXJyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXRjaEFyci5ncm91cHMpID8gTnVtYmVyLnBhcnNlSW50KG1hdGNoQXJyID09PSBudWxsIHx8IG1hdGNoQXJyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXRjaEFyci5ncm91cHMuc3RhdHVzLCAxMCkgOiBkYXZSZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgICBzdGF0dXNUZXh0OiAoX2IgPSAoX2EgPSBtYXRjaEFyciA9PT0gbnVsbCB8fCBtYXRjaEFyciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWF0Y2hBcnIuZ3JvdXBzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RhdHVzVGV4dCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZGF2UmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgIG9rOiAhcmVzcG9uc2VCb2R5LmVycm9yLFxuICAgICAgICAgICAgZXJyb3I6IHJlc3BvbnNlQm9keS5lcnJvcixcbiAgICAgICAgICAgIHJlc3BvbnNlZGVzY3JpcHRpb246IHJlc3BvbnNlQm9keS5yZXNwb25zZWRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgcHJvcHM6IChBcnJheS5pc0FycmF5KHJlc3BvbnNlQm9keS5wcm9wc3RhdClcbiAgICAgICAgICAgICAgICA/IHJlc3BvbnNlQm9keS5wcm9wc3RhdFxuICAgICAgICAgICAgICAgIDogW3Jlc3BvbnNlQm9keS5wcm9wc3RhdF0pLnJlZHVjZSgocHJldiwgY3VycikgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnByZXYsXG4gICAgICAgICAgICAgICAgICAgIC4uLmN1cnIgPT09IG51bGwgfHwgY3VyciA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3Vyci5wcm9wLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LCB7fSksXG4gICAgICAgIH07XG4gICAgfSk7XG59O1xuY29uc3QgcHJvcGZpbmQgPSBhc3luYyAocGFyYW1zKSA9PiB7XG4gICAgY29uc3QgeyB1cmwsIHByb3BzLCBkZXB0aCwgaGVhZGVycywgaGVhZGVyc1RvRXhjbHVkZSwgZmV0Y2hPcHRpb25zID0ge30sIGZldGNoOiBmZXRjaE92ZXJyaWRlLCB9ID0gcGFyYW1zO1xuICAgIHJldHVybiBkYXZSZXF1ZXN0KHtcbiAgICAgICAgdXJsLFxuICAgICAgICBpbml0OiB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQUk9QRklORCcsXG4gICAgICAgICAgICBoZWFkZXJzOiBleGNsdWRlSGVhZGVycyhjbGVhbnVwRmFsc3koeyBkZXB0aCwgLi4uaGVhZGVycyB9KSwgaGVhZGVyc1RvRXhjbHVkZSksXG4gICAgICAgICAgICBuYW1lc3BhY2U6IERBVk5hbWVzcGFjZVNob3J0LkRBVixcbiAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICBwcm9wZmluZDoge1xuICAgICAgICAgICAgICAgICAgICBfYXR0cmlidXRlczogZ2V0REFWQXR0cmlidXRlKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIERBVk5hbWVzcGFjZS5DQUxEQVYsXG4gICAgICAgICAgICAgICAgICAgICAgICBEQVZOYW1lc3BhY2UuQ0FMREFWX0FQUExFLFxuICAgICAgICAgICAgICAgICAgICAgICAgREFWTmFtZXNwYWNlLkNBTEVOREFSX1NFUlZFUixcbiAgICAgICAgICAgICAgICAgICAgICAgIERBVk5hbWVzcGFjZS5DQVJEREFWLFxuICAgICAgICAgICAgICAgICAgICAgICAgREFWTmFtZXNwYWNlLkRBVixcbiAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgIHByb3A6IHByb3BzLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBmZXRjaE9wdGlvbnMsXG4gICAgICAgIGZldGNoOiBmZXRjaE92ZXJyaWRlLFxuICAgIH0pO1xufTtcbmNvbnN0IGNyZWF0ZU9iamVjdCA9IGFzeW5jIChwYXJhbXMpID0+IHtcbiAgICBjb25zdCB7IHVybCwgZGF0YSwgaGVhZGVycywgaGVhZGVyc1RvRXhjbHVkZSwgZmV0Y2hPcHRpb25zID0ge30sIGZldGNoOiBmZXRjaE92ZXJyaWRlIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgcmVxdWVzdEZldGNoID0gZmV0Y2hPdmVycmlkZSAhPT0gbnVsbCAmJiBmZXRjaE92ZXJyaWRlICE9PSB2b2lkIDAgPyBmZXRjaE92ZXJyaWRlIDogZmV0Y2g7XG4gICAgcmV0dXJuIHJlcXVlc3RGZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgICAgYm9keTogZGF0YSxcbiAgICAgICAgaGVhZGVyczogZXhjbHVkZUhlYWRlcnMoaGVhZGVycywgaGVhZGVyc1RvRXhjbHVkZSksXG4gICAgICAgIC4uLmZldGNoT3B0aW9ucyxcbiAgICB9KTtcbn07XG5jb25zdCB1cGRhdGVPYmplY3QgPSBhc3luYyAocGFyYW1zKSA9PiB7XG4gICAgY29uc3QgeyB1cmwsIGRhdGEsIGV0YWcsIGhlYWRlcnMsIGhlYWRlcnNUb0V4Y2x1ZGUsIGZldGNoT3B0aW9ucyA9IHt9LCBmZXRjaDogZmV0Y2hPdmVycmlkZSwgfSA9IHBhcmFtcztcbiAgICBjb25zdCByZXF1ZXN0RmV0Y2ggPSBmZXRjaE92ZXJyaWRlICE9PSBudWxsICYmIGZldGNoT3ZlcnJpZGUgIT09IHZvaWQgMCA/IGZldGNoT3ZlcnJpZGUgOiBmZXRjaDtcbiAgICByZXR1cm4gcmVxdWVzdEZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICBib2R5OiBkYXRhLFxuICAgICAgICBoZWFkZXJzOiBleGNsdWRlSGVhZGVycyhjbGVhbnVwRmFsc3koeyAnSWYtTWF0Y2gnOiBldGFnLCAuLi5oZWFkZXJzIH0pLCBoZWFkZXJzVG9FeGNsdWRlKSxcbiAgICAgICAgLi4uZmV0Y2hPcHRpb25zLFxuICAgIH0pO1xufTtcbmNvbnN0IGRlbGV0ZU9iamVjdCA9IGFzeW5jIChwYXJhbXMpID0+IHtcbiAgICBjb25zdCB7IHVybCwgaGVhZGVycywgZXRhZywgaGVhZGVyc1RvRXhjbHVkZSwgZmV0Y2hPcHRpb25zID0ge30sIGZldGNoOiBmZXRjaE92ZXJyaWRlIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgcmVxdWVzdEZldGNoID0gZmV0Y2hPdmVycmlkZSAhPT0gbnVsbCAmJiBmZXRjaE92ZXJyaWRlICE9PSB2b2lkIDAgPyBmZXRjaE92ZXJyaWRlIDogZmV0Y2g7XG4gICAgcmV0dXJuIHJlcXVlc3RGZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgaGVhZGVyczogZXhjbHVkZUhlYWRlcnMoY2xlYW51cEZhbHN5KHsgJ0lmLU1hdGNoJzogZXRhZywgLi4uaGVhZGVycyB9KSwgaGVhZGVyc1RvRXhjbHVkZSksXG4gICAgICAgIC4uLmZldGNoT3B0aW9ucyxcbiAgICB9KTtcbn07XG5cbnZhciByZXF1ZXN0ID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBjcmVhdGVPYmplY3Q6IGNyZWF0ZU9iamVjdCxcbiAgICBkYXZSZXF1ZXN0OiBkYXZSZXF1ZXN0LFxuICAgIGRlbGV0ZU9iamVjdDogZGVsZXRlT2JqZWN0LFxuICAgIHByb3BmaW5kOiBwcm9wZmluZCxcbiAgICB1cGRhdGVPYmplY3Q6IHVwZGF0ZU9iamVjdFxufSk7XG5cbmZ1bmN0aW9uIGhhc0ZpZWxkcyhvYmosIGZpZWxkcykge1xuICAgIGNvbnN0IGluT2JqID0gKG9iamVjdCkgPT4gZmllbGRzLmV2ZXJ5KChmKSA9PiBvYmplY3RbZl0pO1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgcmV0dXJuIG9iai5ldmVyeSgobykgPT4gaW5PYmoobykpO1xuICAgIH1cbiAgICByZXR1cm4gaW5PYmoob2JqKTtcbn1cbmNvbnN0IGZpbmRNaXNzaW5nRmllbGROYW1lcyA9IChvYmosIGZpZWxkcykgPT4gZmllbGRzLnJlZHVjZSgocHJldiwgY3VycikgPT4gKG9ialtjdXJyXSA/IHByZXYgOiBgJHtwcmV2Lmxlbmd0aCA/IGAke3ByZXZ9LGAgOiAnJ30ke2N1cnIudG9TdHJpbmcoKX1gKSwgJycpO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlcnNjb3JlLWRhbmdsZSAqL1xuY29uc3QgZGVidWckNCA9IGdldExvZ2dlcigndHNkYXY6Y29sbGVjdGlvbicpO1xuY29uc3QgY29sbGVjdGlvblF1ZXJ5ID0gYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IHsgdXJsLCBib2R5LCBkZXB0aCwgZGVmYXVsdE5hbWVzcGFjZSA9IERBVk5hbWVzcGFjZVNob3J0LkRBViwgaGVhZGVycywgaGVhZGVyc1RvRXhjbHVkZSwgZmV0Y2hPcHRpb25zID0ge30sIGZldGNoOiBmZXRjaE92ZXJyaWRlLCB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHF1ZXJ5UmVzdWx0cyA9IGF3YWl0IGRhdlJlcXVlc3Qoe1xuICAgICAgICB1cmwsXG4gICAgICAgIGluaXQ6IHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1JFUE9SVCcsXG4gICAgICAgICAgICBoZWFkZXJzOiBleGNsdWRlSGVhZGVycyhjbGVhbnVwRmFsc3koeyBkZXB0aCwgLi4uaGVhZGVycyB9KSwgaGVhZGVyc1RvRXhjbHVkZSksXG4gICAgICAgICAgICBuYW1lc3BhY2U6IGRlZmF1bHROYW1lc3BhY2UsXG4gICAgICAgICAgICBib2R5LFxuICAgICAgICB9LFxuICAgICAgICBmZXRjaE9wdGlvbnMsXG4gICAgICAgIGZldGNoOiBmZXRjaE92ZXJyaWRlLFxuICAgIH0pO1xuICAgIGNvbnN0IGVycm9yUmVzcG9uc2UgPSBxdWVyeVJlc3VsdHMuZmluZCgocmVzKSA9PiAhcmVzLm9rIHx8IChyZXMuc3RhdHVzICYmIHJlcy5zdGF0dXMgPj0gNDAwKSk7XG4gICAgaWYgKGVycm9yUmVzcG9uc2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb2xsZWN0aW9uIHF1ZXJ5IGZhaWxlZDogJHtlcnJvclJlc3BvbnNlLnN0YXR1c30gJHtlcnJvclJlc3BvbnNlLnN0YXR1c1RleHR9LiAke2Vycm9yUmVzcG9uc2UucmF3ID8gYFJhdyByZXNwb25zZTogJHtlcnJvclJlc3BvbnNlLnJhd31gIDogJyd9YCk7XG4gICAgfVxuICAgIC8vIGVtcHR5IHF1ZXJ5IHJlc3VsdFxuICAgIGlmIChxdWVyeVJlc3VsdHMubGVuZ3RoID09PSAxICYmXG4gICAgICAgICFxdWVyeVJlc3VsdHNbMF0ucmF3ICYmXG4gICAgICAgIHF1ZXJ5UmVzdWx0c1swXS5zdGF0dXMgJiZcbiAgICAgICAgcXVlcnlSZXN1bHRzWzBdLnN0YXR1cyA8IDMwMCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJldHVybiBxdWVyeVJlc3VsdHM7XG59O1xuY29uc3QgbWFrZUNvbGxlY3Rpb24gPSBhc3luYyAocGFyYW1zKSA9PiB7XG4gICAgY29uc3QgeyB1cmwsIHByb3BzLCBkZXB0aCwgaGVhZGVycywgaGVhZGVyc1RvRXhjbHVkZSwgZmV0Y2hPcHRpb25zID0ge30sIGZldGNoOiBmZXRjaE92ZXJyaWRlLCB9ID0gcGFyYW1zO1xuICAgIHJldHVybiBkYXZSZXF1ZXN0KHtcbiAgICAgICAgdXJsLFxuICAgICAgICBpbml0OiB7XG4gICAgICAgICAgICBtZXRob2Q6ICdNS0NPTCcsXG4gICAgICAgICAgICBoZWFkZXJzOiBleGNsdWRlSGVhZGVycyhjbGVhbnVwRmFsc3koeyBkZXB0aCwgLi4uaGVhZGVycyB9KSwgaGVhZGVyc1RvRXhjbHVkZSksXG4gICAgICAgICAgICBuYW1lc3BhY2U6IERBVk5hbWVzcGFjZVNob3J0LkRBVixcbiAgICAgICAgICAgIGJvZHk6IHByb3BzXG4gICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgIG1rY29sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wOiBwcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICB9LFxuICAgICAgICBmZXRjaE9wdGlvbnMsXG4gICAgICAgIGZldGNoOiBmZXRjaE92ZXJyaWRlLFxuICAgIH0pO1xufTtcbmNvbnN0IHN1cHBvcnRlZFJlcG9ydFNldCA9IGFzeW5jIChwYXJhbXMpID0+IHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgIGNvbnN0IHsgY29sbGVjdGlvbiwgaGVhZGVycywgaGVhZGVyc1RvRXhjbHVkZSwgZmV0Y2hPcHRpb25zID0ge30sIGZldGNoOiBmZXRjaE92ZXJyaWRlIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgcHJvcGZpbmQoe1xuICAgICAgICB1cmw6IGNvbGxlY3Rpb24udXJsLFxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgW2Ake0RBVk5hbWVzcGFjZVNob3J0LkRBVn06c3VwcG9ydGVkLXJlcG9ydC1zZXRgXToge30sXG4gICAgICAgIH0sXG4gICAgICAgIGRlcHRoOiAnMCcsXG4gICAgICAgIGhlYWRlcnM6IGV4Y2x1ZGVIZWFkZXJzKGhlYWRlcnMsIGhlYWRlcnNUb0V4Y2x1ZGUpLFxuICAgICAgICBmZXRjaE9wdGlvbnMsXG4gICAgICAgIGZldGNoOiBmZXRjaE92ZXJyaWRlLFxuICAgIH0pO1xuICAgIHJldHVybiAoKF9lID0gKF9kID0gKF9jID0gKF9iID0gKF9hID0gcmVzWzBdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucHJvcHMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zdXBwb3J0ZWRSZXBvcnRTZXQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5zdXBwb3J0ZWRSZXBvcnQpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5tYXAoKHNyKSA9PiBPYmplY3Qua2V5cyhzci5yZXBvcnQpWzBdKSkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogW10pO1xufTtcbmNvbnN0IGlzQ29sbGVjdGlvbkRpcnR5ID0gYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIGNvbnN0IHsgY29sbGVjdGlvbiwgaGVhZGVycywgaGVhZGVyc1RvRXhjbHVkZSwgZmV0Y2hPcHRpb25zID0ge30sIGZldGNoOiBmZXRjaE92ZXJyaWRlIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgcmVzcG9uc2VzID0gYXdhaXQgcHJvcGZpbmQoe1xuICAgICAgICB1cmw6IGNvbGxlY3Rpb24udXJsLFxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgW2Ake0RBVk5hbWVzcGFjZVNob3J0LkNBTEVOREFSX1NFUlZFUn06Z2V0Y3RhZ2BdOiB7fSxcbiAgICAgICAgfSxcbiAgICAgICAgZGVwdGg6ICcwJyxcbiAgICAgICAgaGVhZGVyczogZXhjbHVkZUhlYWRlcnMoaGVhZGVycywgaGVhZGVyc1RvRXhjbHVkZSksXG4gICAgICAgIGZldGNoT3B0aW9ucyxcbiAgICAgICAgZmV0Y2g6IGZldGNoT3ZlcnJpZGUsXG4gICAgfSk7XG4gICAgY29uc3QgcmVzID0gcmVzcG9uc2VzLmZpbHRlcigocikgPT4gdXJsQ29udGFpbnMoY29sbGVjdGlvbi51cmwsIHIuaHJlZikpWzBdO1xuICAgIGlmICghcmVzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ29sbGVjdGlvbiBkb2VzIG5vdCBleGlzdCBvbiBzZXJ2ZXInKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaXNEaXJ0eTogYCR7Y29sbGVjdGlvbi5jdGFnfWAgIT09IGAkeyhfYSA9IHJlcy5wcm9wcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldGN0YWd9YCxcbiAgICAgICAgbmV3Q3RhZzogKF9jID0gKF9iID0gcmVzLnByb3BzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZ2V0Y3RhZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnRvU3RyaW5nKCksXG4gICAgfTtcbn07XG4vKipcbiAqIFRoaXMgaXMgZm9yIHdlYmRhdiBzeW5jLWNvbGxlY3Rpb24gb25seVxuICovXG5jb25zdCBzeW5jQ29sbGVjdGlvbiA9IChwYXJhbXMpID0+IHtcbiAgICBjb25zdCB7IHVybCwgcHJvcHMsIGhlYWRlcnMsIHN5bmNMZXZlbCwgc3luY1Rva2VuLCBoZWFkZXJzVG9FeGNsdWRlLCBmZXRjaE9wdGlvbnMsIGZldGNoOiBmZXRjaE92ZXJyaWRlLCB9ID0gcGFyYW1zO1xuICAgIHJldHVybiBkYXZSZXF1ZXN0KHtcbiAgICAgICAgdXJsLFxuICAgICAgICBpbml0OiB7XG4gICAgICAgICAgICBtZXRob2Q6ICdSRVBPUlQnLFxuICAgICAgICAgICAgbmFtZXNwYWNlOiBEQVZOYW1lc3BhY2VTaG9ydC5EQVYsXG4gICAgICAgICAgICBoZWFkZXJzOiBleGNsdWRlSGVhZGVycyh7IC4uLmhlYWRlcnMgfSwgaGVhZGVyc1RvRXhjbHVkZSksXG4gICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgICAgJ3N5bmMtY29sbGVjdGlvbic6IHtcbiAgICAgICAgICAgICAgICAgICAgX2F0dHJpYnV0ZXM6IGdldERBVkF0dHJpYnV0ZShbXG4gICAgICAgICAgICAgICAgICAgICAgICBEQVZOYW1lc3BhY2UuQ0FMREFWLFxuICAgICAgICAgICAgICAgICAgICAgICAgREFWTmFtZXNwYWNlLkNBUkREQVYsXG4gICAgICAgICAgICAgICAgICAgICAgICBEQVZOYW1lc3BhY2UuREFWLFxuICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgJ3N5bmMtbGV2ZWwnOiBzeW5jTGV2ZWwsXG4gICAgICAgICAgICAgICAgICAgICdzeW5jLXRva2VuJzogc3luY1Rva2VuLFxuICAgICAgICAgICAgICAgICAgICBbYCR7REFWTmFtZXNwYWNlU2hvcnQuREFWfTpwcm9wYF06IHByb3BzLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBmZXRjaE9wdGlvbnMsXG4gICAgICAgIGZldGNoOiBmZXRjaE92ZXJyaWRlLFxuICAgIH0pO1xufTtcbi8qKiByZW1vdGUgY29sbGVjdGlvbiB0byBsb2NhbCAqL1xuY29uc3Qgc21hcnRDb2xsZWN0aW9uU3luYyA9IGFzeW5jIChwYXJhbXMpID0+IHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaiwgX2ssIF9sLCBfbTtcbiAgICBjb25zdCB7IGNvbGxlY3Rpb24sIG1ldGhvZCwgaGVhZGVycywgaGVhZGVyc1RvRXhjbHVkZSwgYWNjb3VudCwgZGV0YWlsZWRSZXN1bHQsIGZldGNoT3B0aW9ucyA9IHt9LCBmZXRjaDogZmV0Y2hPdmVycmlkZSwgfSA9IHBhcmFtcztcbiAgICBjb25zdCByZXF1aXJlZEZpZWxkcyA9IFsnYWNjb3VudFR5cGUnLCAnaG9tZVVybCddO1xuICAgIGlmICghYWNjb3VudCB8fCAhaGFzRmllbGRzKGFjY291bnQsIHJlcXVpcmVkRmllbGRzKSkge1xuICAgICAgICBpZiAoIWFjY291bnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbm8gYWNjb3VudCBmb3Igc21hcnRDb2xsZWN0aW9uU3luYycpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgYWNjb3VudCBtdXN0IGhhdmUgJHtmaW5kTWlzc2luZ0ZpZWxkTmFtZXMoYWNjb3VudCwgcmVxdWlyZWRGaWVsZHMpfSBiZWZvcmUgc21hcnRDb2xsZWN0aW9uU3luY2ApO1xuICAgIH1cbiAgICBjb25zdCBzeW5jTWV0aG9kID0gbWV0aG9kICE9PSBudWxsICYmIG1ldGhvZCAhPT0gdm9pZCAwID8gbWV0aG9kIDogKCgoX2EgPSBjb2xsZWN0aW9uLnJlcG9ydHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pbmNsdWRlcygnc3luY0NvbGxlY3Rpb24nKSkgPyAnd2ViZGF2JyA6ICdiYXNpYycpO1xuICAgIGRlYnVnJDQoYHNtYXJ0IGNvbGxlY3Rpb24gc3luYyB3aXRoIHR5cGUgJHthY2NvdW50LmFjY291bnRUeXBlfSBhbmQgbWV0aG9kICR7c3luY01ldGhvZH1gKTtcbiAgICBpZiAoc3luY01ldGhvZCA9PT0gJ3dlYmRhdicpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3luY0NvbGxlY3Rpb24oe1xuICAgICAgICAgICAgdXJsOiBjb2xsZWN0aW9uLnVybCxcbiAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgW2Ake0RBVk5hbWVzcGFjZVNob3J0LkRBVn06Z2V0ZXRhZ2BdOiB7fSxcbiAgICAgICAgICAgICAgICBbYCR7YWNjb3VudC5hY2NvdW50VHlwZSA9PT0gJ2NhbGRhdicgPyBEQVZOYW1lc3BhY2VTaG9ydC5DQUxEQVYgOiBEQVZOYW1lc3BhY2VTaG9ydC5DQVJEREFWfToke2FjY291bnQuYWNjb3VudFR5cGUgPT09ICdjYWxkYXYnID8gJ2NhbGVuZGFyLWRhdGEnIDogJ2FkZHJlc3MtZGF0YSd9YF06IHt9LFxuICAgICAgICAgICAgICAgIFtgJHtEQVZOYW1lc3BhY2VTaG9ydC5EQVZ9OmRpc3BsYXluYW1lYF06IHt9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN5bmNMZXZlbDogMSxcbiAgICAgICAgICAgIHN5bmNUb2tlbjogY29sbGVjdGlvbi5zeW5jVG9rZW4sXG4gICAgICAgICAgICBoZWFkZXJzOiBleGNsdWRlSGVhZGVycyhoZWFkZXJzLCBoZWFkZXJzVG9FeGNsdWRlKSxcbiAgICAgICAgICAgIGZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgIGZldGNoOiBmZXRjaE92ZXJyaWRlLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgb2JqZWN0UmVzcG9uc2VzID0gcmVzdWx0LmZpbHRlcigocikgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgY29uc3QgZXh0TmFtZSA9IGFjY291bnQuYWNjb3VudFR5cGUgPT09ICdjYWxkYXYnID8gJy5pY3MnIDogJy52Y2YnO1xuICAgICAgICAgICAgcmV0dXJuICgoX2EgPSByLmhyZWYpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zbGljZSgtNCkpID09PSBleHROYW1lO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY2hhbmdlZE9iamVjdFVybHMgPSBvYmplY3RSZXNwb25zZXMuZmlsdGVyKChvKSA9PiBvLnN0YXR1cyAhPT0gNDA0KS5tYXAoKHIpID0+IHIuaHJlZik7XG4gICAgICAgIGNvbnN0IGRlbGV0ZWRPYmplY3RVcmxzID0gb2JqZWN0UmVzcG9uc2VzLmZpbHRlcigobykgPT4gby5zdGF0dXMgPT09IDQwNCkubWFwKChyKSA9PiByLmhyZWYpO1xuICAgICAgICBjb25zdCBtdWx0aUdldE9iamVjdFJlc3BvbnNlID0gY2hhbmdlZE9iamVjdFVybHMubGVuZ3RoXG4gICAgICAgICAgICA/ICgoX2MgPSAoYXdhaXQgKChfYiA9IGNvbGxlY3Rpb24gPT09IG51bGwgfHwgY29sbGVjdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29sbGVjdGlvbi5vYmplY3RNdWx0aUdldCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoY29sbGVjdGlvbiwge1xuICAgICAgICAgICAgICAgIHVybDogY29sbGVjdGlvbi51cmwsXG4gICAgICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgW2Ake0RBVk5hbWVzcGFjZVNob3J0LkRBVn06Z2V0ZXRhZ2BdOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgW2Ake2FjY291bnQuYWNjb3VudFR5cGUgPT09ICdjYWxkYXYnXG4gICAgICAgICAgICAgICAgICAgICAgICA/IERBVk5hbWVzcGFjZVNob3J0LkNBTERBVlxuICAgICAgICAgICAgICAgICAgICAgICAgOiBEQVZOYW1lc3BhY2VTaG9ydC5DQVJEREFWfToke2FjY291bnQuYWNjb3VudFR5cGUgPT09ICdjYWxkYXYnID8gJ2NhbGVuZGFyLWRhdGEnIDogJ2FkZHJlc3MtZGF0YSd9YF06IHt9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb2JqZWN0VXJsczogY2hhbmdlZE9iamVjdFVybHMsXG4gICAgICAgICAgICAgICAgZGVwdGg6ICcxJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBleGNsdWRlSGVhZGVycyhoZWFkZXJzLCBoZWFkZXJzVG9FeGNsdWRlKSxcbiAgICAgICAgICAgICAgICBmZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgZmV0Y2g6IGZldGNoT3ZlcnJpZGUsXG4gICAgICAgICAgICB9KSkpKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBbXSlcbiAgICAgICAgICAgIDogW107XG4gICAgICAgIGNvbnN0IHJlbW90ZU9iamVjdHMgPSBtdWx0aUdldE9iamVjdFJlc3BvbnNlLm1hcCgocmVzKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaiwgX2s7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKF9hID0gcmVzLmhyZWYpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnLFxuICAgICAgICAgICAgICAgIGV0YWc6IChfYiA9IHJlcy5wcm9wcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmdldGV0YWcsXG4gICAgICAgICAgICAgICAgZGF0YTogKGFjY291bnQgPT09IG51bGwgfHwgYWNjb3VudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWNjb3VudC5hY2NvdW50VHlwZSkgPT09ICdjYWxkYXYnXG4gICAgICAgICAgICAgICAgICAgID8gKChfZSA9IChfZCA9IChfYyA9IHJlcy5wcm9wcykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhbGVuZGFyRGF0YSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLl9jZGF0YSkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogKF9mID0gcmVzLnByb3BzKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuY2FsZW5kYXJEYXRhKVxuICAgICAgICAgICAgICAgICAgICA6ICgoX2ogPSAoX2ggPSAoX2cgPSByZXMucHJvcHMpID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy5hZGRyZXNzRGF0YSkgPT09IG51bGwgfHwgX2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9oLl9jZGF0YSkgIT09IG51bGwgJiYgX2ogIT09IHZvaWQgMCA/IF9qIDogKF9rID0gcmVzLnByb3BzKSA9PT0gbnVsbCB8fCBfayA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2suYWRkcmVzc0RhdGEpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGxvY2FsT2JqZWN0cyA9IChfZCA9IGNvbGxlY3Rpb24ub2JqZWN0cykgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogW107XG4gICAgICAgIC8vIG5vIGV4aXN0aW5nIHVybFxuICAgICAgICBjb25zdCBjcmVhdGVkID0gcmVtb3RlT2JqZWN0cy5maWx0ZXIoKG8pID0+IGxvY2FsT2JqZWN0cy5ldmVyeSgobG8pID0+ICF1cmxDb250YWlucyhsby51cmwsIG8udXJsKSkpO1xuICAgICAgICAvLyBkZWJ1ZyhgY3JlYXRlZCBvYmplY3RzOiAke2NyZWF0ZWQubWFwKChvKSA9PiBvLnVybCkuam9pbignXFxuJyl9YCk7XG4gICAgICAgIC8vIGhhdmUgc2FtZSB1cmwsIGJ1dCBldGFnIGRpZmZlcmVudFxuICAgICAgICBjb25zdCB1cGRhdGVkID0gbG9jYWxPYmplY3RzLnJlZHVjZSgocHJldiwgY3VycikgPT4ge1xuICAgICAgICAgICAgY29uc3QgZm91bmQgPSByZW1vdGVPYmplY3RzLmZpbmQoKHJvKSA9PiB1cmxDb250YWlucyhyby51cmwsIGN1cnIudXJsKSk7XG4gICAgICAgICAgICBpZiAoZm91bmQgJiYgZm91bmQuZXRhZyAmJiBmb3VuZC5ldGFnICE9PSBjdXJyLmV0YWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWy4uLnByZXYsIGZvdW5kXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgICB9LCBbXSk7XG4gICAgICAgIC8vIGRlYnVnKGB1cGRhdGVkIG9iamVjdHM6ICR7dXBkYXRlZC5tYXAoKG8pID0+IG8udXJsKS5qb2luKCdcXG4nKX1gKTtcbiAgICAgICAgY29uc3QgZGVsZXRlZCA9IGRlbGV0ZWRPYmplY3RVcmxzLm1hcCgobykgPT4gKHtcbiAgICAgICAgICAgIHVybDogbyxcbiAgICAgICAgICAgIGV0YWc6ICcnLFxuICAgICAgICB9KSk7XG4gICAgICAgIC8vIGRlYnVnKGBkZWxldGVkIG9iamVjdHM6ICR7ZGVsZXRlZC5tYXAoKG8pID0+IG8udXJsKS5qb2luKCdcXG4nKX1gKTtcbiAgICAgICAgY29uc3QgdW5jaGFuZ2VkID0gbG9jYWxPYmplY3RzLmZpbHRlcigobG8pID0+IHJlbW90ZU9iamVjdHMuc29tZSgocm8pID0+IHVybENvbnRhaW5zKGxvLnVybCwgcm8udXJsKSAmJiByby5ldGFnID09PSBsby5ldGFnKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5jb2xsZWN0aW9uLFxuICAgICAgICAgICAgb2JqZWN0czogZGV0YWlsZWRSZXN1bHRcbiAgICAgICAgICAgICAgICA/IHsgY3JlYXRlZCwgdXBkYXRlZCwgZGVsZXRlZCB9XG4gICAgICAgICAgICAgICAgOiBbLi4udW5jaGFuZ2VkLCAuLi5jcmVhdGVkLCAuLi51cGRhdGVkXSxcbiAgICAgICAgICAgIC8vIGFsbCBzeW5jVG9rZW4gaW4gdGhlIHJlc3VsdHMgYXJlIHRoZSBzYW1lIHNvIHdlIHVzZSB0aGUgZmlyc3Qgb25lIGhlcmVcbiAgICAgICAgICAgIHN5bmNUb2tlbjogKF9oID0gKF9nID0gKF9mID0gKF9lID0gcmVzdWx0WzBdKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UucmF3KSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YubXVsdGlzdGF0dXMpID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy5zeW5jVG9rZW4pICE9PSBudWxsICYmIF9oICE9PSB2b2lkIDAgPyBfaCA6IGNvbGxlY3Rpb24uc3luY1Rva2VuLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoc3luY01ldGhvZCA9PT0gJ2Jhc2ljJykge1xuICAgICAgICBjb25zdCB7IGlzRGlydHksIG5ld0N0YWcgfSA9IGF3YWl0IGlzQ29sbGVjdGlvbkRpcnR5KHtcbiAgICAgICAgICAgIGNvbGxlY3Rpb24sXG4gICAgICAgICAgICBoZWFkZXJzOiBleGNsdWRlSGVhZGVycyhoZWFkZXJzLCBoZWFkZXJzVG9FeGNsdWRlKSxcbiAgICAgICAgICAgIGZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgIGZldGNoOiBmZXRjaE92ZXJyaWRlLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgbG9jYWxPYmplY3RzID0gKF9qID0gY29sbGVjdGlvbi5vYmplY3RzKSAhPT0gbnVsbCAmJiBfaiAhPT0gdm9pZCAwID8gX2ogOiBbXTtcbiAgICAgICAgY29uc3QgcmVtb3RlT2JqZWN0cyA9IChfbSA9IChhd2FpdCAoKF9sID0gKF9rID0gY29sbGVjdGlvbikuZmV0Y2hPYmplY3RzKSA9PT0gbnVsbCB8fCBfbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2wuY2FsbChfaywge1xuICAgICAgICAgICAgY29sbGVjdGlvbixcbiAgICAgICAgICAgIGhlYWRlcnM6IGV4Y2x1ZGVIZWFkZXJzKGhlYWRlcnMsIGhlYWRlcnNUb0V4Y2x1ZGUpLFxuICAgICAgICAgICAgZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgZmV0Y2g6IGZldGNoT3ZlcnJpZGUsXG4gICAgICAgIH0pKSkpICE9PSBudWxsICYmIF9tICE9PSB2b2lkIDAgPyBfbSA6IFtdO1xuICAgICAgICAvLyBubyBleGlzdGluZyB1cmxcbiAgICAgICAgY29uc3QgY3JlYXRlZCA9IHJlbW90ZU9iamVjdHMuZmlsdGVyKChybykgPT4gbG9jYWxPYmplY3RzLmV2ZXJ5KChsbykgPT4gIXVybENvbnRhaW5zKGxvLnVybCwgcm8udXJsKSkpO1xuICAgICAgICAvLyBkZWJ1ZyhgY3JlYXRlZCBvYmplY3RzOiAke2NyZWF0ZWQubWFwKChvKSA9PiBvLnVybCkuam9pbignXFxuJyl9YCk7XG4gICAgICAgIC8vIGhhdmUgc2FtZSB1cmwsIGJ1dCBldGFnIGRpZmZlcmVudFxuICAgICAgICBjb25zdCB1cGRhdGVkID0gbG9jYWxPYmplY3RzLnJlZHVjZSgocHJldiwgY3VycikgPT4ge1xuICAgICAgICAgICAgY29uc3QgZm91bmQgPSByZW1vdGVPYmplY3RzLmZpbmQoKHJvKSA9PiB1cmxDb250YWlucyhyby51cmwsIGN1cnIudXJsKSk7XG4gICAgICAgICAgICBpZiAoZm91bmQgJiYgZm91bmQuZXRhZyAmJiBmb3VuZC5ldGFnICE9PSBjdXJyLmV0YWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWy4uLnByZXYsIGZvdW5kXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgICB9LCBbXSk7XG4gICAgICAgIC8vIGRlYnVnKGB1cGRhdGVkIG9iamVjdHM6ICR7dXBkYXRlZC5tYXAoKG8pID0+IG8udXJsKS5qb2luKCdcXG4nKX1gKTtcbiAgICAgICAgLy8gZG9lcyBub3QgcHJlc2VudCBpbiByZW1vdGVcbiAgICAgICAgY29uc3QgZGVsZXRlZCA9IGxvY2FsT2JqZWN0cy5maWx0ZXIoKGNhbCkgPT4gcmVtb3RlT2JqZWN0cy5ldmVyeSgocm8pID0+ICF1cmxDb250YWlucyhyby51cmwsIGNhbC51cmwpKSk7XG4gICAgICAgIC8vIGRlYnVnKGBkZWxldGVkIG9iamVjdHM6ICR7ZGVsZXRlZC5tYXAoKG8pID0+IG8udXJsKS5qb2luKCdcXG4nKX1gKTtcbiAgICAgICAgY29uc3QgdW5jaGFuZ2VkID0gbG9jYWxPYmplY3RzLmZpbHRlcigobG8pID0+IHJlbW90ZU9iamVjdHMuc29tZSgocm8pID0+IHVybENvbnRhaW5zKGxvLnVybCwgcm8udXJsKSAmJiByby5ldGFnID09PSBsby5ldGFnKSk7XG4gICAgICAgIGlmIChpc0RpcnR5KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLmNvbGxlY3Rpb24sXG4gICAgICAgICAgICAgICAgb2JqZWN0czogZGV0YWlsZWRSZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgPyB7IGNyZWF0ZWQsIHVwZGF0ZWQsIGRlbGV0ZWQgfVxuICAgICAgICAgICAgICAgICAgICA6IFsuLi51bmNoYW5nZWQsIC4uLmNyZWF0ZWQsIC4uLnVwZGF0ZWRdLFxuICAgICAgICAgICAgICAgIGN0YWc6IG5ld0N0YWcsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZXRhaWxlZFJlc3VsdFxuICAgICAgICA/IHtcbiAgICAgICAgICAgIC4uLmNvbGxlY3Rpb24sXG4gICAgICAgICAgICBvYmplY3RzOiB7XG4gICAgICAgICAgICAgICAgY3JlYXRlZDogW10sXG4gICAgICAgICAgICAgICAgdXBkYXRlZDogW10sXG4gICAgICAgICAgICAgICAgZGVsZXRlZDogW10sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9XG4gICAgICAgIDogY29sbGVjdGlvbjtcbn07XG5cbnZhciBjb2xsZWN0aW9uID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBjb2xsZWN0aW9uUXVlcnk6IGNvbGxlY3Rpb25RdWVyeSxcbiAgICBpc0NvbGxlY3Rpb25EaXJ0eTogaXNDb2xsZWN0aW9uRGlydHksXG4gICAgbWFrZUNvbGxlY3Rpb246IG1ha2VDb2xsZWN0aW9uLFxuICAgIHNtYXJ0Q29sbGVjdGlvblN5bmM6IHNtYXJ0Q29sbGVjdGlvblN5bmMsXG4gICAgc3VwcG9ydGVkUmVwb3J0U2V0OiBzdXBwb3J0ZWRSZXBvcnRTZXQsXG4gICAgc3luY0NvbGxlY3Rpb246IHN5bmNDb2xsZWN0aW9uXG59KTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZXJzY29yZS1kYW5nbGUgKi9cbmNvbnN0IGRlYnVnJDMgPSBnZXRMb2dnZXIoJ3RzZGF2OmFkZHJlc3NCb29rJyk7XG5jb25zdCBhZGRyZXNzQm9va1F1ZXJ5ID0gYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IHsgdXJsLCBwcm9wcywgZmlsdGVycywgZGVwdGgsIGhlYWRlcnMsIGhlYWRlcnNUb0V4Y2x1ZGUsIGZldGNoT3B0aW9ucyA9IHt9LCBmZXRjaDogZmV0Y2hPdmVycmlkZSwgfSA9IHBhcmFtcztcbiAgICByZXR1cm4gY29sbGVjdGlvblF1ZXJ5KHtcbiAgICAgICAgdXJsLFxuICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAnYWRkcmVzc2Jvb2stcXVlcnknOiBjbGVhbnVwRmFsc3koe1xuICAgICAgICAgICAgICAgIF9hdHRyaWJ1dGVzOiBnZXREQVZBdHRyaWJ1dGUoW0RBVk5hbWVzcGFjZS5DQVJEREFWLCBEQVZOYW1lc3BhY2UuREFWXSksXG4gICAgICAgICAgICAgICAgW2Ake0RBVk5hbWVzcGFjZVNob3J0LkRBVn06cHJvcGBdOiBwcm9wcyxcbiAgICAgICAgICAgICAgICBmaWx0ZXI6IGZpbHRlcnMgIT09IG51bGwgJiYgZmlsdGVycyAhPT0gdm9pZCAwID8gZmlsdGVycyA6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3Byb3AtZmlsdGVyJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2F0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnRk4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSksXG4gICAgICAgIH0sXG4gICAgICAgIGRlZmF1bHROYW1lc3BhY2U6IERBVk5hbWVzcGFjZVNob3J0LkNBUkREQVYsXG4gICAgICAgIGRlcHRoLFxuICAgICAgICBoZWFkZXJzOiBleGNsdWRlSGVhZGVycyhoZWFkZXJzLCBoZWFkZXJzVG9FeGNsdWRlKSxcbiAgICAgICAgZmV0Y2hPcHRpb25zLFxuICAgICAgICBmZXRjaDogZmV0Y2hPdmVycmlkZSxcbiAgICB9KTtcbn07XG5jb25zdCBhZGRyZXNzQm9va011bHRpR2V0ID0gYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IHsgdXJsLCBwcm9wcywgb2JqZWN0VXJscywgZGVwdGgsIGhlYWRlcnMsIGhlYWRlcnNUb0V4Y2x1ZGUsIGZldGNoT3B0aW9ucyA9IHt9LCBmZXRjaDogZmV0Y2hPdmVycmlkZSwgfSA9IHBhcmFtcztcbiAgICByZXR1cm4gY29sbGVjdGlvblF1ZXJ5KHtcbiAgICAgICAgdXJsLFxuICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAnYWRkcmVzc2Jvb2stbXVsdGlnZXQnOiBjbGVhbnVwRmFsc3koe1xuICAgICAgICAgICAgICAgIF9hdHRyaWJ1dGVzOiBnZXREQVZBdHRyaWJ1dGUoW0RBVk5hbWVzcGFjZS5EQVYsIERBVk5hbWVzcGFjZS5DQVJEREFWXSksXG4gICAgICAgICAgICAgICAgW2Ake0RBVk5hbWVzcGFjZVNob3J0LkRBVn06cHJvcGBdOiBwcm9wcyxcbiAgICAgICAgICAgICAgICBbYCR7REFWTmFtZXNwYWNlU2hvcnQuREFWfTpocmVmYF06IG9iamVjdFVybHMsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgfSxcbiAgICAgICAgZGVmYXVsdE5hbWVzcGFjZTogREFWTmFtZXNwYWNlU2hvcnQuQ0FSRERBVixcbiAgICAgICAgZGVwdGgsXG4gICAgICAgIGhlYWRlcnM6IGV4Y2x1ZGVIZWFkZXJzKGhlYWRlcnMsIGhlYWRlcnNUb0V4Y2x1ZGUpLFxuICAgICAgICBmZXRjaE9wdGlvbnMsXG4gICAgICAgIGZldGNoOiBmZXRjaE92ZXJyaWRlLFxuICAgIH0pO1xufTtcbmNvbnN0IGZldGNoQWRkcmVzc0Jvb2tzID0gYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IHsgYWNjb3VudCwgaGVhZGVycywgcHJvcHM6IGN1c3RvbVByb3BzLCBoZWFkZXJzVG9FeGNsdWRlLCBmZXRjaE9wdGlvbnMgPSB7fSwgZmV0Y2g6IGZldGNoT3ZlcnJpZGUsIH0gPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICBjb25zdCByZXF1aXJlZEZpZWxkcyA9IFsnaG9tZVVybCcsICdyb290VXJsJ107XG4gICAgaWYgKCFhY2NvdW50IHx8ICFoYXNGaWVsZHMoYWNjb3VudCwgcmVxdWlyZWRGaWVsZHMpKSB7XG4gICAgICAgIGlmICghYWNjb3VudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBhY2NvdW50IGZvciBmZXRjaEFkZHJlc3NCb29rcycpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgYWNjb3VudCBtdXN0IGhhdmUgJHtmaW5kTWlzc2luZ0ZpZWxkTmFtZXMoYWNjb3VudCwgcmVxdWlyZWRGaWVsZHMpfSBiZWZvcmUgZmV0Y2hBZGRyZXNzQm9va3NgKTtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gYXdhaXQgcHJvcGZpbmQoe1xuICAgICAgICB1cmw6IGFjY291bnQuaG9tZVVybCxcbiAgICAgICAgcHJvcHM6IGN1c3RvbVByb3BzICE9PSBudWxsICYmIGN1c3RvbVByb3BzICE9PSB2b2lkIDAgPyBjdXN0b21Qcm9wcyA6IHtcbiAgICAgICAgICAgIFtgJHtEQVZOYW1lc3BhY2VTaG9ydC5EQVZ9OmRpc3BsYXluYW1lYF06IHt9LFxuICAgICAgICAgICAgW2Ake0RBVk5hbWVzcGFjZVNob3J0LkNBTEVOREFSX1NFUlZFUn06Z2V0Y3RhZ2BdOiB7fSxcbiAgICAgICAgICAgIFtgJHtEQVZOYW1lc3BhY2VTaG9ydC5EQVZ9OnJlc291cmNldHlwZWBdOiB7fSxcbiAgICAgICAgICAgIFtgJHtEQVZOYW1lc3BhY2VTaG9ydC5EQVZ9OnN5bmMtdG9rZW5gXToge30sXG4gICAgICAgIH0sXG4gICAgICAgIGRlcHRoOiAnMScsXG4gICAgICAgIGhlYWRlcnM6IGV4Y2x1ZGVIZWFkZXJzKGhlYWRlcnMsIGhlYWRlcnNUb0V4Y2x1ZGUpLFxuICAgICAgICBmZXRjaE9wdGlvbnMsXG4gICAgICAgIGZldGNoOiBmZXRjaE92ZXJyaWRlLFxuICAgIH0pO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChyZXNcbiAgICAgICAgLmZpbHRlcigocikgPT4geyB2YXIgX2EsIF9iOyByZXR1cm4gT2JqZWN0LmtleXMoKF9iID0gKF9hID0gci5wcm9wcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlc291cmNldHlwZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDoge30pLmluY2x1ZGVzKCdhZGRyZXNzYm9vaycpOyB9KVxuICAgICAgICAubWFwKChycykgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfajtcbiAgICAgICAgY29uc3QgZGlzcGxheU5hbWUgPSAoX2MgPSAoX2IgPSAoX2EgPSBycy5wcm9wcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRpc3BsYXluYW1lKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuX2NkYXRhKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAoX2QgPSBycy5wcm9wcykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmRpc3BsYXluYW1lO1xuICAgICAgICBkZWJ1ZyQzKGBGb3VuZCBhZGRyZXNzIGJvb2sgbmFtZWQgJHt0eXBlb2YgZGlzcGxheU5hbWUgPT09ICdzdHJpbmcnID8gZGlzcGxheU5hbWUgOiAnJ30sXG4gICAgICAgICAgICAgcHJvcHM6ICR7SlNPTi5zdHJpbmdpZnkocnMucHJvcHMpfWApO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdXJsOiBuZXcgVVJMKChfZSA9IHJzLmhyZWYpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6ICcnLCAoX2YgPSBhY2NvdW50LnJvb3RVcmwpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6ICcnKS5ocmVmLFxuICAgICAgICAgICAgY3RhZzogKF9nID0gcnMucHJvcHMpID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy5nZXRjdGFnLFxuICAgICAgICAgICAgZGlzcGxheU5hbWU6IHR5cGVvZiBkaXNwbGF5TmFtZSA9PT0gJ3N0cmluZycgPyBkaXNwbGF5TmFtZSA6ICcnLFxuICAgICAgICAgICAgcmVzb3VyY2V0eXBlOiBPYmplY3Qua2V5cygoX2ggPSBycy5wcm9wcykgPT09IG51bGwgfHwgX2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9oLnJlc291cmNldHlwZSksXG4gICAgICAgICAgICBzeW5jVG9rZW46IChfaiA9IHJzLnByb3BzKSA9PT0gbnVsbCB8fCBfaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2ouc3luY1Rva2VuLFxuICAgICAgICB9O1xuICAgIH0pXG4gICAgICAgIC5tYXAoYXN5bmMgKGFkZHIpID0+ICh7XG4gICAgICAgIC4uLmFkZHIsXG4gICAgICAgIHJlcG9ydHM6IGF3YWl0IHN1cHBvcnRlZFJlcG9ydFNldCh7XG4gICAgICAgICAgICBjb2xsZWN0aW9uOiBhZGRyLFxuICAgICAgICAgICAgaGVhZGVyczogZXhjbHVkZUhlYWRlcnMoaGVhZGVycywgaGVhZGVyc1RvRXhjbHVkZSksXG4gICAgICAgICAgICBmZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICBmZXRjaDogZmV0Y2hPdmVycmlkZSxcbiAgICAgICAgfSksXG4gICAgfSkpKTtcbn07XG5jb25zdCBmZXRjaFZDYXJkcyA9IGFzeW5jIChwYXJhbXMpID0+IHtcbiAgICBjb25zdCB7IGFkZHJlc3NCb29rLCBoZWFkZXJzLCBvYmplY3RVcmxzLCBoZWFkZXJzVG9FeGNsdWRlLCB1cmxGaWx0ZXIgPSAodXJsKSA9PiB1cmwsIHVzZU11bHRpR2V0ID0gdHJ1ZSwgZmV0Y2hPcHRpb25zID0ge30sIGZldGNoOiBmZXRjaE92ZXJyaWRlLCB9ID0gcGFyYW1zO1xuICAgIGRlYnVnJDMoYEZldGNoaW5nIHZjYXJkcyBmcm9tICR7YWRkcmVzc0Jvb2sgPT09IG51bGwgfHwgYWRkcmVzc0Jvb2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFkZHJlc3NCb29rLnVybH1gKTtcbiAgICBjb25zdCByZXF1aXJlZEZpZWxkcyA9IFsndXJsJ107XG4gICAgaWYgKCFhZGRyZXNzQm9vayB8fCAhaGFzRmllbGRzKGFkZHJlc3NCb29rLCByZXF1aXJlZEZpZWxkcykpIHtcbiAgICAgICAgaWYgKCFhZGRyZXNzQm9vaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgZmV0Y2hWQ2FyZHMgZm9yIHVuZGVmaW5lZCBhZGRyZXNzQm9vaycpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgYWRkcmVzc0Jvb2sgbXVzdCBoYXZlICR7ZmluZE1pc3NpbmdGaWVsZE5hbWVzKGFkZHJlc3NCb29rLCByZXF1aXJlZEZpZWxkcyl9IGJlZm9yZSBmZXRjaFZDYXJkc2ApO1xuICAgIH1cbiAgICBjb25zdCB2Y2FyZFVybHMgPSAob2JqZWN0VXJscyAhPT0gbnVsbCAmJiBvYmplY3RVcmxzICE9PSB2b2lkIDAgPyBvYmplY3RVcmxzIDogXG4gICAgLy8gZmV0Y2ggYWxsIG9iamVjdHMgb2YgdGhlIGNhbGVuZGFyXG4gICAgKGF3YWl0IGFkZHJlc3NCb29rUXVlcnkoe1xuICAgICAgICB1cmw6IGFkZHJlc3NCb29rLnVybCxcbiAgICAgICAgcHJvcHM6IHsgW2Ake0RBVk5hbWVzcGFjZVNob3J0LkRBVn06Z2V0ZXRhZ2BdOiB7fSB9LFxuICAgICAgICBkZXB0aDogJzEnLFxuICAgICAgICBoZWFkZXJzOiBleGNsdWRlSGVhZGVycyhoZWFkZXJzLCBoZWFkZXJzVG9FeGNsdWRlKSxcbiAgICAgICAgZmV0Y2hPcHRpb25zLFxuICAgICAgICBmZXRjaDogZmV0Y2hPdmVycmlkZSxcbiAgICB9KSkubWFwKChyZXMpID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gcmVzLmhyZWYpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnOyB9KSlcbiAgICAgICAgLm1hcCgodXJsKSA9PiAodXJsLnN0YXJ0c1dpdGgoJ2h0dHAnKSB8fCAhdXJsID8gdXJsIDogbmV3IFVSTCh1cmwsIGFkZHJlc3NCb29rLnVybCkuaHJlZikpXG4gICAgICAgIC5maWx0ZXIoKHVybCkgPT4gdXJsICYmICF1cmxFcXVhbHModXJsLCBhZGRyZXNzQm9vay51cmwpKVxuICAgICAgICAuZmlsdGVyKHVybEZpbHRlcilcbiAgICAgICAgLm1hcCgodXJsKSA9PiBuZXcgVVJMKHVybCkucGF0aG5hbWUpO1xuICAgIGxldCB2Q2FyZFJlc3VsdHMgPSBbXTtcbiAgICBpZiAodmNhcmRVcmxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKHVzZU11bHRpR2V0KSB7XG4gICAgICAgICAgICB2Q2FyZFJlc3VsdHMgPSBhd2FpdCBhZGRyZXNzQm9va011bHRpR2V0KHtcbiAgICAgICAgICAgICAgICB1cmw6IGFkZHJlc3NCb29rLnVybCxcbiAgICAgICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgICAgICBbYCR7REFWTmFtZXNwYWNlU2hvcnQuREFWfTpnZXRldGFnYF06IHt9LFxuICAgICAgICAgICAgICAgICAgICBbYCR7REFWTmFtZXNwYWNlU2hvcnQuQ0FSRERBVn06YWRkcmVzcy1kYXRhYF06IHt9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb2JqZWN0VXJsczogdmNhcmRVcmxzLFxuICAgICAgICAgICAgICAgIGRlcHRoOiAnMScsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogZXhjbHVkZUhlYWRlcnMoaGVhZGVycywgaGVhZGVyc1RvRXhjbHVkZSksXG4gICAgICAgICAgICAgICAgZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgICAgIGZldGNoOiBmZXRjaE92ZXJyaWRlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2Q2FyZFJlc3VsdHMgPSBhd2FpdCBhZGRyZXNzQm9va1F1ZXJ5KHtcbiAgICAgICAgICAgICAgICB1cmw6IGFkZHJlc3NCb29rLnVybCxcbiAgICAgICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgICAgICBbYCR7REFWTmFtZXNwYWNlU2hvcnQuREFWfTpnZXRldGFnYF06IHt9LFxuICAgICAgICAgICAgICAgICAgICBbYCR7REFWTmFtZXNwYWNlU2hvcnQuQ0FSRERBVn06YWRkcmVzcy1kYXRhYF06IHt9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGVwdGg6ICcxJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBleGNsdWRlSGVhZGVycyhoZWFkZXJzLCBoZWFkZXJzVG9FeGNsdWRlKSxcbiAgICAgICAgICAgICAgICBmZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgZmV0Y2g6IGZldGNoT3ZlcnJpZGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdkNhcmRSZXN1bHRzLm1hcCgocmVzKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgICByZXR1cm4gKHtcbiAgICAgICAgICAgIHVybDogbmV3IFVSTCgoX2EgPSByZXMuaHJlZikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJycsIGFkZHJlc3NCb29rLnVybCkuaHJlZixcbiAgICAgICAgICAgIGV0YWc6IChfYiA9IHJlcy5wcm9wcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmdldGV0YWcsXG4gICAgICAgICAgICBkYXRhOiAoX2UgPSAoX2QgPSAoX2MgPSByZXMucHJvcHMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5hZGRyZXNzRGF0YSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLl9jZGF0YSkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogKF9mID0gcmVzLnByb3BzKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuYWRkcmVzc0RhdGEsXG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcbmNvbnN0IGNyZWF0ZVZDYXJkID0gYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IHsgYWRkcmVzc0Jvb2ssIHZDYXJkU3RyaW5nLCBmaWxlbmFtZSwgaGVhZGVycywgaGVhZGVyc1RvRXhjbHVkZSwgZmV0Y2hPcHRpb25zID0ge30sIGZldGNoOiBmZXRjaE92ZXJyaWRlLCB9ID0gcGFyYW1zO1xuICAgIHJldHVybiBjcmVhdGVPYmplY3Qoe1xuICAgICAgICB1cmw6IG5ldyBVUkwoZmlsZW5hbWUsIGFkZHJlc3NCb29rLnVybCkuaHJlZixcbiAgICAgICAgZGF0YTogdkNhcmRTdHJpbmcsXG4gICAgICAgIGhlYWRlcnM6IGV4Y2x1ZGVIZWFkZXJzKHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAndGV4dC92Y2FyZDsgY2hhcnNldD11dGYtOCcsXG4gICAgICAgICAgICAnSWYtTm9uZS1NYXRjaCc6ICcqJyxcbiAgICAgICAgICAgIC4uLmhlYWRlcnMsXG4gICAgICAgIH0sIGhlYWRlcnNUb0V4Y2x1ZGUpLFxuICAgICAgICBmZXRjaE9wdGlvbnMsXG4gICAgICAgIGZldGNoOiBmZXRjaE92ZXJyaWRlLFxuICAgIH0pO1xufTtcbmNvbnN0IHVwZGF0ZVZDYXJkID0gYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IHsgdkNhcmQsIGhlYWRlcnMsIGhlYWRlcnNUb0V4Y2x1ZGUsIGZldGNoT3B0aW9ucyA9IHt9LCBmZXRjaDogZmV0Y2hPdmVycmlkZSB9ID0gcGFyYW1zO1xuICAgIHJldHVybiB1cGRhdGVPYmplY3Qoe1xuICAgICAgICB1cmw6IHZDYXJkLnVybCxcbiAgICAgICAgZGF0YTogdkNhcmQuZGF0YSxcbiAgICAgICAgZXRhZzogdkNhcmQuZXRhZyxcbiAgICAgICAgaGVhZGVyczogZXhjbHVkZUhlYWRlcnMoe1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICd0ZXh0L3ZjYXJkOyBjaGFyc2V0PXV0Zi04JyxcbiAgICAgICAgICAgIC4uLmhlYWRlcnMsXG4gICAgICAgIH0sIGhlYWRlcnNUb0V4Y2x1ZGUpLFxuICAgICAgICBmZXRjaE9wdGlvbnMsXG4gICAgICAgIGZldGNoOiBmZXRjaE92ZXJyaWRlLFxuICAgIH0pO1xufTtcbmNvbnN0IGRlbGV0ZVZDYXJkID0gYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IHsgdkNhcmQsIGhlYWRlcnMsIGhlYWRlcnNUb0V4Y2x1ZGUsIGZldGNoT3B0aW9ucyA9IHt9LCBmZXRjaDogZmV0Y2hPdmVycmlkZSB9ID0gcGFyYW1zO1xuICAgIHJldHVybiBkZWxldGVPYmplY3Qoe1xuICAgICAgICB1cmw6IHZDYXJkLnVybCxcbiAgICAgICAgZXRhZzogdkNhcmQuZXRhZyxcbiAgICAgICAgaGVhZGVyczogZXhjbHVkZUhlYWRlcnMoaGVhZGVycywgaGVhZGVyc1RvRXhjbHVkZSksXG4gICAgICAgIGZldGNoT3B0aW9ucyxcbiAgICAgICAgZmV0Y2g6IGZldGNoT3ZlcnJpZGUsXG4gICAgfSk7XG59O1xuXG52YXIgYWRkcmVzc0Jvb2sgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGFkZHJlc3NCb29rTXVsdGlHZXQ6IGFkZHJlc3NCb29rTXVsdGlHZXQsXG4gICAgYWRkcmVzc0Jvb2tRdWVyeTogYWRkcmVzc0Jvb2tRdWVyeSxcbiAgICBjcmVhdGVWQ2FyZDogY3JlYXRlVkNhcmQsXG4gICAgZGVsZXRlVkNhcmQ6IGRlbGV0ZVZDYXJkLFxuICAgIGZldGNoQWRkcmVzc0Jvb2tzOiBmZXRjaEFkZHJlc3NCb29rcyxcbiAgICBmZXRjaFZDYXJkczogZmV0Y2hWQ2FyZHMsXG4gICAgdXBkYXRlVkNhcmQ6IHVwZGF0ZVZDYXJkXG59KTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZXJzY29yZS1kYW5nbGUgKi9cbmNvbnN0IGRlYnVnJDIgPSBnZXRMb2dnZXIoJ3RzZGF2OmNhbGVuZGFyJyk7XG5jb25zdCBmZXRjaENhbGVuZGFyVXNlckFkZHJlc3NlcyA9IGFzeW5jIChwYXJhbXMpID0+IHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBjb25zdCB7IGFjY291bnQsIGhlYWRlcnMsIGhlYWRlcnNUb0V4Y2x1ZGUsIGZldGNoT3B0aW9ucyA9IHt9LCBmZXRjaDogZmV0Y2hPdmVycmlkZSB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHJlcXVpcmVkRmllbGRzID0gWydwcmluY2lwYWxVcmwnLCAncm9vdFVybCddO1xuICAgIGlmICghaGFzRmllbGRzKGFjY291bnQsIHJlcXVpcmVkRmllbGRzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGFjY291bnQgbXVzdCBoYXZlICR7ZmluZE1pc3NpbmdGaWVsZE5hbWVzKGFjY291bnQsIHJlcXVpcmVkRmllbGRzKX0gYmVmb3JlIGZldGNoVXNlckFkZHJlc3Nlc2ApO1xuICAgIH1cbiAgICBkZWJ1ZyQyKGBGZXRjaCB1c2VyIGFkZHJlc3NlcyBmcm9tICR7YWNjb3VudC5wcmluY2lwYWxVcmx9YCk7XG4gICAgY29uc3QgcmVzcG9uc2VzID0gYXdhaXQgcHJvcGZpbmQoe1xuICAgICAgICB1cmw6IGFjY291bnQucHJpbmNpcGFsVXJsLFxuICAgICAgICBwcm9wczogeyBbYCR7REFWTmFtZXNwYWNlU2hvcnQuQ0FMREFWfTpjYWxlbmRhci11c2VyLWFkZHJlc3Mtc2V0YF06IHt9IH0sXG4gICAgICAgIGRlcHRoOiAnMCcsXG4gICAgICAgIGhlYWRlcnM6IGV4Y2x1ZGVIZWFkZXJzKGhlYWRlcnMsIGhlYWRlcnNUb0V4Y2x1ZGUpLFxuICAgICAgICBmZXRjaE9wdGlvbnMsXG4gICAgICAgIGZldGNoOiBmZXRjaE92ZXJyaWRlLFxuICAgIH0pO1xuICAgIGNvbnN0IG1hdGNoZWQgPSByZXNwb25zZXMuZmluZCgocikgPT4gdXJsQ29udGFpbnMoYWNjb3VudC5wcmluY2lwYWxVcmwsIHIuaHJlZikpO1xuICAgIGlmICghbWF0Y2hlZCB8fCAhbWF0Y2hlZC5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBmaW5kIGNhbGVuZGFyVXNlckFkZHJlc3NlcycpO1xuICAgIH1cbiAgICBjb25zdCBhZGRyZXNzZXMgPSAoKF9jID0gKF9iID0gKF9hID0gbWF0Y2hlZCA9PT0gbnVsbCB8fCBtYXRjaGVkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXRjaGVkLnByb3BzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsZW5kYXJVc2VyQWRkcmVzc1NldCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmhyZWYpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5maWx0ZXIoQm9vbGVhbikpIHx8IFtdO1xuICAgIGRlYnVnJDIoYEZldGNoZWQgY2FsZW5kYXIgdXNlciBhZGRyZXNzZXMgJHthZGRyZXNzZXN9YCk7XG4gICAgcmV0dXJuIGFkZHJlc3Nlcztcbn07XG5jb25zdCBjYWxlbmRhclF1ZXJ5ID0gYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IHsgdXJsLCBwcm9wcywgZmlsdGVycywgdGltZXpvbmUsIGRlcHRoLCBoZWFkZXJzLCBoZWFkZXJzVG9FeGNsdWRlLCBmZXRjaE9wdGlvbnMgPSB7fSwgZmV0Y2g6IGZldGNoT3ZlcnJpZGUsIH0gPSBwYXJhbXM7XG4gICAgcmV0dXJuIGNvbGxlY3Rpb25RdWVyeSh7XG4gICAgICAgIHVybCxcbiAgICAgICAgYm9keToge1xuICAgICAgICAgICAgJ2NhbGVuZGFyLXF1ZXJ5JzogY2xlYW51cEZhbHN5KHtcbiAgICAgICAgICAgICAgICBfYXR0cmlidXRlczogZ2V0REFWQXR0cmlidXRlKFtcbiAgICAgICAgICAgICAgICAgICAgREFWTmFtZXNwYWNlLkNBTERBVixcbiAgICAgICAgICAgICAgICAgICAgREFWTmFtZXNwYWNlLkNBTEVOREFSX1NFUlZFUixcbiAgICAgICAgICAgICAgICAgICAgREFWTmFtZXNwYWNlLkNBTERBVl9BUFBMRSxcbiAgICAgICAgICAgICAgICAgICAgREFWTmFtZXNwYWNlLkRBVixcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICBbYCR7REFWTmFtZXNwYWNlU2hvcnQuREFWfTpwcm9wYF06IHByb3BzLFxuICAgICAgICAgICAgICAgIGZpbHRlcjogZmlsdGVycyxcbiAgICAgICAgICAgICAgICB0aW1lem9uZSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICB9LFxuICAgICAgICBkZWZhdWx0TmFtZXNwYWNlOiBEQVZOYW1lc3BhY2VTaG9ydC5DQUxEQVYsXG4gICAgICAgIGRlcHRoLFxuICAgICAgICBoZWFkZXJzOiBleGNsdWRlSGVhZGVycyhoZWFkZXJzLCBoZWFkZXJzVG9FeGNsdWRlKSxcbiAgICAgICAgZmV0Y2hPcHRpb25zLFxuICAgICAgICBmZXRjaDogZmV0Y2hPdmVycmlkZSxcbiAgICB9KTtcbn07XG5jb25zdCBjYWxlbmRhck11bHRpR2V0ID0gYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IHsgdXJsLCBwcm9wcywgb2JqZWN0VXJscywgZmlsdGVycywgdGltZXpvbmUsIGRlcHRoLCBoZWFkZXJzLCBoZWFkZXJzVG9FeGNsdWRlLCBmZXRjaE9wdGlvbnMgPSB7fSwgZmV0Y2g6IGZldGNoT3ZlcnJpZGUsIH0gPSBwYXJhbXM7XG4gICAgcmV0dXJuIGNvbGxlY3Rpb25RdWVyeSh7XG4gICAgICAgIHVybCxcbiAgICAgICAgYm9keToge1xuICAgICAgICAgICAgJ2NhbGVuZGFyLW11bHRpZ2V0JzogY2xlYW51cEZhbHN5KHtcbiAgICAgICAgICAgICAgICBfYXR0cmlidXRlczogZ2V0REFWQXR0cmlidXRlKFtEQVZOYW1lc3BhY2UuREFWLCBEQVZOYW1lc3BhY2UuQ0FMREFWXSksXG4gICAgICAgICAgICAgICAgW2Ake0RBVk5hbWVzcGFjZVNob3J0LkRBVn06cHJvcGBdOiBwcm9wcyxcbiAgICAgICAgICAgICAgICBbYCR7REFWTmFtZXNwYWNlU2hvcnQuREFWfTpocmVmYF06IG9iamVjdFVybHMsXG4gICAgICAgICAgICAgICAgZmlsdGVyOiBmaWx0ZXJzLFxuICAgICAgICAgICAgICAgIHRpbWV6b25lLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIH0sXG4gICAgICAgIGRlZmF1bHROYW1lc3BhY2U6IERBVk5hbWVzcGFjZVNob3J0LkNBTERBVixcbiAgICAgICAgZGVwdGgsXG4gICAgICAgIGhlYWRlcnM6IGV4Y2x1ZGVIZWFkZXJzKGhlYWRlcnMsIGhlYWRlcnNUb0V4Y2x1ZGUpLFxuICAgICAgICBmZXRjaE9wdGlvbnMsXG4gICAgICAgIGZldGNoOiBmZXRjaE92ZXJyaWRlLFxuICAgIH0pO1xufTtcbmNvbnN0IG1ha2VDYWxlbmRhciA9IGFzeW5jIChwYXJhbXMpID0+IHtcbiAgICBjb25zdCB7IHVybCwgcHJvcHMsIGRlcHRoLCBoZWFkZXJzLCBoZWFkZXJzVG9FeGNsdWRlLCBmZXRjaE9wdGlvbnMgPSB7fSwgZmV0Y2g6IGZldGNoT3ZlcnJpZGUsIH0gPSBwYXJhbXM7XG4gICAgcmV0dXJuIGRhdlJlcXVlc3Qoe1xuICAgICAgICB1cmwsXG4gICAgICAgIGluaXQ6IHtcbiAgICAgICAgICAgIG1ldGhvZDogJ01LQ0FMRU5EQVInLFxuICAgICAgICAgICAgaGVhZGVyczogZXhjbHVkZUhlYWRlcnMoY2xlYW51cEZhbHN5KHsgZGVwdGgsIC4uLmhlYWRlcnMgfSksIGhlYWRlcnNUb0V4Y2x1ZGUpLFxuICAgICAgICAgICAgbmFtZXNwYWNlOiBEQVZOYW1lc3BhY2VTaG9ydC5EQVYsXG4gICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgICAgW2Ake0RBVk5hbWVzcGFjZVNob3J0LkNBTERBVn06bWtjYWxlbmRhcmBdOiB7XG4gICAgICAgICAgICAgICAgICAgIF9hdHRyaWJ1dGVzOiBnZXREQVZBdHRyaWJ1dGUoW1xuICAgICAgICAgICAgICAgICAgICAgICAgREFWTmFtZXNwYWNlLkRBVixcbiAgICAgICAgICAgICAgICAgICAgICAgIERBVk5hbWVzcGFjZS5DQUxEQVYsXG4gICAgICAgICAgICAgICAgICAgICAgICBEQVZOYW1lc3BhY2UuQ0FMREFWX0FQUExFLFxuICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgc2V0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wOiBwcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgZmV0Y2hPcHRpb25zLFxuICAgICAgICBmZXRjaDogZmV0Y2hPdmVycmlkZSxcbiAgICB9KTtcbn07XG5jb25zdCBmZXRjaENhbGVuZGFycyA9IGFzeW5jIChwYXJhbXMpID0+IHtcbiAgICBjb25zdCB7IGhlYWRlcnMsIGFjY291bnQsIHByb3BzOiBjdXN0b21Qcm9wcywgcHJvamVjdGVkUHJvcHMsIGhlYWRlcnNUb0V4Y2x1ZGUsIGZldGNoT3B0aW9ucyA9IHt9LCBmZXRjaDogZmV0Y2hPdmVycmlkZSwgfSA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgIGNvbnN0IHJlcXVpcmVkRmllbGRzID0gWydob21lVXJsJywgJ3Jvb3RVcmwnXTtcbiAgICBpZiAoIWFjY291bnQgfHwgIWhhc0ZpZWxkcyhhY2NvdW50LCByZXF1aXJlZEZpZWxkcykpIHtcbiAgICAgICAgaWYgKCFhY2NvdW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIGFjY291bnQgZm9yIGZldGNoQ2FsZW5kYXJzJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBhY2NvdW50IG11c3QgaGF2ZSAke2ZpbmRNaXNzaW5nRmllbGROYW1lcyhhY2NvdW50LCByZXF1aXJlZEZpZWxkcyl9IGJlZm9yZSBmZXRjaENhbGVuZGFyc2ApO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBhd2FpdCBwcm9wZmluZCh7XG4gICAgICAgIHVybDogYWNjb3VudC5ob21lVXJsLFxuICAgICAgICBwcm9wczogY3VzdG9tUHJvcHMgIT09IG51bGwgJiYgY3VzdG9tUHJvcHMgIT09IHZvaWQgMCA/IGN1c3RvbVByb3BzIDoge1xuICAgICAgICAgICAgW2Ake0RBVk5hbWVzcGFjZVNob3J0LkNBTERBVn06Y2FsZW5kYXItZGVzY3JpcHRpb25gXToge30sXG4gICAgICAgICAgICBbYCR7REFWTmFtZXNwYWNlU2hvcnQuQ0FMREFWfTpjYWxlbmRhci10aW1lem9uZWBdOiB7fSxcbiAgICAgICAgICAgIFtgJHtEQVZOYW1lc3BhY2VTaG9ydC5EQVZ9OmRpc3BsYXluYW1lYF06IHt9LFxuICAgICAgICAgICAgW2Ake0RBVk5hbWVzcGFjZVNob3J0LkNBTERBVl9BUFBMRX06Y2FsZW5kYXItY29sb3JgXToge30sXG4gICAgICAgICAgICBbYCR7REFWTmFtZXNwYWNlU2hvcnQuQ0FMRU5EQVJfU0VSVkVSfTpnZXRjdGFnYF06IHt9LFxuICAgICAgICAgICAgW2Ake0RBVk5hbWVzcGFjZVNob3J0LkRBVn06cmVzb3VyY2V0eXBlYF06IHt9LFxuICAgICAgICAgICAgW2Ake0RBVk5hbWVzcGFjZVNob3J0LkNBTERBVn06c3VwcG9ydGVkLWNhbGVuZGFyLWNvbXBvbmVudC1zZXRgXToge30sXG4gICAgICAgICAgICBbYCR7REFWTmFtZXNwYWNlU2hvcnQuREFWfTpzeW5jLXRva2VuYF06IHt9LFxuICAgICAgICB9LFxuICAgICAgICBkZXB0aDogJzEnLFxuICAgICAgICBoZWFkZXJzOiBleGNsdWRlSGVhZGVycyhoZWFkZXJzLCBoZWFkZXJzVG9FeGNsdWRlKSxcbiAgICAgICAgZmV0Y2hPcHRpb25zLFxuICAgICAgICBmZXRjaDogZmV0Y2hPdmVycmlkZSxcbiAgICB9KTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocmVzXG4gICAgICAgIC5maWx0ZXIoKHIpID0+IHsgdmFyIF9hLCBfYjsgcmV0dXJuIE9iamVjdC5rZXlzKChfYiA9IChfYSA9IHIucHJvcHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZXNvdXJjZXR5cGUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHt9KS5pbmNsdWRlcygnY2FsZW5kYXInKTsgfSlcbiAgICAgICAgLmZpbHRlcigocmMpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgIC8vIGZpbHRlciBvdXQgbm9uZSBpQ2FsIGZvcm1hdCBjYWxlbmRhcnMuXG4gICAgICAgIGNvbnN0IGNvbXBvbmVudHMgPSBBcnJheS5pc0FycmF5KChfYiA9IChfYSA9IHJjLnByb3BzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3VwcG9ydGVkQ2FsZW5kYXJDb21wb25lbnRTZXQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jb21wKVxuICAgICAgICAgICAgPyAoX2MgPSByYy5wcm9wcykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnN1cHBvcnRlZENhbGVuZGFyQ29tcG9uZW50U2V0LmNvbXAubWFwKChzYykgPT4gc2MuX2F0dHJpYnV0ZXMubmFtZSlcbiAgICAgICAgICAgIDogWyhfZiA9IChfZSA9IChfZCA9IHJjLnByb3BzKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Quc3VwcG9ydGVkQ2FsZW5kYXJDb21wb25lbnRTZXQpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5jb21wKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuX2F0dHJpYnV0ZXMubmFtZV07XG4gICAgICAgIHJldHVybiBjb21wb25lbnRzLnNvbWUoKGMpID0+IE9iamVjdC52YWx1ZXMoSUNBTE9iamVjdHMpLmluY2x1ZGVzKGMpKTtcbiAgICB9KVxuICAgICAgICAubWFwKChycykgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaiwgX2ssIF9sLCBfbSwgX28sIF9wLCBfcSwgX3I7XG4gICAgICAgIC8vIGRlYnVnKGBGb3VuZCBjYWxlbmRhciAke3JzLnByb3BzPy5kaXNwbGF5bmFtZX1gKTtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSAoX2EgPSBycy5wcm9wcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGVuZGFyRGVzY3JpcHRpb247XG4gICAgICAgIGNvbnN0IHRpbWV6b25lID0gKF9iID0gcnMucHJvcHMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxlbmRhclRpbWV6b25lO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGVzY3JpcHRpb246IHR5cGVvZiBkZXNjcmlwdGlvbiA9PT0gJ3N0cmluZycgPyBkZXNjcmlwdGlvbiA6ICcnLFxuICAgICAgICAgICAgdGltZXpvbmU6IHR5cGVvZiB0aW1lem9uZSA9PT0gJ3N0cmluZycgPyB0aW1lem9uZSA6ICcnLFxuICAgICAgICAgICAgdXJsOiBuZXcgVVJMKChfYyA9IHJzLmhyZWYpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6ICcnLCAoX2QgPSBhY2NvdW50LnJvb3RVcmwpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6ICcnKS5ocmVmLFxuICAgICAgICAgICAgY3RhZzogKF9lID0gcnMucHJvcHMpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5nZXRjdGFnLFxuICAgICAgICAgICAgY2FsZW5kYXJDb2xvcjogKF9mID0gcnMucHJvcHMpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5jYWxlbmRhckNvbG9yLFxuICAgICAgICAgICAgZGlzcGxheU5hbWU6IChfaCA9IChfZyA9IHJzLnByb3BzKSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cuZGlzcGxheW5hbWUuX2NkYXRhKSAhPT0gbnVsbCAmJiBfaCAhPT0gdm9pZCAwID8gX2ggOiAoX2ogPSBycy5wcm9wcykgPT09IG51bGwgfHwgX2ogPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9qLmRpc3BsYXluYW1lLFxuICAgICAgICAgICAgY29tcG9uZW50czogQXJyYXkuaXNBcnJheSgoX2sgPSBycy5wcm9wcykgPT09IG51bGwgfHwgX2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9rLnN1cHBvcnRlZENhbGVuZGFyQ29tcG9uZW50U2V0LmNvbXApXG4gICAgICAgICAgICAgICAgPyAoX2wgPSBycy5wcm9wcykgPT09IG51bGwgfHwgX2wgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9sLnN1cHBvcnRlZENhbGVuZGFyQ29tcG9uZW50U2V0LmNvbXAubWFwKChzYykgPT4gc2MuX2F0dHJpYnV0ZXMubmFtZSlcbiAgICAgICAgICAgICAgICA6IFsoX28gPSAoX20gPSBycy5wcm9wcykgPT09IG51bGwgfHwgX20gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9tLnN1cHBvcnRlZENhbGVuZGFyQ29tcG9uZW50U2V0LmNvbXApID09PSBudWxsIHx8IF9vID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfby5fYXR0cmlidXRlcy5uYW1lXSxcbiAgICAgICAgICAgIHJlc291cmNldHlwZTogT2JqZWN0LmtleXMoKF9wID0gcnMucHJvcHMpID09PSBudWxsIHx8IF9wID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcC5yZXNvdXJjZXR5cGUpLFxuICAgICAgICAgICAgc3luY1Rva2VuOiAoX3EgPSBycy5wcm9wcykgPT09IG51bGwgfHwgX3EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9xLnN5bmNUb2tlbixcbiAgICAgICAgICAgIC4uLmNvbmRpdGlvbmFsUGFyYW0oJ3Byb2plY3RlZFByb3BzJywgT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKChfciA9IHJzLnByb3BzKSAhPT0gbnVsbCAmJiBfciAhPT0gdm9pZCAwID8gX3IgOiB7fSkuZmlsdGVyKChba2V5XSkgPT4gcHJvamVjdGVkUHJvcHMgPT09IG51bGwgfHwgcHJvamVjdGVkUHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb2plY3RlZFByb3BzW2tleV0pKSksXG4gICAgICAgIH07XG4gICAgfSlcbiAgICAgICAgLm1hcChhc3luYyAoY2FsKSA9PiAoe1xuICAgICAgICAuLi5jYWwsXG4gICAgICAgIHJlcG9ydHM6IGF3YWl0IHN1cHBvcnRlZFJlcG9ydFNldCh7XG4gICAgICAgICAgICBjb2xsZWN0aW9uOiBjYWwsXG4gICAgICAgICAgICBoZWFkZXJzOiBleGNsdWRlSGVhZGVycyhoZWFkZXJzLCBoZWFkZXJzVG9FeGNsdWRlKSxcbiAgICAgICAgICAgIGZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgIGZldGNoOiBmZXRjaE92ZXJyaWRlLFxuICAgICAgICB9KSxcbiAgICB9KSkpO1xufTtcbmNvbnN0IGZldGNoQ2FsZW5kYXJPYmplY3RzID0gYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IHsgY2FsZW5kYXIsIG9iamVjdFVybHMsIGZpbHRlcnM6IGN1c3RvbUZpbHRlcnMsIHRpbWVSYW5nZSwgaGVhZGVycywgZXhwYW5kLCB1cmxGaWx0ZXIgPSAodXJsKSA9PiBCb29sZWFuKHVybCA9PT0gbnVsbCB8fCB1cmwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHVybC5pbmNsdWRlcygnLmljcycpKSwgdXNlTXVsdGlHZXQgPSB0cnVlLCBoZWFkZXJzVG9FeGNsdWRlLCBmZXRjaE9wdGlvbnMgPSB7fSwgZmV0Y2g6IGZldGNoT3ZlcnJpZGUsIH0gPSBwYXJhbXM7XG4gICAgaWYgKHRpbWVSYW5nZSkge1xuICAgICAgICAvLyB2YWxpZGF0ZSB0aW1lUmFuZ2VcbiAgICAgICAgY29uc3QgSVNPXzg2MDEgPSAvXlxcZHs0fSgtXFxkXFxkKC1cXGRcXGQoVFxcZFxcZDpcXGRcXGQoOlxcZFxcZCk/KFxcLlxcZCspPygoWystXVxcZFxcZDpcXGRcXGQpfFopPyk/KT8pPyQvaTtcbiAgICAgICAgY29uc3QgSVNPXzg2MDFfRlVMTCA9IC9eXFxkezR9LVxcZFxcZC1cXGRcXGRUXFxkXFxkOlxcZFxcZDpcXGRcXGQoXFwuXFxkKyk/KChbKy1dXFxkXFxkOlxcZFxcZCl8Wik/JC9pO1xuICAgICAgICBpZiAoKCFJU09fODYwMS50ZXN0KHRpbWVSYW5nZS5zdGFydCkgfHwgIUlTT184NjAxLnRlc3QodGltZVJhbmdlLmVuZCkpICYmXG4gICAgICAgICAgICAoIUlTT184NjAxX0ZVTEwudGVzdCh0aW1lUmFuZ2Uuc3RhcnQpIHx8ICFJU09fODYwMV9GVUxMLnRlc3QodGltZVJhbmdlLmVuZCkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgdGltZVJhbmdlIGZvcm1hdCwgbm90IGluIElTTzg2MDEnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZWJ1ZyQyKGBGZXRjaGluZyBjYWxlbmRhciBvYmplY3RzIGZyb20gJHtjYWxlbmRhciA9PT0gbnVsbCB8fCBjYWxlbmRhciA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsZW5kYXIudXJsfWApO1xuICAgIGNvbnN0IHJlcXVpcmVkRmllbGRzID0gWyd1cmwnXTtcbiAgICBpZiAoIWNhbGVuZGFyIHx8ICFoYXNGaWVsZHMoY2FsZW5kYXIsIHJlcXVpcmVkRmllbGRzKSkge1xuICAgICAgICBpZiAoIWNhbGVuZGFyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBmZXRjaENhbGVuZGFyT2JqZWN0cyBmb3IgdW5kZWZpbmVkIGNhbGVuZGFyJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYWxlbmRhciBtdXN0IGhhdmUgJHtmaW5kTWlzc2luZ0ZpZWxkTmFtZXMoY2FsZW5kYXIsIHJlcXVpcmVkRmllbGRzKX0gYmVmb3JlIGZldGNoQ2FsZW5kYXJPYmplY3RzYCk7XG4gICAgfVxuICAgIC8vIGRlZmF1bHQgdG8gZmV0Y2ggYWxsXG4gICAgY29uc3QgZmlsdGVycyA9IGN1c3RvbUZpbHRlcnMgIT09IG51bGwgJiYgY3VzdG9tRmlsdGVycyAhPT0gdm9pZCAwID8gY3VzdG9tRmlsdGVycyA6IFtcbiAgICAgICAge1xuICAgICAgICAgICAgJ2NvbXAtZmlsdGVyJzoge1xuICAgICAgICAgICAgICAgIF9hdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdWQ0FMRU5EQVInLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2NvbXAtZmlsdGVyJzoge1xuICAgICAgICAgICAgICAgICAgICBfYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ1ZFVkVOVCcsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIC4uLih0aW1lUmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0aW1lLXJhbmdlJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGAke25ldyBEYXRlKHRpbWVSYW5nZS5zdGFydClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudG9JU09TdHJpbmcoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zbGljZSgwLCAxOSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvWy06Ll0vZywgJycpfVpgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBgJHtuZXcgRGF0ZSh0aW1lUmFuZ2UuZW5kKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50b0lTT1N0cmluZygpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNsaWNlKDAsIDE5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9bLTouXS9nLCAnJyl9WmAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIDoge30pLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIF07XG4gICAgbGV0IGluaXRpYWxSZXNwb25zZXMgPSBbXTtcbiAgICBjb25zdCBjYWxlbmRhck9iamVjdFVybHMgPSAob2JqZWN0VXJscyAhPT0gbnVsbCAmJiBvYmplY3RVcmxzICE9PSB2b2lkIDAgPyBvYmplY3RVcmxzIDogXG4gICAgLy8gZmV0Y2ggYWxsIG9iamVjdHMgb2YgdGhlIGNhbGVuZGFyXG4gICAgKGluaXRpYWxSZXNwb25zZXMgPSBhd2FpdCBjYWxlbmRhclF1ZXJ5KHtcbiAgICAgICAgdXJsOiBjYWxlbmRhci51cmwsXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICBbYCR7REFWTmFtZXNwYWNlU2hvcnQuREFWfTpnZXRldGFnYF06IHt9LFxuICAgICAgICAgICAgLi4uKGV4cGFuZCAmJiB0aW1lUmFuZ2VcbiAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgW2Ake0RBVk5hbWVzcGFjZVNob3J0LkNBTERBVn06Y2FsZW5kYXItZGF0YWBdOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBbYCR7REFWTmFtZXNwYWNlU2hvcnQuQ0FMREFWfTpleHBhbmRgXToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBgJHtuZXcgRGF0ZSh0aW1lUmFuZ2Uuc3RhcnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudG9JU09TdHJpbmcoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNsaWNlKDAsIDE5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1stOi5dL2csICcnKX1aYCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBgJHtuZXcgRGF0ZSh0aW1lUmFuZ2UuZW5kKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRvSVNPU3RyaW5nKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zbGljZSgwLCAxOSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9bLTouXS9nLCAnJyl9WmAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDoge30pLFxuICAgICAgICB9LFxuICAgICAgICBmaWx0ZXJzLFxuICAgICAgICBkZXB0aDogJzEnLFxuICAgICAgICBoZWFkZXJzOiBleGNsdWRlSGVhZGVycyhoZWFkZXJzLCBoZWFkZXJzVG9FeGNsdWRlKSxcbiAgICAgICAgZmV0Y2hPcHRpb25zLFxuICAgICAgICBmZXRjaDogZmV0Y2hPdmVycmlkZSxcbiAgICB9KSkubWFwKChyZXMpID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gcmVzLmhyZWYpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnOyB9KSlcbiAgICAgICAgLm1hcCgodXJsKSA9PiAodXJsLnN0YXJ0c1dpdGgoJ2h0dHAnKSB8fCAhdXJsID8gdXJsIDogbmV3IFVSTCh1cmwsIGNhbGVuZGFyLnVybCkuaHJlZikpIC8vIHBhdGNoIHVwIHRvIGZ1bGwgdXJsIGlmIHVybCBpcyBub3QgZnVsbFxuICAgICAgICAuZmlsdGVyKHVybEZpbHRlcikgLy8gY3VzdG9tIGZpbHRlciBmdW5jdGlvbiBvbiBjYWxlbmRhciBvYmplY3RzXG4gICAgICAgIC5tYXAoKHVybCkgPT4gbmV3IFVSTCh1cmwpLnBhdGhuYW1lKTsgLy8gb2J0YWluIHBhdGhuYW1lIG9mIHRoZSB1cmxcbiAgICBsZXQgY2FsZW5kYXJPYmplY3RSZXN1bHRzID0gW107XG4gICAgaWYgKGNhbGVuZGFyT2JqZWN0VXJscy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmIChleHBhbmQgJiYgIW9iamVjdFVybHMpIHtcbiAgICAgICAgICAgIGNhbGVuZGFyT2JqZWN0UmVzdWx0cyA9IGluaXRpYWxSZXNwb25zZXMuZmlsdGVyKChyZXMpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZ1bGxVcmwgPSAoKF9hID0gcmVzLmhyZWYpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnKS5zdGFydHNXaXRoKCdodHRwJylcbiAgICAgICAgICAgICAgICAgICAgPyByZXMuaHJlZlxuICAgICAgICAgICAgICAgICAgICA6IG5ldyBVUkwoKF9iID0gcmVzLmhyZWYpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcnLCBjYWxlbmRhci51cmwpLmhyZWY7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVybEZpbHRlcihmdWxsVXJsICE9PSBudWxsICYmIGZ1bGxVcmwgIT09IHZvaWQgMCA/IGZ1bGxVcmwgOiAnJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdXNlTXVsdGlHZXQpIHtcbiAgICAgICAgICAgIGNhbGVuZGFyT2JqZWN0UmVzdWx0cyA9IGF3YWl0IGNhbGVuZGFyUXVlcnkoe1xuICAgICAgICAgICAgICAgIHVybDogY2FsZW5kYXIudXJsLFxuICAgICAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgIFtgJHtEQVZOYW1lc3BhY2VTaG9ydC5EQVZ9OmdldGV0YWdgXToge30sXG4gICAgICAgICAgICAgICAgICAgIFtgJHtEQVZOYW1lc3BhY2VTaG9ydC5DQUxEQVZ9OmNhbGVuZGFyLWRhdGFgXToge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uKGV4cGFuZCAmJiB0aW1lUmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2Ake0RBVk5hbWVzcGFjZVNob3J0LkNBTERBVn06ZXhwYW5kYF06IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGAke25ldyBEYXRlKHRpbWVSYW5nZS5zdGFydClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRvSVNPU3RyaW5nKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNsaWNlKDAsIDE5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvWy06Ll0vZywgJycpfVpgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogYCR7bmV3IERhdGUodGltZVJhbmdlLmVuZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRvSVNPU3RyaW5nKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNsaWNlKDAsIDE5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvWy06Ll0vZywgJycpfVpgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB7fSksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBmaWx0ZXJzLFxuICAgICAgICAgICAgICAgIGRlcHRoOiAnMScsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogZXhjbHVkZUhlYWRlcnMoaGVhZGVycywgaGVhZGVyc1RvRXhjbHVkZSksXG4gICAgICAgICAgICAgICAgZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgICAgIGZldGNoOiBmZXRjaE92ZXJyaWRlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjYWxlbmRhck9iamVjdFJlc3VsdHMgPSBhd2FpdCBjYWxlbmRhck11bHRpR2V0KHtcbiAgICAgICAgICAgICAgICB1cmw6IGNhbGVuZGFyLnVybCxcbiAgICAgICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgICAgICBbYCR7REFWTmFtZXNwYWNlU2hvcnQuREFWfTpnZXRldGFnYF06IHt9LFxuICAgICAgICAgICAgICAgICAgICBbYCR7REFWTmFtZXNwYWNlU2hvcnQuQ0FMREFWfTpjYWxlbmRhci1kYXRhYF06IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLihleHBhbmQgJiYgdGltZVJhbmdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtgJHtEQVZOYW1lc3BhY2VTaG9ydC5DQUxEQVZ9OmV4cGFuZGBdOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBgJHtuZXcgRGF0ZSh0aW1lUmFuZ2Uuc3RhcnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50b0lTT1N0cmluZygpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zbGljZSgwLCAxOSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1stOi5dL2csICcnKX1aYCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGAke25ldyBEYXRlKHRpbWVSYW5nZS5lbmQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50b0lTT1N0cmluZygpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zbGljZSgwLCAxOSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1stOi5dL2csICcnKX1aYCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDoge30pLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb2JqZWN0VXJsczogY2FsZW5kYXJPYmplY3RVcmxzLFxuICAgICAgICAgICAgICAgIGRlcHRoOiAnMScsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogZXhjbHVkZUhlYWRlcnMoaGVhZGVycywgaGVhZGVyc1RvRXhjbHVkZSksXG4gICAgICAgICAgICAgICAgZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgICAgIGZldGNoOiBmZXRjaE92ZXJyaWRlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNhbGVuZGFyT2JqZWN0UmVzdWx0cy5tYXAoKHJlcykgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICAgICAgcmV0dXJuICh7XG4gICAgICAgICAgICB1cmw6IG5ldyBVUkwoKF9hID0gcmVzLmhyZWYpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnLCBjYWxlbmRhci51cmwpLmhyZWYsXG4gICAgICAgICAgICBldGFnOiBgJHsoX2IgPSByZXMucHJvcHMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5nZXRldGFnfWAsXG4gICAgICAgICAgICBkYXRhOiAoX2UgPSAoX2QgPSAoX2MgPSByZXMucHJvcHMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYWxlbmRhckRhdGEpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5fY2RhdGEpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IChfZiA9IHJlcy5wcm9wcykgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmNhbGVuZGFyRGF0YSxcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuY29uc3QgY3JlYXRlQ2FsZW5kYXJPYmplY3QgPSBhc3luYyAocGFyYW1zKSA9PiB7XG4gICAgY29uc3QgeyBjYWxlbmRhciwgaUNhbFN0cmluZywgZmlsZW5hbWUsIGhlYWRlcnMsIGhlYWRlcnNUb0V4Y2x1ZGUsIGZldGNoT3B0aW9ucyA9IHt9LCBmZXRjaDogZmV0Y2hPdmVycmlkZSwgfSA9IHBhcmFtcztcbiAgICByZXR1cm4gY3JlYXRlT2JqZWN0KHtcbiAgICAgICAgdXJsOiBuZXcgVVJMKGZpbGVuYW1lLCBjYWxlbmRhci51cmwpLmhyZWYsXG4gICAgICAgIGRhdGE6IGlDYWxTdHJpbmcsXG4gICAgICAgIGhlYWRlcnM6IGV4Y2x1ZGVIZWFkZXJzKHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAndGV4dC9jYWxlbmRhcjsgY2hhcnNldD11dGYtOCcsXG4gICAgICAgICAgICAnSWYtTm9uZS1NYXRjaCc6ICcqJyxcbiAgICAgICAgICAgIC4uLmhlYWRlcnMsXG4gICAgICAgIH0sIGhlYWRlcnNUb0V4Y2x1ZGUpLFxuICAgICAgICBmZXRjaE9wdGlvbnMsXG4gICAgICAgIGZldGNoOiBmZXRjaE92ZXJyaWRlLFxuICAgIH0pO1xufTtcbmNvbnN0IHVwZGF0ZUNhbGVuZGFyT2JqZWN0ID0gYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IHsgY2FsZW5kYXJPYmplY3QsIGhlYWRlcnMsIGhlYWRlcnNUb0V4Y2x1ZGUsIGZldGNoT3B0aW9ucyA9IHt9LCBmZXRjaDogZmV0Y2hPdmVycmlkZSwgfSA9IHBhcmFtcztcbiAgICByZXR1cm4gdXBkYXRlT2JqZWN0KHtcbiAgICAgICAgdXJsOiBjYWxlbmRhck9iamVjdC51cmwsXG4gICAgICAgIGRhdGE6IGNhbGVuZGFyT2JqZWN0LmRhdGEsXG4gICAgICAgIGV0YWc6IGNhbGVuZGFyT2JqZWN0LmV0YWcsXG4gICAgICAgIGhlYWRlcnM6IGV4Y2x1ZGVIZWFkZXJzKHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAndGV4dC9jYWxlbmRhcjsgY2hhcnNldD11dGYtOCcsXG4gICAgICAgICAgICAuLi5oZWFkZXJzLFxuICAgICAgICB9LCBoZWFkZXJzVG9FeGNsdWRlKSxcbiAgICAgICAgZmV0Y2hPcHRpb25zLFxuICAgICAgICBmZXRjaDogZmV0Y2hPdmVycmlkZSxcbiAgICB9KTtcbn07XG5jb25zdCBkZWxldGVDYWxlbmRhck9iamVjdCA9IGFzeW5jIChwYXJhbXMpID0+IHtcbiAgICBjb25zdCB7IGNhbGVuZGFyT2JqZWN0LCBoZWFkZXJzLCBoZWFkZXJzVG9FeGNsdWRlLCBmZXRjaE9wdGlvbnMgPSB7fSwgZmV0Y2g6IGZldGNoT3ZlcnJpZGUsIH0gPSBwYXJhbXM7XG4gICAgcmV0dXJuIGRlbGV0ZU9iamVjdCh7XG4gICAgICAgIHVybDogY2FsZW5kYXJPYmplY3QudXJsLFxuICAgICAgICBldGFnOiBjYWxlbmRhck9iamVjdC5ldGFnLFxuICAgICAgICBoZWFkZXJzOiBleGNsdWRlSGVhZGVycyhoZWFkZXJzLCBoZWFkZXJzVG9FeGNsdWRlKSxcbiAgICAgICAgZmV0Y2hPcHRpb25zLFxuICAgICAgICBmZXRjaDogZmV0Y2hPdmVycmlkZSxcbiAgICB9KTtcbn07XG4vKipcbiAqIFN5bmMgcmVtb3RlIGNhbGVuZGFycyB0byBsb2NhbFxuICovXG5jb25zdCBzeW5jQ2FsZW5kYXJzID0gYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB7IG9sZENhbGVuZGFycywgYWNjb3VudCwgZGV0YWlsZWRSZXN1bHQsIGhlYWRlcnMsIGhlYWRlcnNUb0V4Y2x1ZGUsIGZldGNoT3B0aW9ucyA9IHt9LCBmZXRjaDogZmV0Y2hPdmVycmlkZSwgfSA9IHBhcmFtcztcbiAgICBpZiAoIWFjY291bnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IGhhdmUgYWNjb3VudCBiZWZvcmUgc3luY0NhbGVuZGFycycpO1xuICAgIH1cbiAgICBjb25zdCBsb2NhbENhbGVuZGFycyA9IChfYSA9IG9sZENhbGVuZGFycyAhPT0gbnVsbCAmJiBvbGRDYWxlbmRhcnMgIT09IHZvaWQgMCA/IG9sZENhbGVuZGFycyA6IGFjY291bnQuY2FsZW5kYXJzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXTtcbiAgICBjb25zdCByZW1vdGVDYWxlbmRhcnMgPSBhd2FpdCBmZXRjaENhbGVuZGFycyh7XG4gICAgICAgIGFjY291bnQsXG4gICAgICAgIGhlYWRlcnM6IGV4Y2x1ZGVIZWFkZXJzKGhlYWRlcnMsIGhlYWRlcnNUb0V4Y2x1ZGUpLFxuICAgICAgICBmZXRjaE9wdGlvbnMsXG4gICAgICAgIGZldGNoOiBmZXRjaE92ZXJyaWRlLFxuICAgIH0pO1xuICAgIC8vIG5vIGV4aXN0aW5nIHVybFxuICAgIGNvbnN0IGNyZWF0ZWQgPSByZW1vdGVDYWxlbmRhcnMuZmlsdGVyKChyYykgPT4gbG9jYWxDYWxlbmRhcnMuZXZlcnkoKGxjKSA9PiAhdXJsQ29udGFpbnMobGMudXJsLCByYy51cmwpKSk7XG4gICAgZGVidWckMihgbmV3IGNhbGVuZGFyczogJHtjcmVhdGVkLm1hcCgoY2MpID0+IGNjLmRpc3BsYXlOYW1lKX1gKTtcbiAgICAvLyBoYXZlIHNhbWUgdXJsLCBidXQgc3luY1Rva2VuL2N0YWcgZGlmZmVyZW50XG4gICAgY29uc3QgdXBkYXRlZCA9IGxvY2FsQ2FsZW5kYXJzLnJlZHVjZSgocHJldiwgY3VycikgPT4ge1xuICAgICAgICBjb25zdCBmb3VuZCA9IHJlbW90ZUNhbGVuZGFycy5maW5kKChyYykgPT4gdXJsQ29udGFpbnMocmMudXJsLCBjdXJyLnVybCkpO1xuICAgICAgICBpZiAoZm91bmQgJiZcbiAgICAgICAgICAgICgoZm91bmQuc3luY1Rva2VuICYmIGAke2ZvdW5kLnN5bmNUb2tlbn1gICE9PSBgJHtjdXJyLnN5bmNUb2tlbn1gKSB8fFxuICAgICAgICAgICAgICAgIChmb3VuZC5jdGFnICYmIGAke2ZvdW5kLmN0YWd9YCAhPT0gYCR7Y3Vyci5jdGFnfWApKSkge1xuICAgICAgICAgICAgcmV0dXJuIFsuLi5wcmV2LCBmb3VuZF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgfSwgW10pO1xuICAgIGRlYnVnJDIoYHVwZGF0ZWQgY2FsZW5kYXJzOiAke3VwZGF0ZWQubWFwKChjYykgPT4gY2MuZGlzcGxheU5hbWUpfWApO1xuICAgIGNvbnN0IHVwZGF0ZWRXaXRoT2JqZWN0cyA9IGF3YWl0IFByb21pc2UuYWxsKHVwZGF0ZWQubWFwKGFzeW5jICh1KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNtYXJ0Q29sbGVjdGlvblN5bmMoe1xuICAgICAgICAgICAgY29sbGVjdGlvbjogeyAuLi51LCBvYmplY3RNdWx0aUdldDogY2FsZW5kYXJNdWx0aUdldCB9LFxuICAgICAgICAgICAgbWV0aG9kOiAnd2ViZGF2JyxcbiAgICAgICAgICAgIGhlYWRlcnM6IGV4Y2x1ZGVIZWFkZXJzKGhlYWRlcnMsIGhlYWRlcnNUb0V4Y2x1ZGUpLFxuICAgICAgICAgICAgYWNjb3VudCxcbiAgICAgICAgICAgIGZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgIGZldGNoOiBmZXRjaE92ZXJyaWRlLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KSk7XG4gICAgLy8gZG9lcyBub3QgcHJlc2VudCBpbiByZW1vdGVcbiAgICBjb25zdCBkZWxldGVkID0gbG9jYWxDYWxlbmRhcnMuZmlsdGVyKChjYWwpID0+IHJlbW90ZUNhbGVuZGFycy5ldmVyeSgocmMpID0+ICF1cmxDb250YWlucyhyYy51cmwsIGNhbC51cmwpKSk7XG4gICAgZGVidWckMihgZGVsZXRlZCBjYWxlbmRhcnM6ICR7ZGVsZXRlZC5tYXAoKGNjKSA9PiBjYy5kaXNwbGF5TmFtZSl9YCk7XG4gICAgY29uc3QgdW5jaGFuZ2VkID0gbG9jYWxDYWxlbmRhcnMuZmlsdGVyKChjYWwpID0+IHJlbW90ZUNhbGVuZGFycy5zb21lKChyYykgPT4gdXJsQ29udGFpbnMocmMudXJsLCBjYWwudXJsKSAmJlxuICAgICAgICAoKHJjLnN5bmNUb2tlbiAmJiBgJHtyYy5zeW5jVG9rZW59YCAhPT0gYCR7Y2FsLnN5bmNUb2tlbn1gKSB8fFxuICAgICAgICAgICAgKHJjLmN0YWcgJiYgYCR7cmMuY3RhZ31gICE9PSBgJHtjYWwuY3RhZ31gKSkpKTtcbiAgICAvLyBkZWJ1ZyhgdW5jaGFuZ2VkIGNhbGVuZGFyczogJHt1bmNoYW5nZWQubWFwKChjYykgPT4gY2MuZGlzcGxheU5hbWUpfWApO1xuICAgIHJldHVybiBkZXRhaWxlZFJlc3VsdFxuICAgICAgICA/IHtcbiAgICAgICAgICAgIGNyZWF0ZWQsXG4gICAgICAgICAgICB1cGRhdGVkLFxuICAgICAgICAgICAgZGVsZXRlZCxcbiAgICAgICAgfVxuICAgICAgICA6IFsuLi51bmNoYW5nZWQsIC4uLmNyZWF0ZWQsIC4uLnVwZGF0ZWRXaXRoT2JqZWN0c107XG59O1xuY29uc3QgZnJlZUJ1c3lRdWVyeSA9IGFzeW5jIChwYXJhbXMpID0+IHtcbiAgICBjb25zdCB7IHVybCwgdGltZVJhbmdlLCBkZXB0aCwgaGVhZGVycywgaGVhZGVyc1RvRXhjbHVkZSwgZmV0Y2hPcHRpb25zID0ge30sIGZldGNoOiBmZXRjaE92ZXJyaWRlLCB9ID0gcGFyYW1zO1xuICAgIGlmICh0aW1lUmFuZ2UpIHtcbiAgICAgICAgLy8gdmFsaWRhdGUgdGltZVJhbmdlXG4gICAgICAgIGNvbnN0IElTT184NjAxID0gL15cXGR7NH0oLVxcZFxcZCgtXFxkXFxkKFRcXGRcXGQ6XFxkXFxkKDpcXGRcXGQpPyhcXC5cXGQrKT8oKFsrLV1cXGRcXGQ6XFxkXFxkKXxaKT8pPyk/KT8kL2k7XG4gICAgICAgIGNvbnN0IElTT184NjAxX0ZVTEwgPSAvXlxcZHs0fS1cXGRcXGQtXFxkXFxkVFxcZFxcZDpcXGRcXGQ6XFxkXFxkKFxcLlxcZCspPygoWystXVxcZFxcZDpcXGRcXGQpfFopPyQvaTtcbiAgICAgICAgaWYgKCghSVNPXzg2MDEudGVzdCh0aW1lUmFuZ2Uuc3RhcnQpIHx8ICFJU09fODYwMS50ZXN0KHRpbWVSYW5nZS5lbmQpKSAmJlxuICAgICAgICAgICAgKCFJU09fODYwMV9GVUxMLnRlc3QodGltZVJhbmdlLnN0YXJ0KSB8fCAhSVNPXzg2MDFfRlVMTC50ZXN0KHRpbWVSYW5nZS5lbmQpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHRpbWVSYW5nZSBmb3JtYXQsIG5vdCBpbiBJU084NjAxJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndGltZVJhbmdlIGlzIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvbGxlY3Rpb25RdWVyeSh7XG4gICAgICAgIHVybCxcbiAgICAgICAgYm9keToge1xuICAgICAgICAgICAgJ2ZyZWUtYnVzeS1xdWVyeSc6IGNsZWFudXBGYWxzeSh7XG4gICAgICAgICAgICAgICAgX2F0dHJpYnV0ZXM6IGdldERBVkF0dHJpYnV0ZShbREFWTmFtZXNwYWNlLkNBTERBVl0pLFxuICAgICAgICAgICAgICAgIFtgJHtEQVZOYW1lc3BhY2VTaG9ydC5DQUxEQVZ9OnRpbWUtcmFuZ2VgXToge1xuICAgICAgICAgICAgICAgICAgICBfYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGAke25ldyBEYXRlKHRpbWVSYW5nZS5zdGFydCkudG9JU09TdHJpbmcoKS5zbGljZSgwLCAxOSkucmVwbGFjZSgvWy06Ll0vZywgJycpfVpgLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBgJHtuZXcgRGF0ZSh0aW1lUmFuZ2UuZW5kKS50b0lTT1N0cmluZygpLnNsaWNlKDAsIDE5KS5yZXBsYWNlKC9bLTouXS9nLCAnJyl9WmAsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICB9LFxuICAgICAgICBkZWZhdWx0TmFtZXNwYWNlOiBEQVZOYW1lc3BhY2VTaG9ydC5DQUxEQVYsXG4gICAgICAgIGRlcHRoLFxuICAgICAgICBoZWFkZXJzOiBleGNsdWRlSGVhZGVycyhoZWFkZXJzLCBoZWFkZXJzVG9FeGNsdWRlKSxcbiAgICAgICAgZmV0Y2hPcHRpb25zLFxuICAgICAgICBmZXRjaDogZmV0Y2hPdmVycmlkZSxcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0WzBdO1xufTtcblxudmFyIGNhbGVuZGFyID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBjYWxlbmRhck11bHRpR2V0OiBjYWxlbmRhck11bHRpR2V0LFxuICAgIGNhbGVuZGFyUXVlcnk6IGNhbGVuZGFyUXVlcnksXG4gICAgY3JlYXRlQ2FsZW5kYXJPYmplY3Q6IGNyZWF0ZUNhbGVuZGFyT2JqZWN0LFxuICAgIGRlbGV0ZUNhbGVuZGFyT2JqZWN0OiBkZWxldGVDYWxlbmRhck9iamVjdCxcbiAgICBmZXRjaENhbGVuZGFyT2JqZWN0czogZmV0Y2hDYWxlbmRhck9iamVjdHMsXG4gICAgZmV0Y2hDYWxlbmRhclVzZXJBZGRyZXNzZXM6IGZldGNoQ2FsZW5kYXJVc2VyQWRkcmVzc2VzLFxuICAgIGZldGNoQ2FsZW5kYXJzOiBmZXRjaENhbGVuZGFycyxcbiAgICBmcmVlQnVzeVF1ZXJ5OiBmcmVlQnVzeVF1ZXJ5LFxuICAgIG1ha2VDYWxlbmRhcjogbWFrZUNhbGVuZGFyLFxuICAgIHN5bmNDYWxlbmRhcnM6IHN5bmNDYWxlbmRhcnMsXG4gICAgdXBkYXRlQ2FsZW5kYXJPYmplY3Q6IHVwZGF0ZUNhbGVuZGFyT2JqZWN0XG59KTtcblxuY29uc3QgZGVidWckMSA9IGdldExvZ2dlcigndHNkYXY6YWNjb3VudCcpO1xuY29uc3Qgc2VydmljZURpc2NvdmVyeSA9IGFzeW5jIChwYXJhbXMpID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGRlYnVnJDEoJ1NlcnZpY2UgZGlzY292ZXJ5Li4uJyk7XG4gICAgY29uc3QgeyBhY2NvdW50LCBoZWFkZXJzLCBoZWFkZXJzVG9FeGNsdWRlLCBmZXRjaE9wdGlvbnMgPSB7fSwgZmV0Y2g6IGZldGNoT3ZlcnJpZGUgfSA9IHBhcmFtcztcbiAgICBjb25zdCByZXF1ZXN0RmV0Y2ggPSBmZXRjaE92ZXJyaWRlICE9PSBudWxsICYmIGZldGNoT3ZlcnJpZGUgIT09IHZvaWQgMCA/IGZldGNoT3ZlcnJpZGUgOiBmZXRjaDtcbiAgICBjb25zdCBlbmRwb2ludCA9IG5ldyBVUkwoYWNjb3VudC5zZXJ2ZXJVcmwpO1xuICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwoYC8ud2VsbC1rbm93bi8ke2FjY291bnQuYWNjb3VudFR5cGV9YCwgZW5kcG9pbnQpO1xuICAgIHVyaS5wcm90b2NvbCA9IChfYSA9IGVuZHBvaW50LnByb3RvY29sKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnaHR0cCc7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0RmV0Y2godXJpLmhyZWYsIHtcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAuLi5leGNsdWRlSGVhZGVycyhoZWFkZXJzLCBoZWFkZXJzVG9FeGNsdWRlKSxcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ3RleHQveG1sO2NoYXJzZXQ9VVRGLTgnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1ldGhvZDogJ1BST1BGSU5EJyxcbiAgICAgICAgICAgIGJvZHk6IGA8P3htbCB2ZXJzaW9uPVwiMS4wXCIgZW5jb2Rpbmc9XCJ1dGYtOFwiID8+XG48ZDpwcm9wZmluZCB4bWxuczpkPVwiREFWOlwiPlxuICA8ZDpwcm9wPlxuICAgIDxkOnJlc291cmNldHlwZS8+XG4gIDwvZDpwcm9wPlxuPC9kOnByb3BmaW5kPmAsXG4gICAgICAgICAgICByZWRpcmVjdDogJ21hbnVhbCcsXG4gICAgICAgICAgICAuLi5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID49IDMwMCAmJiByZXNwb25zZS5zdGF0dXMgPCA0MDApIHtcbiAgICAgICAgICAgIC8vIGh0dHAgcmVkaXJlY3QuXG4gICAgICAgICAgICBjb25zdCBsb2NhdGlvbiA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdMb2NhdGlvbicpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBsb2NhdGlvbiA9PT0gJ3N0cmluZycgJiYgbG9jYXRpb24ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZGVidWckMShgU2VydmljZSBkaXNjb3ZlcnkgcmVkaXJlY3RlZCB0byAke2xvY2F0aW9ufWApO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlcnZpY2VVUkwgPSBuZXcgVVJMKGxvY2F0aW9uLCBlbmRwb2ludCk7XG4gICAgICAgICAgICAgICAgaWYgKHNlcnZpY2VVUkwuaG9zdG5hbWUgPT09IHVyaS5ob3N0bmFtZSAmJiB1cmkucG9ydCAmJiAhc2VydmljZVVSTC5wb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgIHNlcnZpY2VVUkwucG9ydCA9IHVyaS5wb3J0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXJ2aWNlVVJMLnByb3RvY29sID0gKF9iID0gZW5kcG9pbnQucHJvdG9jb2wpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICdodHRwJztcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VydmljZVVSTC5ocmVmO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgZGVidWckMShgU2VydmljZSBkaXNjb3ZlcnkgZmFpbGVkOiAke2Vyci5zdGFja31gKTtcbiAgICB9XG4gICAgcmV0dXJuIGVuZHBvaW50LmhyZWY7XG59O1xuY29uc3QgZmV0Y2hQcmluY2lwYWxVcmwgPSBhc3luYyAocGFyYW1zKSA9PiB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICBjb25zdCB7IGFjY291bnQsIGhlYWRlcnMsIGhlYWRlcnNUb0V4Y2x1ZGUsIGZldGNoT3B0aW9ucyA9IHt9LCBmZXRjaDogZmV0Y2hPdmVycmlkZSB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHJlcXVpcmVkRmllbGRzID0gWydyb290VXJsJ107XG4gICAgaWYgKCFoYXNGaWVsZHMoYWNjb3VudCwgcmVxdWlyZWRGaWVsZHMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgYWNjb3VudCBtdXN0IGhhdmUgJHtmaW5kTWlzc2luZ0ZpZWxkTmFtZXMoYWNjb3VudCwgcmVxdWlyZWRGaWVsZHMpfSBiZWZvcmUgZmV0Y2hQcmluY2lwYWxVcmxgKTtcbiAgICB9XG4gICAgZGVidWckMShgRmV0Y2hpbmcgcHJpbmNpcGFsIHVybCBmcm9tIHBhdGggJHthY2NvdW50LnJvb3RVcmx9YCk7XG4gICAgY29uc3QgW3Jlc3BvbnNlXSA9IGF3YWl0IHByb3BmaW5kKHtcbiAgICAgICAgdXJsOiBhY2NvdW50LnJvb3RVcmwsXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICBbYCR7REFWTmFtZXNwYWNlU2hvcnQuREFWfTpjdXJyZW50LXVzZXItcHJpbmNpcGFsYF06IHt9LFxuICAgICAgICB9LFxuICAgICAgICBkZXB0aDogJzAnLFxuICAgICAgICBoZWFkZXJzOiBleGNsdWRlSGVhZGVycyhoZWFkZXJzLCBoZWFkZXJzVG9FeGNsdWRlKSxcbiAgICAgICAgZmV0Y2hPcHRpb25zLFxuICAgICAgICBmZXRjaDogZmV0Y2hPdmVycmlkZSxcbiAgICB9KTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGRlYnVnJDEoYEZldGNoIHByaW5jaXBhbCB1cmwgZmFpbGVkOiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNyZWRlbnRpYWxzJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVidWckMShgRmV0Y2hlZCBwcmluY2lwYWwgdXJsICR7KF9iID0gKF9hID0gcmVzcG9uc2UucHJvcHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jdXJyZW50VXNlclByaW5jaXBhbCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmhyZWZ9YCk7XG4gICAgcmV0dXJuIG5ldyBVUkwoKF9lID0gKF9kID0gKF9jID0gcmVzcG9uc2UucHJvcHMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jdXJyZW50VXNlclByaW5jaXBhbCkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmhyZWYpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6ICcnLCBhY2NvdW50LnJvb3RVcmwpLmhyZWY7XG59O1xuY29uc3QgZmV0Y2hIb21lVXJsID0gYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgeyBhY2NvdW50LCBoZWFkZXJzLCBoZWFkZXJzVG9FeGNsdWRlLCBmZXRjaE9wdGlvbnMgPSB7fSwgZmV0Y2g6IGZldGNoT3ZlcnJpZGUgfSA9IHBhcmFtcztcbiAgICBjb25zdCByZXF1aXJlZEZpZWxkcyA9IFsncHJpbmNpcGFsVXJsJywgJ3Jvb3RVcmwnXTtcbiAgICBpZiAoIWhhc0ZpZWxkcyhhY2NvdW50LCByZXF1aXJlZEZpZWxkcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBhY2NvdW50IG11c3QgaGF2ZSAke2ZpbmRNaXNzaW5nRmllbGROYW1lcyhhY2NvdW50LCByZXF1aXJlZEZpZWxkcyl9IGJlZm9yZSBmZXRjaEhvbWVVcmxgKTtcbiAgICB9XG4gICAgZGVidWckMShgRmV0Y2ggaG9tZSB1cmwgZnJvbSAke2FjY291bnQucHJpbmNpcGFsVXJsfWApO1xuICAgIGNvbnN0IHJlc3BvbnNlcyA9IGF3YWl0IHByb3BmaW5kKHtcbiAgICAgICAgdXJsOiBhY2NvdW50LnByaW5jaXBhbFVybCxcbiAgICAgICAgcHJvcHM6IGFjY291bnQuYWNjb3VudFR5cGUgPT09ICdjYWxkYXYnXG4gICAgICAgICAgICA/IHsgW2Ake0RBVk5hbWVzcGFjZVNob3J0LkNBTERBVn06Y2FsZW5kYXItaG9tZS1zZXRgXToge30gfVxuICAgICAgICAgICAgOiB7IFtgJHtEQVZOYW1lc3BhY2VTaG9ydC5DQVJEREFWfTphZGRyZXNzYm9vay1ob21lLXNldGBdOiB7fSB9LFxuICAgICAgICBkZXB0aDogJzAnLFxuICAgICAgICBoZWFkZXJzOiBleGNsdWRlSGVhZGVycyhoZWFkZXJzLCBoZWFkZXJzVG9FeGNsdWRlKSxcbiAgICAgICAgZmV0Y2hPcHRpb25zLFxuICAgICAgICBmZXRjaDogZmV0Y2hPdmVycmlkZSxcbiAgICB9KTtcbiAgICBjb25zdCBtYXRjaGVkID0gcmVzcG9uc2VzLmZpbmQoKHIpID0+IHVybENvbnRhaW5zKGFjY291bnQucHJpbmNpcGFsVXJsLCByLmhyZWYpKTtcbiAgICBpZiAoIW1hdGNoZWQgfHwgIW1hdGNoZWQub2spIHtcbiAgICAgICAgZGVidWckMShgRmV0Y2ggaG9tZSB1cmwgZmFpbGVkIHdpdGggc3RhdHVzICR7bWF0Y2hlZCA9PT0gbnVsbCB8fCBtYXRjaGVkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXRjaGVkLnN0YXR1c1RleHR9IGFuZCBlcnJvciAke0pTT04uc3RyaW5naWZ5KHJlc3BvbnNlcy5tYXAoKHIpID0+IHIuZXJyb3IpKX1gKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgZmluZCBob21lVXJsJyk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVUkwoYWNjb3VudC5hY2NvdW50VHlwZSA9PT0gJ2NhbGRhdidcbiAgICAgICAgPyAoX2EgPSBtYXRjaGVkID09PSBudWxsIHx8IG1hdGNoZWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hdGNoZWQucHJvcHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxlbmRhckhvbWVTZXQuaHJlZlxuICAgICAgICA6IChfYiA9IG1hdGNoZWQgPT09IG51bGwgfHwgbWF0Y2hlZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWF0Y2hlZC5wcm9wcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFkZHJlc3Nib29rSG9tZVNldC5ocmVmLCBhY2NvdW50LnJvb3RVcmwpLmhyZWY7XG4gICAgZGVidWckMShgRmV0Y2hlZCBob21lIHVybCAke3Jlc3VsdH1gKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbmNvbnN0IGNyZWF0ZUFjY291bnQgPSBhc3luYyAocGFyYW1zKSA9PiB7XG4gICAgY29uc3QgeyBhY2NvdW50LCBoZWFkZXJzLCBsb2FkQ29sbGVjdGlvbnMgPSBmYWxzZSwgbG9hZE9iamVjdHMgPSBmYWxzZSwgaGVhZGVyc1RvRXhjbHVkZSwgZmV0Y2hPcHRpb25zID0ge30sIGZldGNoOiBmZXRjaE92ZXJyaWRlLCB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IG5ld0FjY291bnQgPSB7IC4uLmFjY291bnQgfTtcbiAgICBuZXdBY2NvdW50LnJvb3RVcmwgPSBhd2FpdCBzZXJ2aWNlRGlzY292ZXJ5KHtcbiAgICAgICAgYWNjb3VudCxcbiAgICAgICAgaGVhZGVyczogZXhjbHVkZUhlYWRlcnMoaGVhZGVycywgaGVhZGVyc1RvRXhjbHVkZSksXG4gICAgICAgIGZldGNoT3B0aW9ucyxcbiAgICAgICAgZmV0Y2g6IGZldGNoT3ZlcnJpZGUsXG4gICAgfSk7XG4gICAgbmV3QWNjb3VudC5wcmluY2lwYWxVcmwgPSBhd2FpdCBmZXRjaFByaW5jaXBhbFVybCh7XG4gICAgICAgIGFjY291bnQ6IG5ld0FjY291bnQsXG4gICAgICAgIGhlYWRlcnM6IGV4Y2x1ZGVIZWFkZXJzKGhlYWRlcnMsIGhlYWRlcnNUb0V4Y2x1ZGUpLFxuICAgICAgICBmZXRjaE9wdGlvbnMsXG4gICAgICAgIGZldGNoOiBmZXRjaE92ZXJyaWRlLFxuICAgIH0pO1xuICAgIG5ld0FjY291bnQuaG9tZVVybCA9IGF3YWl0IGZldGNoSG9tZVVybCh7XG4gICAgICAgIGFjY291bnQ6IG5ld0FjY291bnQsXG4gICAgICAgIGhlYWRlcnM6IGV4Y2x1ZGVIZWFkZXJzKGhlYWRlcnMsIGhlYWRlcnNUb0V4Y2x1ZGUpLFxuICAgICAgICBmZXRjaE9wdGlvbnMsXG4gICAgICAgIGZldGNoOiBmZXRjaE92ZXJyaWRlLFxuICAgIH0pO1xuICAgIC8vIHRvIGxvYWQgb2JqZWN0cyB5b3UgbXVzdCBmaXJzdCBsb2FkIGNvbGxlY3Rpb25zXG4gICAgaWYgKGxvYWRDb2xsZWN0aW9ucyB8fCBsb2FkT2JqZWN0cykge1xuICAgICAgICBpZiAoYWNjb3VudC5hY2NvdW50VHlwZSA9PT0gJ2NhbGRhdicpIHtcbiAgICAgICAgICAgIG5ld0FjY291bnQuY2FsZW5kYXJzID0gYXdhaXQgZmV0Y2hDYWxlbmRhcnMoe1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGV4Y2x1ZGVIZWFkZXJzKGhlYWRlcnMsIGhlYWRlcnNUb0V4Y2x1ZGUpLFxuICAgICAgICAgICAgICAgIGFjY291bnQ6IG5ld0FjY291bnQsXG4gICAgICAgICAgICAgICAgZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgICAgIGZldGNoOiBmZXRjaE92ZXJyaWRlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYWNjb3VudC5hY2NvdW50VHlwZSA9PT0gJ2NhcmRkYXYnKSB7XG4gICAgICAgICAgICBuZXdBY2NvdW50LmFkZHJlc3NCb29rcyA9IGF3YWl0IGZldGNoQWRkcmVzc0Jvb2tzKHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBleGNsdWRlSGVhZGVycyhoZWFkZXJzLCBoZWFkZXJzVG9FeGNsdWRlKSxcbiAgICAgICAgICAgICAgICBhY2NvdW50OiBuZXdBY2NvdW50LFxuICAgICAgICAgICAgICAgIGZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBmZXRjaDogZmV0Y2hPdmVycmlkZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChsb2FkT2JqZWN0cykge1xuICAgICAgICBpZiAoYWNjb3VudC5hY2NvdW50VHlwZSA9PT0gJ2NhbGRhdicgJiYgbmV3QWNjb3VudC5jYWxlbmRhcnMpIHtcbiAgICAgICAgICAgIG5ld0FjY291bnQuY2FsZW5kYXJzID0gYXdhaXQgUHJvbWlzZS5hbGwobmV3QWNjb3VudC5jYWxlbmRhcnMubWFwKGFzeW5jIChjYWwpID0+ICh7XG4gICAgICAgICAgICAgICAgLi4uY2FsLFxuICAgICAgICAgICAgICAgIG9iamVjdHM6IGF3YWl0IGZldGNoQ2FsZW5kYXJPYmplY3RzKHtcbiAgICAgICAgICAgICAgICAgICAgY2FsZW5kYXI6IGNhbCxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogZXhjbHVkZUhlYWRlcnMoaGVhZGVycywgaGVhZGVyc1RvRXhjbHVkZSksXG4gICAgICAgICAgICAgICAgICAgIGZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgZmV0Y2g6IGZldGNoT3ZlcnJpZGUsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9KSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFjY291bnQuYWNjb3VudFR5cGUgPT09ICdjYXJkZGF2JyAmJiBuZXdBY2NvdW50LmFkZHJlc3NCb29rcykge1xuICAgICAgICAgICAgbmV3QWNjb3VudC5hZGRyZXNzQm9va3MgPSBhd2FpdCBQcm9taXNlLmFsbChuZXdBY2NvdW50LmFkZHJlc3NCb29rcy5tYXAoYXN5bmMgKGFkZHIpID0+ICh7XG4gICAgICAgICAgICAgICAgLi4uYWRkcixcbiAgICAgICAgICAgICAgICBvYmplY3RzOiBhd2FpdCBmZXRjaFZDYXJkcyh7XG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3NCb29rOiBhZGRyLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBleGNsdWRlSGVhZGVycyhoZWFkZXJzLCBoZWFkZXJzVG9FeGNsdWRlKSxcbiAgICAgICAgICAgICAgICAgICAgZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICBmZXRjaDogZmV0Y2hPdmVycmlkZSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ld0FjY291bnQ7XG59O1xuXG52YXIgYWNjb3VudCA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgY3JlYXRlQWNjb3VudDogY3JlYXRlQWNjb3VudCxcbiAgICBmZXRjaEhvbWVVcmw6IGZldGNoSG9tZVVybCxcbiAgICBmZXRjaFByaW5jaXBhbFVybDogZmV0Y2hQcmluY2lwYWxVcmwsXG4gICAgc2VydmljZURpc2NvdmVyeTogc2VydmljZURpc2NvdmVyeVxufSk7XG5cbmNvbnN0IGRlYnVnID0gZ2V0TG9nZ2VyKCd0c2RhdjphdXRoSGVscGVyJyk7XG4vKipcbiAqIFByb3ZpZGUgZ2l2ZW4gcGFyYW1zIGFzIGRlZmF1bHQgcGFyYW1zIHRvIGdpdmVuIGZ1bmN0aW9uIHdpdGggb3B0aW9uYWwgcGFyYW1zLlxuICpcbiAqIHN1aXRhYmxlIG9ubHkgZm9yIG9uZSBwYXJhbSBmdW5jdGlvbnNcbiAqIHBhcmFtcyBhcmUgc2hhbGxvdyBtZXJnZWRcbiAqL1xuY29uc3QgZGVmYXVsdFBhcmFtID0gKGZuLCBwYXJhbXMpID0+ICguLi5hcmdzKSA9PiB7XG4gICAgcmV0dXJuIGZuKHsgLi4ucGFyYW1zLCAuLi5hcmdzWzBdIH0pO1xufTtcbmNvbnN0IGdldEJhc2ljQXV0aEhlYWRlcnMgPSAoY3JlZGVudGlhbHMpID0+IHtcbiAgICBkZWJ1ZyhgQmFzaWMgYXV0aCB0b2tlbiBnZW5lcmF0ZWQ6ICR7ZW5jb2RlKGAke2NyZWRlbnRpYWxzLnVzZXJuYW1lfToke2NyZWRlbnRpYWxzLnBhc3N3b3JkfWApfWApO1xuICAgIHJldHVybiB7XG4gICAgICAgIGF1dGhvcml6YXRpb246IGBCYXNpYyAke2VuY29kZShgJHtjcmVkZW50aWFscy51c2VybmFtZX06JHtjcmVkZW50aWFscy5wYXNzd29yZH1gKX1gLFxuICAgIH07XG59O1xuY29uc3QgZ2V0QmVhcmVyQXV0aEhlYWRlcnMgPSAoY3JlZGVudGlhbHMpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgICBhdXRob3JpemF0aW9uOiBgQmVhcmVyICR7Y3JlZGVudGlhbHMuYWNjZXNzVG9rZW59YCxcbiAgICB9O1xufTtcbmNvbnN0IGZldGNoT2F1dGhUb2tlbnMgPSBhc3luYyAoY3JlZGVudGlhbHMsIGZldGNoT3B0aW9ucywgZmV0Y2hPdmVycmlkZSkgPT4ge1xuICAgIGNvbnN0IHJlcXVpcmVGaWVsZHMgPSBbXG4gICAgICAgICdhdXRob3JpemF0aW9uQ29kZScsXG4gICAgICAgICdyZWRpcmVjdFVybCcsXG4gICAgICAgICdjbGllbnRJZCcsXG4gICAgICAgICdjbGllbnRTZWNyZXQnLFxuICAgICAgICAndG9rZW5VcmwnLFxuICAgIF07XG4gICAgaWYgKCFoYXNGaWVsZHMoY3JlZGVudGlhbHMsIHJlcXVpcmVGaWVsZHMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgT2F1dGggY3JlZGVudGlhbHMgbWlzc2luZzogJHtmaW5kTWlzc2luZ0ZpZWxkTmFtZXMoY3JlZGVudGlhbHMsIHJlcXVpcmVGaWVsZHMpfWApO1xuICAgIH1cbiAgICBjb25zdCBwYXJhbSA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgICAgICBncmFudF90eXBlOiAnYXV0aG9yaXphdGlvbl9jb2RlJyxcbiAgICAgICAgY29kZTogY3JlZGVudGlhbHMuYXV0aG9yaXphdGlvbkNvZGUsXG4gICAgICAgIHJlZGlyZWN0X3VyaTogY3JlZGVudGlhbHMucmVkaXJlY3RVcmwsXG4gICAgICAgIGNsaWVudF9pZDogY3JlZGVudGlhbHMuY2xpZW50SWQsXG4gICAgICAgIGNsaWVudF9zZWNyZXQ6IGNyZWRlbnRpYWxzLmNsaWVudFNlY3JldCxcbiAgICB9KTtcbiAgICBkZWJ1ZyhjcmVkZW50aWFscy50b2tlblVybCk7XG4gICAgZGVidWcocGFyYW0udG9TdHJpbmcoKSk7XG4gICAgY29uc3QgcmVxdWVzdEZldGNoID0gZmV0Y2hPdmVycmlkZSAhPT0gbnVsbCAmJiBmZXRjaE92ZXJyaWRlICE9PSB2b2lkIDAgPyBmZXRjaE92ZXJyaWRlIDogZmV0Y2g7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0RmV0Y2goY3JlZGVudGlhbHMudG9rZW5VcmwsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGJvZHk6IHBhcmFtLnRvU3RyaW5nKCksXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICdjb250ZW50LWxlbmd0aCc6IGAke3BhcmFtLnRvU3RyaW5nKCkubGVuZ3RofWAsXG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICAgICAgIH0sXG4gICAgICAgIC4uLihmZXRjaE9wdGlvbnMgIT09IG51bGwgJiYgZmV0Y2hPcHRpb25zICE9PSB2b2lkIDAgPyBmZXRjaE9wdGlvbnMgOiB7fSksXG4gICAgfSk7XG4gICAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IHRva2VucyA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9XG4gICAgZGVidWcoYEZldGNoIE9hdXRoIHRva2VucyBmYWlsZWQ6ICR7YXdhaXQgcmVzcG9uc2UudGV4dCgpfWApO1xuICAgIHJldHVybiB7fTtcbn07XG5jb25zdCByZWZyZXNoQWNjZXNzVG9rZW4gPSBhc3luYyAoY3JlZGVudGlhbHMsIGZldGNoT3B0aW9ucywgZmV0Y2hPdmVycmlkZSkgPT4ge1xuICAgIGNvbnN0IHJlcXVpcmVGaWVsZHMgPSBbXG4gICAgICAgICdyZWZyZXNoVG9rZW4nLFxuICAgICAgICAnY2xpZW50SWQnLFxuICAgICAgICAnY2xpZW50U2VjcmV0JyxcbiAgICAgICAgJ3Rva2VuVXJsJyxcbiAgICBdO1xuICAgIGlmICghaGFzRmllbGRzKGNyZWRlbnRpYWxzLCByZXF1aXJlRmllbGRzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE9hdXRoIGNyZWRlbnRpYWxzIG1pc3Npbmc6ICR7ZmluZE1pc3NpbmdGaWVsZE5hbWVzKGNyZWRlbnRpYWxzLCByZXF1aXJlRmllbGRzKX1gKTtcbiAgICB9XG4gICAgY29uc3QgcGFyYW0gPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgY2xpZW50X2lkOiBjcmVkZW50aWFscy5jbGllbnRJZCxcbiAgICAgICAgY2xpZW50X3NlY3JldDogY3JlZGVudGlhbHMuY2xpZW50U2VjcmV0LFxuICAgICAgICByZWZyZXNoX3Rva2VuOiBjcmVkZW50aWFscy5yZWZyZXNoVG9rZW4sXG4gICAgICAgIGdyYW50X3R5cGU6ICdyZWZyZXNoX3Rva2VuJyxcbiAgICB9KTtcbiAgICBjb25zdCByZXF1ZXN0RmV0Y2ggPSBmZXRjaE92ZXJyaWRlICE9PSBudWxsICYmIGZldGNoT3ZlcnJpZGUgIT09IHZvaWQgMCA/IGZldGNoT3ZlcnJpZGUgOiBmZXRjaDtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3RGZXRjaChjcmVkZW50aWFscy50b2tlblVybCwge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgYm9keTogcGFyYW0udG9TdHJpbmcoKSxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAgICAgICB9LFxuICAgICAgICAuLi4oZmV0Y2hPcHRpb25zICE9PSBudWxsICYmIGZldGNoT3B0aW9ucyAhPT0gdm9pZCAwID8gZmV0Y2hPcHRpb25zIDoge30pLFxuICAgIH0pO1xuICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCB0b2tlbnMgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfVxuICAgIGRlYnVnKGBSZWZyZXNoIGFjY2VzcyB0b2tlbiBmYWlsZWQ6ICR7YXdhaXQgcmVzcG9uc2UudGV4dCgpfWApO1xuICAgIHJldHVybiB7fTtcbn07XG5jb25zdCBnZXRPYXV0aEhlYWRlcnMgPSBhc3luYyAoY3JlZGVudGlhbHMsIGZldGNoT3B0aW9ucywgZmV0Y2hPdmVycmlkZSkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBkZWJ1ZygnRmV0Y2hpbmcgb2F1dGggaGVhZGVycycpO1xuICAgIGxldCB0b2tlbnMgPSB7fTtcbiAgICBpZiAoIWNyZWRlbnRpYWxzLnJlZnJlc2hUb2tlbikge1xuICAgICAgICAvLyBObyByZWZyZXNoIHRva2VuLCBmZXRjaCBuZXcgdG9rZW5zXG4gICAgICAgIHRva2VucyA9IGF3YWl0IGZldGNoT2F1dGhUb2tlbnMoY3JlZGVudGlhbHMsIGZldGNoT3B0aW9ucywgZmV0Y2hPdmVycmlkZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKChjcmVkZW50aWFscy5yZWZyZXNoVG9rZW4gJiYgIWNyZWRlbnRpYWxzLmFjY2Vzc1Rva2VuKSB8fFxuICAgICAgICBEYXRlLm5vdygpID4gKChfYSA9IGNyZWRlbnRpYWxzLmV4cGlyYXRpb24pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDApKSB7XG4gICAgICAgIC8vIGhhdmUgcmVmcmVzaCB0b2tlbiwgYnV0IG5vIGFjY2Vzc1Rva2VuLCBmZXRjaCBhY2Nlc3MgdG9rZW4gb25seVxuICAgICAgICAvLyBvciBoYXZlIGJvdGgsIGJ1dCBhY2Nlc3NUb2tlbiB3YXMgZXhwaXJlZFxuICAgICAgICB0b2tlbnMgPSBhd2FpdCByZWZyZXNoQWNjZXNzVG9rZW4oY3JlZGVudGlhbHMsIGZldGNoT3B0aW9ucywgZmV0Y2hPdmVycmlkZSk7XG4gICAgfVxuICAgIC8vIG5vdyB3ZSBzaG91bGQgaGF2ZSB2YWxpZCBhY2Nlc3MgdG9rZW5cbiAgICBkZWJ1ZyhgT2F1dGggdG9rZW5zIGZldGNoZWQ6ICR7dG9rZW5zLmFjY2Vzc190b2tlbn1gKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0b2tlbnMsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIGF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0b2tlbnMuYWNjZXNzX3Rva2VufWAsXG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5cbnZhciBhdXRoSGVscGVycyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgZGVmYXVsdFBhcmFtOiBkZWZhdWx0UGFyYW0sXG4gICAgZmV0Y2hPYXV0aFRva2VuczogZmV0Y2hPYXV0aFRva2VucyxcbiAgICBnZXRCYXNpY0F1dGhIZWFkZXJzOiBnZXRCYXNpY0F1dGhIZWFkZXJzLFxuICAgIGdldEJlYXJlckF1dGhIZWFkZXJzOiBnZXRCZWFyZXJBdXRoSGVhZGVycyxcbiAgICBnZXRPYXV0aEhlYWRlcnM6IGdldE9hdXRoSGVhZGVycyxcbiAgICByZWZyZXNoQWNjZXNzVG9rZW46IHJlZnJlc2hBY2Nlc3NUb2tlblxufSk7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvZXhwbGljaXQtbW9kdWxlLWJvdW5kYXJ5LXR5cGVzXG5jb25zdCBjcmVhdGVEQVZDbGllbnQgPSBhc3luYyAocGFyYW1zKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHsgc2VydmVyVXJsLCBjcmVkZW50aWFscywgYXV0aE1ldGhvZCwgZGVmYXVsdEFjY291bnRUeXBlLCBhdXRoRnVuY3Rpb24sIGZldGNoOiBmZXRjaE92ZXJyaWRlLCB9ID0gcGFyYW1zO1xuICAgIGxldCBhdXRoSGVhZGVycyA9IHt9O1xuICAgIHN3aXRjaCAoYXV0aE1ldGhvZCkge1xuICAgICAgICBjYXNlICdCYXNpYyc6XG4gICAgICAgICAgICBhdXRoSGVhZGVycyA9IGdldEJhc2ljQXV0aEhlYWRlcnMoY3JlZGVudGlhbHMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0JlYXJlcic6XG4gICAgICAgICAgICBhdXRoSGVhZGVycyA9IGdldEJlYXJlckF1dGhIZWFkZXJzKGNyZWRlbnRpYWxzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdPYXV0aCc6XG4gICAgICAgICAgICBhdXRoSGVhZGVycyA9IChhd2FpdCBnZXRPYXV0aEhlYWRlcnMoY3JlZGVudGlhbHMsIHVuZGVmaW5lZCwgZmV0Y2hPdmVycmlkZSkpLmhlYWRlcnM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnRGlnZXN0JzpcbiAgICAgICAgICAgIGF1dGhIZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgIEF1dGhvcml6YXRpb246IGBEaWdlc3QgJHtjcmVkZW50aWFscy5kaWdlc3RTdHJpbmd9YCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnQ3VzdG9tJzpcbiAgICAgICAgICAgIGF1dGhIZWFkZXJzID0gKF9hID0gKGF3YWl0IChhdXRoRnVuY3Rpb24gPT09IG51bGwgfHwgYXV0aEZ1bmN0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhdXRoRnVuY3Rpb24oY3JlZGVudGlhbHMpKSkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXV0aCBtZXRob2QnKTtcbiAgICB9XG4gICAgY29uc3QgZGVmYXVsdEFjY291bnQgPSBkZWZhdWx0QWNjb3VudFR5cGVcbiAgICAgICAgPyBhd2FpdCBjcmVhdGVBY2NvdW50KHtcbiAgICAgICAgICAgIGFjY291bnQ6IHsgc2VydmVyVXJsLCBjcmVkZW50aWFscywgYWNjb3VudFR5cGU6IGRlZmF1bHRBY2NvdW50VHlwZSB9LFxuICAgICAgICAgICAgaGVhZGVyczogYXV0aEhlYWRlcnMsXG4gICAgICAgICAgICBmZXRjaDogZmV0Y2hPdmVycmlkZSxcbiAgICAgICAgfSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgZGF2UmVxdWVzdCQxID0gYXN5bmMgKHBhcmFtczApID0+IHtcbiAgICAgICAgY29uc3QgeyBpbml0LCBmZXRjaDogZmV0Y2hPdmVycmlkZTIsIC4uLnJlc3QgfSA9IHBhcmFtczA7XG4gICAgICAgIGNvbnN0IHsgaGVhZGVycywgLi4ucmVzdEluaXQgfSA9IGluaXQ7XG4gICAgICAgIHJldHVybiBkYXZSZXF1ZXN0KHtcbiAgICAgICAgICAgIC4uLnJlc3QsXG4gICAgICAgICAgICBpbml0OiB7XG4gICAgICAgICAgICAgICAgLi4ucmVzdEluaXQsXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAuLi5hdXRoSGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgLi4uaGVhZGVycyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZldGNoOiBmZXRjaE92ZXJyaWRlMiAhPT0gbnVsbCAmJiBmZXRjaE92ZXJyaWRlMiAhPT0gdm9pZCAwID8gZmV0Y2hPdmVycmlkZTIgOiBmZXRjaE92ZXJyaWRlLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGNyZWF0ZU9iamVjdCQxID0gZGVmYXVsdFBhcmFtKGNyZWF0ZU9iamVjdCwge1xuICAgICAgICB1cmw6IHNlcnZlclVybCxcbiAgICAgICAgaGVhZGVyczogYXV0aEhlYWRlcnMsXG4gICAgICAgIGZldGNoOiBmZXRjaE92ZXJyaWRlLFxuICAgIH0pO1xuICAgIGNvbnN0IHVwZGF0ZU9iamVjdCQxID0gZGVmYXVsdFBhcmFtKHVwZGF0ZU9iamVjdCwge1xuICAgICAgICBoZWFkZXJzOiBhdXRoSGVhZGVycyxcbiAgICAgICAgdXJsOiBzZXJ2ZXJVcmwsXG4gICAgICAgIGZldGNoOiBmZXRjaE92ZXJyaWRlLFxuICAgIH0pO1xuICAgIGNvbnN0IGRlbGV0ZU9iamVjdCQxID0gZGVmYXVsdFBhcmFtKGRlbGV0ZU9iamVjdCwge1xuICAgICAgICBoZWFkZXJzOiBhdXRoSGVhZGVycyxcbiAgICAgICAgdXJsOiBzZXJ2ZXJVcmwsXG4gICAgICAgIGZldGNoOiBmZXRjaE92ZXJyaWRlLFxuICAgIH0pO1xuICAgIGNvbnN0IHByb3BmaW5kJDEgPSBkZWZhdWx0UGFyYW0ocHJvcGZpbmQsIHsgaGVhZGVyczogYXV0aEhlYWRlcnMsIGZldGNoOiBmZXRjaE92ZXJyaWRlIH0pO1xuICAgIC8vIGFjY291bnRcbiAgICBjb25zdCBjcmVhdGVBY2NvdW50JDEgPSBhc3luYyAocGFyYW1zMCkgPT4ge1xuICAgICAgICBjb25zdCB7IGFjY291bnQsIGhlYWRlcnMsIGxvYWRDb2xsZWN0aW9ucywgbG9hZE9iamVjdHMsIGZldGNoOiBmZXRjaE92ZXJyaWRlMiB9ID0gcGFyYW1zMDtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUFjY291bnQoe1xuICAgICAgICAgICAgYWNjb3VudDogeyBzZXJ2ZXJVcmwsIGNyZWRlbnRpYWxzLCAuLi5hY2NvdW50IH0sXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLmF1dGhIZWFkZXJzLCAuLi5oZWFkZXJzIH0sXG4gICAgICAgICAgICBsb2FkQ29sbGVjdGlvbnMsXG4gICAgICAgICAgICBsb2FkT2JqZWN0cyxcbiAgICAgICAgICAgIGZldGNoOiBmZXRjaE92ZXJyaWRlMiAhPT0gbnVsbCAmJiBmZXRjaE92ZXJyaWRlMiAhPT0gdm9pZCAwID8gZmV0Y2hPdmVycmlkZTIgOiBmZXRjaE92ZXJyaWRlLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIGNvbGxlY3Rpb25cbiAgICBjb25zdCBjb2xsZWN0aW9uUXVlcnkkMSA9IGRlZmF1bHRQYXJhbShjb2xsZWN0aW9uUXVlcnksIHtcbiAgICAgICAgaGVhZGVyczogYXV0aEhlYWRlcnMsXG4gICAgICAgIGZldGNoOiBmZXRjaE92ZXJyaWRlLFxuICAgIH0pO1xuICAgIGNvbnN0IG1ha2VDb2xsZWN0aW9uJDEgPSBkZWZhdWx0UGFyYW0obWFrZUNvbGxlY3Rpb24sIHtcbiAgICAgICAgaGVhZGVyczogYXV0aEhlYWRlcnMsXG4gICAgICAgIGZldGNoOiBmZXRjaE92ZXJyaWRlLFxuICAgIH0pO1xuICAgIGNvbnN0IHN5bmNDb2xsZWN0aW9uJDEgPSBkZWZhdWx0UGFyYW0oc3luY0NvbGxlY3Rpb24sIHtcbiAgICAgICAgaGVhZGVyczogYXV0aEhlYWRlcnMsXG4gICAgICAgIGZldGNoOiBmZXRjaE92ZXJyaWRlLFxuICAgIH0pO1xuICAgIGNvbnN0IHN1cHBvcnRlZFJlcG9ydFNldCQxID0gZGVmYXVsdFBhcmFtKHN1cHBvcnRlZFJlcG9ydFNldCwge1xuICAgICAgICBoZWFkZXJzOiBhdXRoSGVhZGVycyxcbiAgICAgICAgZmV0Y2g6IGZldGNoT3ZlcnJpZGUsXG4gICAgfSk7XG4gICAgY29uc3QgaXNDb2xsZWN0aW9uRGlydHkkMSA9IGRlZmF1bHRQYXJhbShpc0NvbGxlY3Rpb25EaXJ0eSwge1xuICAgICAgICBoZWFkZXJzOiBhdXRoSGVhZGVycyxcbiAgICAgICAgZmV0Y2g6IGZldGNoT3ZlcnJpZGUsXG4gICAgfSk7XG4gICAgY29uc3Qgc21hcnRDb2xsZWN0aW9uU3luYyQxID0gZGVmYXVsdFBhcmFtKHNtYXJ0Q29sbGVjdGlvblN5bmMsIHtcbiAgICAgICAgaGVhZGVyczogYXV0aEhlYWRlcnMsXG4gICAgICAgIGFjY291bnQ6IGRlZmF1bHRBY2NvdW50LFxuICAgICAgICBmZXRjaDogZmV0Y2hPdmVycmlkZSxcbiAgICB9KTtcbiAgICAvLyBjYWxlbmRhclxuICAgIGNvbnN0IGNhbGVuZGFyUXVlcnkkMSA9IGRlZmF1bHRQYXJhbShjYWxlbmRhclF1ZXJ5LCB7XG4gICAgICAgIGhlYWRlcnM6IGF1dGhIZWFkZXJzLFxuICAgICAgICBmZXRjaDogZmV0Y2hPdmVycmlkZSxcbiAgICB9KTtcbiAgICBjb25zdCBjYWxlbmRhck11bHRpR2V0JDEgPSBkZWZhdWx0UGFyYW0oY2FsZW5kYXJNdWx0aUdldCwge1xuICAgICAgICBoZWFkZXJzOiBhdXRoSGVhZGVycyxcbiAgICAgICAgZmV0Y2g6IGZldGNoT3ZlcnJpZGUsXG4gICAgfSk7XG4gICAgY29uc3QgbWFrZUNhbGVuZGFyJDEgPSBkZWZhdWx0UGFyYW0obWFrZUNhbGVuZGFyLCB7XG4gICAgICAgIGhlYWRlcnM6IGF1dGhIZWFkZXJzLFxuICAgICAgICBmZXRjaDogZmV0Y2hPdmVycmlkZSxcbiAgICB9KTtcbiAgICBjb25zdCBmZXRjaENhbGVuZGFycyQxID0gZGVmYXVsdFBhcmFtKGZldGNoQ2FsZW5kYXJzLCB7XG4gICAgICAgIGhlYWRlcnM6IGF1dGhIZWFkZXJzLFxuICAgICAgICBhY2NvdW50OiBkZWZhdWx0QWNjb3VudCxcbiAgICAgICAgZmV0Y2g6IGZldGNoT3ZlcnJpZGUsXG4gICAgfSk7XG4gICAgY29uc3QgZmV0Y2hDYWxlbmRhclVzZXJBZGRyZXNzZXMkMSA9IGRlZmF1bHRQYXJhbShmZXRjaENhbGVuZGFyVXNlckFkZHJlc3Nlcywge1xuICAgICAgICBoZWFkZXJzOiBhdXRoSGVhZGVycyxcbiAgICAgICAgYWNjb3VudDogZGVmYXVsdEFjY291bnQsXG4gICAgICAgIGZldGNoOiBmZXRjaE92ZXJyaWRlLFxuICAgIH0pO1xuICAgIGNvbnN0IGZldGNoQ2FsZW5kYXJPYmplY3RzJDEgPSBkZWZhdWx0UGFyYW0oZmV0Y2hDYWxlbmRhck9iamVjdHMsIHtcbiAgICAgICAgaGVhZGVyczogYXV0aEhlYWRlcnMsXG4gICAgICAgIGZldGNoOiBmZXRjaE92ZXJyaWRlLFxuICAgIH0pO1xuICAgIGNvbnN0IGNyZWF0ZUNhbGVuZGFyT2JqZWN0JDEgPSBkZWZhdWx0UGFyYW0oY3JlYXRlQ2FsZW5kYXJPYmplY3QsIHtcbiAgICAgICAgaGVhZGVyczogYXV0aEhlYWRlcnMsXG4gICAgICAgIGZldGNoOiBmZXRjaE92ZXJyaWRlLFxuICAgIH0pO1xuICAgIGNvbnN0IHVwZGF0ZUNhbGVuZGFyT2JqZWN0JDEgPSBkZWZhdWx0UGFyYW0odXBkYXRlQ2FsZW5kYXJPYmplY3QsIHtcbiAgICAgICAgaGVhZGVyczogYXV0aEhlYWRlcnMsXG4gICAgICAgIGZldGNoOiBmZXRjaE92ZXJyaWRlLFxuICAgIH0pO1xuICAgIGNvbnN0IGRlbGV0ZUNhbGVuZGFyT2JqZWN0JDEgPSBkZWZhdWx0UGFyYW0oZGVsZXRlQ2FsZW5kYXJPYmplY3QsIHtcbiAgICAgICAgaGVhZGVyczogYXV0aEhlYWRlcnMsXG4gICAgICAgIGZldGNoOiBmZXRjaE92ZXJyaWRlLFxuICAgIH0pO1xuICAgIGNvbnN0IHN5bmNDYWxlbmRhcnMkMSA9IGRlZmF1bHRQYXJhbShzeW5jQ2FsZW5kYXJzLCB7XG4gICAgICAgIGFjY291bnQ6IGRlZmF1bHRBY2NvdW50LFxuICAgICAgICBoZWFkZXJzOiBhdXRoSGVhZGVycyxcbiAgICAgICAgZmV0Y2g6IGZldGNoT3ZlcnJpZGUsXG4gICAgfSk7XG4gICAgLy8gYWRkcmVzc0Jvb2tcbiAgICBjb25zdCBhZGRyZXNzQm9va1F1ZXJ5JDEgPSBkZWZhdWx0UGFyYW0oYWRkcmVzc0Jvb2tRdWVyeSwge1xuICAgICAgICBoZWFkZXJzOiBhdXRoSGVhZGVycyxcbiAgICAgICAgZmV0Y2g6IGZldGNoT3ZlcnJpZGUsXG4gICAgfSk7XG4gICAgY29uc3QgYWRkcmVzc0Jvb2tNdWx0aUdldCQxID0gZGVmYXVsdFBhcmFtKGFkZHJlc3NCb29rTXVsdGlHZXQsIHtcbiAgICAgICAgaGVhZGVyczogYXV0aEhlYWRlcnMsXG4gICAgICAgIGZldGNoOiBmZXRjaE92ZXJyaWRlLFxuICAgIH0pO1xuICAgIGNvbnN0IGZldGNoQWRkcmVzc0Jvb2tzJDEgPSBkZWZhdWx0UGFyYW0oZmV0Y2hBZGRyZXNzQm9va3MsIHtcbiAgICAgICAgYWNjb3VudDogZGVmYXVsdEFjY291bnQsXG4gICAgICAgIGhlYWRlcnM6IGF1dGhIZWFkZXJzLFxuICAgICAgICBmZXRjaDogZmV0Y2hPdmVycmlkZSxcbiAgICB9KTtcbiAgICBjb25zdCBmZXRjaFZDYXJkcyQxID0gZGVmYXVsdFBhcmFtKGZldGNoVkNhcmRzLCB7XG4gICAgICAgIGhlYWRlcnM6IGF1dGhIZWFkZXJzLFxuICAgICAgICBmZXRjaDogZmV0Y2hPdmVycmlkZSxcbiAgICB9KTtcbiAgICBjb25zdCBjcmVhdGVWQ2FyZCQxID0gZGVmYXVsdFBhcmFtKGNyZWF0ZVZDYXJkLCB7XG4gICAgICAgIGhlYWRlcnM6IGF1dGhIZWFkZXJzLFxuICAgICAgICBmZXRjaDogZmV0Y2hPdmVycmlkZSxcbiAgICB9KTtcbiAgICBjb25zdCB1cGRhdGVWQ2FyZCQxID0gZGVmYXVsdFBhcmFtKHVwZGF0ZVZDYXJkLCB7XG4gICAgICAgIGhlYWRlcnM6IGF1dGhIZWFkZXJzLFxuICAgICAgICBmZXRjaDogZmV0Y2hPdmVycmlkZSxcbiAgICB9KTtcbiAgICBjb25zdCBkZWxldGVWQ2FyZCQxID0gZGVmYXVsdFBhcmFtKGRlbGV0ZVZDYXJkLCB7XG4gICAgICAgIGhlYWRlcnM6IGF1dGhIZWFkZXJzLFxuICAgICAgICBmZXRjaDogZmV0Y2hPdmVycmlkZSxcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBkYXZSZXF1ZXN0OiBkYXZSZXF1ZXN0JDEsXG4gICAgICAgIHByb3BmaW5kOiBwcm9wZmluZCQxLFxuICAgICAgICBjcmVhdGVBY2NvdW50OiBjcmVhdGVBY2NvdW50JDEsXG4gICAgICAgIGNyZWF0ZU9iamVjdDogY3JlYXRlT2JqZWN0JDEsXG4gICAgICAgIHVwZGF0ZU9iamVjdDogdXBkYXRlT2JqZWN0JDEsXG4gICAgICAgIGRlbGV0ZU9iamVjdDogZGVsZXRlT2JqZWN0JDEsXG4gICAgICAgIGNhbGVuZGFyUXVlcnk6IGNhbGVuZGFyUXVlcnkkMSxcbiAgICAgICAgYWRkcmVzc0Jvb2tRdWVyeTogYWRkcmVzc0Jvb2tRdWVyeSQxLFxuICAgICAgICBjb2xsZWN0aW9uUXVlcnk6IGNvbGxlY3Rpb25RdWVyeSQxLFxuICAgICAgICBtYWtlQ29sbGVjdGlvbjogbWFrZUNvbGxlY3Rpb24kMSxcbiAgICAgICAgY2FsZW5kYXJNdWx0aUdldDogY2FsZW5kYXJNdWx0aUdldCQxLFxuICAgICAgICBtYWtlQ2FsZW5kYXI6IG1ha2VDYWxlbmRhciQxLFxuICAgICAgICBzeW5jQ29sbGVjdGlvbjogc3luY0NvbGxlY3Rpb24kMSxcbiAgICAgICAgc3VwcG9ydGVkUmVwb3J0U2V0OiBzdXBwb3J0ZWRSZXBvcnRTZXQkMSxcbiAgICAgICAgaXNDb2xsZWN0aW9uRGlydHk6IGlzQ29sbGVjdGlvbkRpcnR5JDEsXG4gICAgICAgIHNtYXJ0Q29sbGVjdGlvblN5bmM6IHNtYXJ0Q29sbGVjdGlvblN5bmMkMSxcbiAgICAgICAgZmV0Y2hDYWxlbmRhcnM6IGZldGNoQ2FsZW5kYXJzJDEsXG4gICAgICAgIGZldGNoQ2FsZW5kYXJVc2VyQWRkcmVzc2VzOiBmZXRjaENhbGVuZGFyVXNlckFkZHJlc3NlcyQxLFxuICAgICAgICBmZXRjaENhbGVuZGFyT2JqZWN0czogZmV0Y2hDYWxlbmRhck9iamVjdHMkMSxcbiAgICAgICAgY3JlYXRlQ2FsZW5kYXJPYmplY3Q6IGNyZWF0ZUNhbGVuZGFyT2JqZWN0JDEsXG4gICAgICAgIHVwZGF0ZUNhbGVuZGFyT2JqZWN0OiB1cGRhdGVDYWxlbmRhck9iamVjdCQxLFxuICAgICAgICBkZWxldGVDYWxlbmRhck9iamVjdDogZGVsZXRlQ2FsZW5kYXJPYmplY3QkMSxcbiAgICAgICAgc3luY0NhbGVuZGFyczogc3luY0NhbGVuZGFycyQxLFxuICAgICAgICBmZXRjaEFkZHJlc3NCb29rczogZmV0Y2hBZGRyZXNzQm9va3MkMSxcbiAgICAgICAgYWRkcmVzc0Jvb2tNdWx0aUdldDogYWRkcmVzc0Jvb2tNdWx0aUdldCQxLFxuICAgICAgICBmZXRjaFZDYXJkczogZmV0Y2hWQ2FyZHMkMSxcbiAgICAgICAgY3JlYXRlVkNhcmQ6IGNyZWF0ZVZDYXJkJDEsXG4gICAgICAgIHVwZGF0ZVZDYXJkOiB1cGRhdGVWQ2FyZCQxLFxuICAgICAgICBkZWxldGVWQ2FyZDogZGVsZXRlVkNhcmQkMSxcbiAgICB9O1xufTtcbmNsYXNzIERBVkNsaWVudCB7XG4gICAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICB0aGlzLnNlcnZlclVybCA9IHBhcmFtcy5zZXJ2ZXJVcmw7XG4gICAgICAgIHRoaXMuY3JlZGVudGlhbHMgPSBwYXJhbXMuY3JlZGVudGlhbHM7XG4gICAgICAgIHRoaXMuYXV0aE1ldGhvZCA9IChfYSA9IHBhcmFtcy5hdXRoTWV0aG9kKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnQmFzaWMnO1xuICAgICAgICB0aGlzLmFjY291bnRUeXBlID0gKF9iID0gcGFyYW1zLmRlZmF1bHRBY2NvdW50VHlwZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJ2NhbGRhdic7XG4gICAgICAgIHRoaXMuYXV0aEZ1bmN0aW9uID0gcGFyYW1zLmF1dGhGdW5jdGlvbjtcbiAgICAgICAgdGhpcy5mZXRjaE9wdGlvbnMgPSAoX2MgPSBwYXJhbXMuZmV0Y2hPcHRpb25zKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB7fTtcbiAgICAgICAgdGhpcy5mZXRjaE92ZXJyaWRlID0gcGFyYW1zLmZldGNoO1xuICAgIH1cbiAgICBhc3luYyBsb2dpbigpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBzd2l0Y2ggKHRoaXMuYXV0aE1ldGhvZCkge1xuICAgICAgICAgICAgY2FzZSAnQmFzaWMnOlxuICAgICAgICAgICAgICAgIHRoaXMuYXV0aEhlYWRlcnMgPSBnZXRCYXNpY0F1dGhIZWFkZXJzKHRoaXMuY3JlZGVudGlhbHMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnQmVhcmVyJzpcbiAgICAgICAgICAgICAgICB0aGlzLmF1dGhIZWFkZXJzID0gZ2V0QmVhcmVyQXV0aEhlYWRlcnModGhpcy5jcmVkZW50aWFscyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdPYXV0aCc6XG4gICAgICAgICAgICAgICAgdGhpcy5hdXRoSGVhZGVycyA9IChhd2FpdCBnZXRPYXV0aEhlYWRlcnModGhpcy5jcmVkZW50aWFscywgdGhpcy5mZXRjaE9wdGlvbnMsIHRoaXMuZmV0Y2hPdmVycmlkZSkpLmhlYWRlcnM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdEaWdlc3QnOlxuICAgICAgICAgICAgICAgIHRoaXMuYXV0aEhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIEF1dGhvcml6YXRpb246IGBEaWdlc3QgJHt0aGlzLmNyZWRlbnRpYWxzLmRpZ2VzdFN0cmluZ31gLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdDdXN0b20nOlxuICAgICAgICAgICAgICAgIHRoaXMuYXV0aEhlYWRlcnMgPSBhd2FpdCAoKF9hID0gdGhpcy5hdXRoRnVuY3Rpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIHRoaXMuY3JlZGVudGlhbHMpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGF1dGggbWV0aG9kJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY2NvdW50ID0gdGhpcy5hY2NvdW50VHlwZVxuICAgICAgICAgICAgPyBhd2FpdCBjcmVhdGVBY2NvdW50KHtcbiAgICAgICAgICAgICAgICBhY2NvdW50OiB7XG4gICAgICAgICAgICAgICAgICAgIHNlcnZlclVybDogdGhpcy5zZXJ2ZXJVcmwsXG4gICAgICAgICAgICAgICAgICAgIGNyZWRlbnRpYWxzOiB0aGlzLmNyZWRlbnRpYWxzLFxuICAgICAgICAgICAgICAgICAgICBhY2NvdW50VHlwZTogdGhpcy5hY2NvdW50VHlwZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuYXV0aEhlYWRlcnMsXG4gICAgICAgICAgICAgICAgZmV0Y2hPcHRpb25zOiB0aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBmZXRjaDogdGhpcy5mZXRjaE92ZXJyaWRlLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBhc3luYyBkYXZSZXF1ZXN0KHBhcmFtczApIHtcbiAgICAgICAgY29uc3QgeyBpbml0LCBmZXRjaDogZmV0Y2hPdmVycmlkZTIsIC4uLnJlc3QgfSA9IHBhcmFtczA7XG4gICAgICAgIGNvbnN0IHsgaGVhZGVycywgLi4ucmVzdEluaXQgfSA9IGluaXQ7XG4gICAgICAgIHJldHVybiBkYXZSZXF1ZXN0KHtcbiAgICAgICAgICAgIC4uLnJlc3QsXG4gICAgICAgICAgICBpbml0OiB7XG4gICAgICAgICAgICAgICAgLi4ucmVzdEluaXQsXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAuLi50aGlzLmF1dGhIZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICAuLi5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmV0Y2hPcHRpb25zOiB0aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgIGZldGNoOiBmZXRjaE92ZXJyaWRlMiAhPT0gbnVsbCAmJiBmZXRjaE92ZXJyaWRlMiAhPT0gdm9pZCAwID8gZmV0Y2hPdmVycmlkZTIgOiB0aGlzLmZldGNoT3ZlcnJpZGUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVPYmplY3QoLi4ucGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0UGFyYW0oY3JlYXRlT2JqZWN0LCB7XG4gICAgICAgICAgICB1cmw6IHRoaXMuc2VydmVyVXJsLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5hdXRoSGVhZGVycyxcbiAgICAgICAgICAgIGZldGNoT3B0aW9uczogdGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICBmZXRjaDogdGhpcy5mZXRjaE92ZXJyaWRlLFxuICAgICAgICB9KShwYXJhbXNbMF0pO1xuICAgIH1cbiAgICBhc3luYyB1cGRhdGVPYmplY3QoLi4ucGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0UGFyYW0odXBkYXRlT2JqZWN0LCB7XG4gICAgICAgICAgICB1cmw6IHRoaXMuc2VydmVyVXJsLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5hdXRoSGVhZGVycyxcbiAgICAgICAgICAgIGZldGNoT3B0aW9uczogdGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICBmZXRjaDogdGhpcy5mZXRjaE92ZXJyaWRlLFxuICAgICAgICB9KShwYXJhbXNbMF0pO1xuICAgIH1cbiAgICBhc3luYyBkZWxldGVPYmplY3QoLi4ucGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0UGFyYW0oZGVsZXRlT2JqZWN0LCB7XG4gICAgICAgICAgICB1cmw6IHRoaXMuc2VydmVyVXJsLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5hdXRoSGVhZGVycyxcbiAgICAgICAgICAgIGZldGNoT3B0aW9uczogdGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICBmZXRjaDogdGhpcy5mZXRjaE92ZXJyaWRlLFxuICAgICAgICB9KShwYXJhbXNbMF0pO1xuICAgIH1cbiAgICBhc3luYyBwcm9wZmluZCguLi5wYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRQYXJhbShwcm9wZmluZCwge1xuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5hdXRoSGVhZGVycyxcbiAgICAgICAgICAgIGZldGNoT3B0aW9uczogdGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICBmZXRjaDogdGhpcy5mZXRjaE92ZXJyaWRlLFxuICAgICAgICB9KShwYXJhbXNbMF0pO1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVBY2NvdW50KHBhcmFtczApIHtcbiAgICAgICAgY29uc3QgeyBhY2NvdW50LCBoZWFkZXJzLCBsb2FkQ29sbGVjdGlvbnMsIGxvYWRPYmplY3RzLCBmZXRjaE9wdGlvbnMsIGZldGNoIH0gPSBwYXJhbXMwO1xuICAgICAgICByZXR1cm4gY3JlYXRlQWNjb3VudCh7XG4gICAgICAgICAgICBhY2NvdW50OiB7IHNlcnZlclVybDogdGhpcy5zZXJ2ZXJVcmwsIGNyZWRlbnRpYWxzOiB0aGlzLmNyZWRlbnRpYWxzLCAuLi5hY2NvdW50IH0sXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuYXV0aEhlYWRlcnMsIC4uLmhlYWRlcnMgfSxcbiAgICAgICAgICAgIGxvYWRDb2xsZWN0aW9ucyxcbiAgICAgICAgICAgIGxvYWRPYmplY3RzLFxuICAgICAgICAgICAgZmV0Y2hPcHRpb25zOiBmZXRjaE9wdGlvbnMgIT09IG51bGwgJiYgZmV0Y2hPcHRpb25zICE9PSB2b2lkIDAgPyBmZXRjaE9wdGlvbnMgOiB0aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgIGZldGNoOiBmZXRjaCAhPT0gbnVsbCAmJiBmZXRjaCAhPT0gdm9pZCAwID8gZmV0Y2ggOiB0aGlzLmZldGNoT3ZlcnJpZGUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBjb2xsZWN0aW9uUXVlcnkoLi4ucGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0UGFyYW0oY29sbGVjdGlvblF1ZXJ5LCB7XG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmF1dGhIZWFkZXJzLFxuICAgICAgICAgICAgZmV0Y2hPcHRpb25zOiB0aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgIGZldGNoOiB0aGlzLmZldGNoT3ZlcnJpZGUsXG4gICAgICAgIH0pKHBhcmFtc1swXSk7XG4gICAgfVxuICAgIGFzeW5jIG1ha2VDb2xsZWN0aW9uKC4uLnBhcmFtcykge1xuICAgICAgICByZXR1cm4gZGVmYXVsdFBhcmFtKG1ha2VDb2xsZWN0aW9uLCB7XG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmF1dGhIZWFkZXJzLFxuICAgICAgICAgICAgZmV0Y2hPcHRpb25zOiB0aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgIGZldGNoOiB0aGlzLmZldGNoT3ZlcnJpZGUsXG4gICAgICAgIH0pKHBhcmFtc1swXSk7XG4gICAgfVxuICAgIGFzeW5jIHN5bmNDb2xsZWN0aW9uKC4uLnBhcmFtcykge1xuICAgICAgICByZXR1cm4gZGVmYXVsdFBhcmFtKHN5bmNDb2xsZWN0aW9uLCB7XG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmF1dGhIZWFkZXJzLFxuICAgICAgICAgICAgZmV0Y2hPcHRpb25zOiB0aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgIGZldGNoOiB0aGlzLmZldGNoT3ZlcnJpZGUsXG4gICAgICAgIH0pKHBhcmFtc1swXSk7XG4gICAgfVxuICAgIGFzeW5jIHN1cHBvcnRlZFJlcG9ydFNldCguLi5wYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRQYXJhbShzdXBwb3J0ZWRSZXBvcnRTZXQsIHtcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuYXV0aEhlYWRlcnMsXG4gICAgICAgICAgICBmZXRjaE9wdGlvbnM6IHRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgZmV0Y2g6IHRoaXMuZmV0Y2hPdmVycmlkZSxcbiAgICAgICAgfSkocGFyYW1zWzBdKTtcbiAgICB9XG4gICAgYXN5bmMgaXNDb2xsZWN0aW9uRGlydHkoLi4ucGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0UGFyYW0oaXNDb2xsZWN0aW9uRGlydHksIHtcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuYXV0aEhlYWRlcnMsXG4gICAgICAgICAgICBmZXRjaE9wdGlvbnM6IHRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgZmV0Y2g6IHRoaXMuZmV0Y2hPdmVycmlkZSxcbiAgICAgICAgfSkocGFyYW1zWzBdKTtcbiAgICB9XG4gICAgYXN5bmMgc21hcnRDb2xsZWN0aW9uU3luYyguLi5wYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRQYXJhbShzbWFydENvbGxlY3Rpb25TeW5jLCB7XG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmF1dGhIZWFkZXJzLFxuICAgICAgICAgICAgZmV0Y2hPcHRpb25zOiB0aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgIGZldGNoOiB0aGlzLmZldGNoT3ZlcnJpZGUsXG4gICAgICAgICAgICBhY2NvdW50OiB0aGlzLmFjY291bnQsXG4gICAgICAgIH0pKHBhcmFtc1swXSk7XG4gICAgfVxuICAgIGFzeW5jIGNhbGVuZGFyUXVlcnkoLi4ucGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0UGFyYW0oY2FsZW5kYXJRdWVyeSwge1xuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5hdXRoSGVhZGVycyxcbiAgICAgICAgICAgIGZldGNoT3B0aW9uczogdGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICBmZXRjaDogdGhpcy5mZXRjaE92ZXJyaWRlLFxuICAgICAgICB9KShwYXJhbXNbMF0pO1xuICAgIH1cbiAgICBhc3luYyBtYWtlQ2FsZW5kYXIoLi4ucGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0UGFyYW0obWFrZUNhbGVuZGFyLCB7XG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmF1dGhIZWFkZXJzLFxuICAgICAgICAgICAgZmV0Y2hPcHRpb25zOiB0aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgIGZldGNoOiB0aGlzLmZldGNoT3ZlcnJpZGUsXG4gICAgICAgIH0pKHBhcmFtc1swXSk7XG4gICAgfVxuICAgIGFzeW5jIGNhbGVuZGFyTXVsdGlHZXQoLi4ucGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0UGFyYW0oY2FsZW5kYXJNdWx0aUdldCwge1xuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5hdXRoSGVhZGVycyxcbiAgICAgICAgICAgIGZldGNoT3B0aW9uczogdGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICBmZXRjaDogdGhpcy5mZXRjaE92ZXJyaWRlLFxuICAgICAgICB9KShwYXJhbXNbMF0pO1xuICAgIH1cbiAgICBhc3luYyBmZXRjaENhbGVuZGFycyguLi5wYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRQYXJhbShmZXRjaENhbGVuZGFycywge1xuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5hdXRoSGVhZGVycyxcbiAgICAgICAgICAgIGFjY291bnQ6IHRoaXMuYWNjb3VudCxcbiAgICAgICAgICAgIGZldGNoT3B0aW9uczogdGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICBmZXRjaDogdGhpcy5mZXRjaE92ZXJyaWRlLFxuICAgICAgICB9KShwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXNbMF0pO1xuICAgIH1cbiAgICBhc3luYyBmZXRjaENhbGVuZGFyVXNlckFkZHJlc3NlcyguLi5wYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRQYXJhbShmZXRjaENhbGVuZGFyVXNlckFkZHJlc3Nlcywge1xuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5hdXRoSGVhZGVycyxcbiAgICAgICAgICAgIGFjY291bnQ6IHRoaXMuYWNjb3VudCxcbiAgICAgICAgICAgIGZldGNoT3B0aW9uczogdGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICBmZXRjaDogdGhpcy5mZXRjaE92ZXJyaWRlLFxuICAgICAgICB9KShwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXNbMF0pO1xuICAgIH1cbiAgICBhc3luYyBmZXRjaENhbGVuZGFyT2JqZWN0cyguLi5wYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRQYXJhbShmZXRjaENhbGVuZGFyT2JqZWN0cywge1xuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5hdXRoSGVhZGVycyxcbiAgICAgICAgICAgIGZldGNoT3B0aW9uczogdGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICBmZXRjaDogdGhpcy5mZXRjaE92ZXJyaWRlLFxuICAgICAgICB9KShwYXJhbXNbMF0pO1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVDYWxlbmRhck9iamVjdCguLi5wYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRQYXJhbShjcmVhdGVDYWxlbmRhck9iamVjdCwge1xuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5hdXRoSGVhZGVycyxcbiAgICAgICAgICAgIGZldGNoT3B0aW9uczogdGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICBmZXRjaDogdGhpcy5mZXRjaE92ZXJyaWRlLFxuICAgICAgICB9KShwYXJhbXNbMF0pO1xuICAgIH1cbiAgICBhc3luYyB1cGRhdGVDYWxlbmRhck9iamVjdCguLi5wYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRQYXJhbSh1cGRhdGVDYWxlbmRhck9iamVjdCwge1xuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5hdXRoSGVhZGVycyxcbiAgICAgICAgICAgIGZldGNoT3B0aW9uczogdGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICBmZXRjaDogdGhpcy5mZXRjaE92ZXJyaWRlLFxuICAgICAgICB9KShwYXJhbXNbMF0pO1xuICAgIH1cbiAgICBhc3luYyBkZWxldGVDYWxlbmRhck9iamVjdCguLi5wYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRQYXJhbShkZWxldGVDYWxlbmRhck9iamVjdCwge1xuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5hdXRoSGVhZGVycyxcbiAgICAgICAgICAgIGZldGNoT3B0aW9uczogdGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICBmZXRjaDogdGhpcy5mZXRjaE92ZXJyaWRlLFxuICAgICAgICB9KShwYXJhbXNbMF0pO1xuICAgIH1cbiAgICBhc3luYyBzeW5jQ2FsZW5kYXJzKC4uLnBhcmFtcykge1xuICAgICAgICByZXR1cm4gZGVmYXVsdFBhcmFtKHN5bmNDYWxlbmRhcnMsIHtcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuYXV0aEhlYWRlcnMsXG4gICAgICAgICAgICBhY2NvdW50OiB0aGlzLmFjY291bnQsXG4gICAgICAgICAgICBmZXRjaE9wdGlvbnM6IHRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgZmV0Y2g6IHRoaXMuZmV0Y2hPdmVycmlkZSxcbiAgICAgICAgfSkocGFyYW1zWzBdKTtcbiAgICB9XG4gICAgYXN5bmMgYWRkcmVzc0Jvb2tRdWVyeSguLi5wYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRQYXJhbShhZGRyZXNzQm9va1F1ZXJ5LCB7XG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmF1dGhIZWFkZXJzLFxuICAgICAgICAgICAgZmV0Y2hPcHRpb25zOiB0aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgIGZldGNoOiB0aGlzLmZldGNoT3ZlcnJpZGUsXG4gICAgICAgIH0pKHBhcmFtc1swXSk7XG4gICAgfVxuICAgIGFzeW5jIGFkZHJlc3NCb29rTXVsdGlHZXQoLi4ucGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0UGFyYW0oYWRkcmVzc0Jvb2tNdWx0aUdldCwge1xuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5hdXRoSGVhZGVycyxcbiAgICAgICAgICAgIGZldGNoT3B0aW9uczogdGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICBmZXRjaDogdGhpcy5mZXRjaE92ZXJyaWRlLFxuICAgICAgICB9KShwYXJhbXNbMF0pO1xuICAgIH1cbiAgICBhc3luYyBmZXRjaEFkZHJlc3NCb29rcyguLi5wYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRQYXJhbShmZXRjaEFkZHJlc3NCb29rcywge1xuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5hdXRoSGVhZGVycyxcbiAgICAgICAgICAgIGFjY291bnQ6IHRoaXMuYWNjb3VudCxcbiAgICAgICAgICAgIGZldGNoT3B0aW9uczogdGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICBmZXRjaDogdGhpcy5mZXRjaE92ZXJyaWRlLFxuICAgICAgICB9KShwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXNbMF0pO1xuICAgIH1cbiAgICBhc3luYyBmZXRjaFZDYXJkcyguLi5wYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRQYXJhbShmZXRjaFZDYXJkcywge1xuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5hdXRoSGVhZGVycyxcbiAgICAgICAgICAgIGZldGNoT3B0aW9uczogdGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICBmZXRjaDogdGhpcy5mZXRjaE92ZXJyaWRlLFxuICAgICAgICB9KShwYXJhbXNbMF0pO1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVWQ2FyZCguLi5wYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRQYXJhbShjcmVhdGVWQ2FyZCwge1xuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5hdXRoSGVhZGVycyxcbiAgICAgICAgICAgIGZldGNoT3B0aW9uczogdGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICBmZXRjaDogdGhpcy5mZXRjaE92ZXJyaWRlLFxuICAgICAgICB9KShwYXJhbXNbMF0pO1xuICAgIH1cbiAgICBhc3luYyB1cGRhdGVWQ2FyZCguLi5wYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRQYXJhbSh1cGRhdGVWQ2FyZCwge1xuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5hdXRoSGVhZGVycyxcbiAgICAgICAgICAgIGZldGNoT3B0aW9uczogdGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICBmZXRjaDogdGhpcy5mZXRjaE92ZXJyaWRlLFxuICAgICAgICB9KShwYXJhbXNbMF0pO1xuICAgIH1cbiAgICBhc3luYyBkZWxldGVWQ2FyZCguLi5wYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRQYXJhbShkZWxldGVWQ2FyZCwge1xuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5hdXRoSGVhZGVycyxcbiAgICAgICAgICAgIGZldGNoT3B0aW9uczogdGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICBmZXRjaDogdGhpcy5mZXRjaE92ZXJyaWRlLFxuICAgICAgICB9KShwYXJhbXNbMF0pO1xuICAgIH1cbn1cblxudmFyIGNsaWVudCA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgREFWQ2xpZW50OiBEQVZDbGllbnQsXG4gICAgY3JlYXRlREFWQ2xpZW50OiBjcmVhdGVEQVZDbGllbnRcbn0pO1xuXG52YXIgaW5kZXggPSB7XG4gICAgREFWTmFtZXNwYWNlLFxuICAgIERBVk5hbWVzcGFjZVNob3J0LFxuICAgIERBVkF0dHJpYnV0ZU1hcCxcbiAgICAuLi5jbGllbnQsXG4gICAgLi4ucmVxdWVzdCxcbiAgICAuLi5jb2xsZWN0aW9uLFxuICAgIC4uLmFjY291bnQsXG4gICAgLi4uYWRkcmVzc0Jvb2ssXG4gICAgLi4uY2FsZW5kYXIsXG4gICAgLi4uYXV0aEhlbHBlcnMsXG4gICAgLi4ucmVxdWVzdEhlbHBlcnMsXG59O1xuXG5leHBvcnQgeyBEQVZBdHRyaWJ1dGVNYXAsIERBVkNsaWVudCwgREFWTmFtZXNwYWNlLCBEQVZOYW1lc3BhY2VTaG9ydCwgYWRkcmVzc0Jvb2tNdWx0aUdldCwgYWRkcmVzc0Jvb2tRdWVyeSwgY2FsZW5kYXJNdWx0aUdldCwgY2FsZW5kYXJRdWVyeSwgY2xlYW51cEZhbHN5LCBjb2xsZWN0aW9uUXVlcnksIGNyZWF0ZUFjY291bnQsIGNyZWF0ZUNhbGVuZGFyT2JqZWN0LCBjcmVhdGVEQVZDbGllbnQsIGNyZWF0ZU9iamVjdCwgY3JlYXRlVkNhcmQsIGRhdlJlcXVlc3QsIGluZGV4IGFzIGRlZmF1bHQsIGRlbGV0ZUNhbGVuZGFyT2JqZWN0LCBkZWxldGVPYmplY3QsIGRlbGV0ZVZDYXJkLCBmZXRjaEFkZHJlc3NCb29rcywgZmV0Y2hDYWxlbmRhck9iamVjdHMsIGZldGNoQ2FsZW5kYXJVc2VyQWRkcmVzc2VzLCBmZXRjaENhbGVuZGFycywgZmV0Y2hPYXV0aFRva2VucywgZmV0Y2hWQ2FyZHMsIGZyZWVCdXN5UXVlcnksIGdldEJhc2ljQXV0aEhlYWRlcnMsIGdldEJlYXJlckF1dGhIZWFkZXJzLCBnZXREQVZBdHRyaWJ1dGUsIGdldE9hdXRoSGVhZGVycywgaXNDb2xsZWN0aW9uRGlydHksIG1ha2VDYWxlbmRhciwgcHJvcGZpbmQsIHJlZnJlc2hBY2Nlc3NUb2tlbiwgc21hcnRDb2xsZWN0aW9uU3luYywgc3VwcG9ydGVkUmVwb3J0U2V0LCBzeW5jQ2FsZW5kYXJzLCBzeW5jQ29sbGVjdGlvbiwgdXBkYXRlQ2FsZW5kYXJPYmplY3QsIHVwZGF0ZU9iamVjdCwgdXBkYXRlVkNhcmQsIHVybENvbnRhaW5zLCB1cmxFcXVhbHMgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/tsdav/dist/tsdav.esm.js\n");

/***/ })

};
;