"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/context/ExpenseContext.tsx":
/*!****************************************!*\
  !*** ./src/context/ExpenseContext.tsx ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ExpenseProvider: function() { return /* binding */ ExpenseProvider; },\n/* harmony export */   useExpenses: function() { return /* binding */ useExpenses; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _utils_generateId__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/utils/generateId */ \"(app-pages-browser)/./src/utils/generateId.ts\");\n/* __next_internal_client_entry_do_not_use__ ExpenseProvider,useExpenses auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\nconst ExpenseContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nconst ExpenseProvider = (param)=>{\n    let { children } = param;\n    _s();\n    const [expenses, setExpenses] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(()=>{\n        if (false) {}\n        const saved = localStorage.getItem(\"life-os-expenses\");\n        return saved ? JSON.parse(saved) : [];\n    });\n    const [isSyncing, setIsSyncing] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [syncError, setSyncError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        localStorage.setItem(\"life-os-expenses\", JSON.stringify(expenses));\n    }, [\n        expenses\n    ]);\n    const addExpense = (expense)=>{\n        const newExpense = {\n            ...expense,\n            id: (0,_utils_generateId__WEBPACK_IMPORTED_MODULE_2__.generateId)()\n        };\n        setExpenses((prev)=>[\n                ...prev,\n                newExpense\n            ]);\n    };\n    const updateExpense = (id, updates)=>{\n        setExpenses((prev)=>prev.map((e)=>e.id === id ? {\n                    ...e,\n                    ...updates\n                } : e));\n    };\n    const deleteExpense = (id)=>{\n        setExpenses((prev)=>prev.filter((e)=>e.id !== id));\n    };\n    const getDailyTotal = ()=>{\n        const today = new Date().toDateString();\n        return expenses.filter((e)=>new Date(e.date).toDateString() === today).reduce((total, e)=>total + e.amount, 0);\n    };\n    const getMonthlyTotal = ()=>{\n        const now = new Date();\n        const currentMonth = now.getMonth();\n        const currentYear = now.getFullYear();\n        return expenses.filter((e)=>{\n            const d = new Date(e.date);\n            return d.getMonth() === currentMonth && d.getFullYear() === currentYear;\n        }).reduce((total, e)=>total + e.amount, 0);\n    };\n    const syncSplitwise = async ()=>{\n        setIsSyncing(true);\n        setSyncError(null);\n        try {\n            // Fetch expenses for \"Sepal combined expenses\" group (ID: 90988419)\n            // Limit to 200 to ensure we get enough for the month\n            const res = await fetch(\"/api/expenses/sync?group_id=90988419&limit=200\");\n            if (!res.ok) {\n                const data = await res.json();\n                throw new Error(data.error || \"Failed to sync Splitwise\");\n            }\n            const synced = await res.json();\n            // Filter for CURRENT MONTH only\n            const now = new Date();\n            const currentMonth = now.getMonth();\n            const currentYear = now.getFullYear();\n            const currentMonthExpenses = synced.filter((s)=>{\n                const d = new Date(s.date);\n                return d.getMonth() === currentMonth && d.getFullYear() === currentYear;\n            });\n            setExpenses((prev)=>{\n                // Remove all existing Splitwise expenses (to avoid duplicates/stale data)\n                // We identify them by the note prefix [Splitwise]\n                const localOnly = prev.filter((e)=>!e.note.startsWith(\"[Splitwise]\"));\n                // Add new sync data\n                const newExpenses = currentMonthExpenses.map((s)=>({\n                        ...s,\n                        id: (0,_utils_generateId__WEBPACK_IMPORTED_MODULE_2__.generateId)()\n                    }));\n                return [\n                    ...localOnly,\n                    ...newExpenses\n                ];\n            });\n        } catch (err) {\n            setSyncError(err.message || \"Sync failed\");\n        } finally{\n            setIsSyncing(false);\n        }\n    };\n    const clearAllExpenses = ()=>{\n        setExpenses([]);\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ExpenseContext.Provider, {\n        value: {\n            expenses,\n            addExpense,\n            updateExpense,\n            deleteExpense,\n            getDailyTotal,\n            getMonthlyTotal,\n            syncSplitwise,\n            isSyncing,\n            syncError,\n            clearAllExpenses\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\kharw\\\\OneDrive\\\\Desktop\\\\ai-assistant\\\\src\\\\context\\\\ExpenseContext.tsx\",\n        lineNumber: 115,\n        columnNumber: 9\n    }, undefined);\n};\n_s(ExpenseProvider, \"aYE9xMceRUfH0H5O4ISO6zx4riA=\");\n_c = ExpenseProvider;\nconst useExpenses = ()=>{\n    _s1();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(ExpenseContext);\n    if (!context) throw new Error(\"useExpenses must be used within an ExpenseProvider\");\n    return context;\n};\n_s1(useExpenses, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"ExpenseProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb250ZXh0L0V4cGVuc2VDb250ZXh0LnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUU4RTtBQUU5QjtBQWVoRCxNQUFNTSwrQkFBaUJMLG9EQUFhQSxDQUFpQ007QUFFOUQsTUFBTUMsa0JBQTJEO1FBQUMsRUFBRUMsUUFBUSxFQUFFOztJQUNqRixNQUFNLENBQUNDLFVBQVVDLFlBQVksR0FBR1AsK0NBQVFBLENBQVk7UUFDaEQsSUFBSSxLQUFrQixFQUFhLEVBQVU7UUFDN0MsTUFBTVEsUUFBUUMsYUFBYUMsT0FBTyxDQUFDO1FBQ25DLE9BQU9GLFFBQVFHLEtBQUtDLEtBQUssQ0FBQ0osU0FBUyxFQUFFO0lBQ3pDO0lBRUEsTUFBTSxDQUFDSyxXQUFXQyxhQUFhLEdBQUdkLCtDQUFRQSxDQUFDO0lBQzNDLE1BQU0sQ0FBQ2UsV0FBV0MsYUFBYSxHQUFHaEIsK0NBQVFBLENBQWdCO0lBRTFERCxnREFBU0EsQ0FBQztRQUNOVSxhQUFhUSxPQUFPLENBQUMsb0JBQW9CTixLQUFLTyxTQUFTLENBQUNaO0lBQzVELEdBQUc7UUFBQ0E7S0FBUztJQUViLE1BQU1hLGFBQWEsQ0FBQ0M7UUFDaEIsTUFBTUMsYUFBc0I7WUFBRSxHQUFHRCxPQUFPO1lBQUVFLElBQUlyQiw2REFBVUE7UUFBRztRQUMzRE0sWUFBWWdCLENBQUFBLE9BQVE7bUJBQUlBO2dCQUFNRjthQUFXO0lBQzdDO0lBRUEsTUFBTUcsZ0JBQWdCLENBQUNGLElBQVlHO1FBQy9CbEIsWUFBWWdCLENBQUFBLE9BQVFBLEtBQUtHLEdBQUcsQ0FBQ0MsQ0FBQUEsSUFDekJBLEVBQUVMLEVBQUUsS0FBS0EsS0FBSztvQkFBRSxHQUFHSyxDQUFDO29CQUFFLEdBQUdGLE9BQU87Z0JBQUMsSUFBSUU7SUFFN0M7SUFFQSxNQUFNQyxnQkFBZ0IsQ0FBQ047UUFDbkJmLFlBQVlnQixDQUFBQSxPQUFRQSxLQUFLTSxNQUFNLENBQUNGLENBQUFBLElBQUtBLEVBQUVMLEVBQUUsS0FBS0E7SUFDbEQ7SUFFQSxNQUFNUSxnQkFBZ0I7UUFDbEIsTUFBTUMsUUFBUSxJQUFJQyxPQUFPQyxZQUFZO1FBQ3JDLE9BQU8zQixTQUNGdUIsTUFBTSxDQUFDRixDQUFBQSxJQUFLLElBQUlLLEtBQUtMLEVBQUVPLElBQUksRUFBRUQsWUFBWSxPQUFPRixPQUNoREksTUFBTSxDQUFDLENBQUNDLE9BQU9ULElBQU1TLFFBQVFULEVBQUVVLE1BQU0sRUFBRTtJQUNoRDtJQUVBLE1BQU1DLGtCQUFrQjtRQUNwQixNQUFNQyxNQUFNLElBQUlQO1FBQ2hCLE1BQU1RLGVBQWVELElBQUlFLFFBQVE7UUFDakMsTUFBTUMsY0FBY0gsSUFBSUksV0FBVztRQUNuQyxPQUFPckMsU0FDRnVCLE1BQU0sQ0FBQ0YsQ0FBQUE7WUFDSixNQUFNaUIsSUFBSSxJQUFJWixLQUFLTCxFQUFFTyxJQUFJO1lBQ3pCLE9BQU9VLEVBQUVILFFBQVEsT0FBT0QsZ0JBQWdCSSxFQUFFRCxXQUFXLE9BQU9EO1FBQ2hFLEdBQ0NQLE1BQU0sQ0FBQyxDQUFDQyxPQUFPVCxJQUFNUyxRQUFRVCxFQUFFVSxNQUFNLEVBQUU7SUFDaEQ7SUFFQSxNQUFNUSxnQkFBZ0I7UUFDbEIvQixhQUFhO1FBQ2JFLGFBQWE7UUFDYixJQUFJO1lBQ0Esb0VBQW9FO1lBQ3BFLHFEQUFxRDtZQUNyRCxNQUFNOEIsTUFBTSxNQUFNQyxNQUFNO1lBQ3hCLElBQUksQ0FBQ0QsSUFBSUUsRUFBRSxFQUFFO2dCQUNULE1BQU1DLE9BQU8sTUFBTUgsSUFBSUksSUFBSTtnQkFDM0IsTUFBTSxJQUFJQyxNQUFNRixLQUFLRyxLQUFLLElBQUk7WUFDbEM7WUFDQSxNQUFNQyxTQUFnQyxNQUFNUCxJQUFJSSxJQUFJO1lBRXBELGdDQUFnQztZQUNoQyxNQUFNWCxNQUFNLElBQUlQO1lBQ2hCLE1BQU1RLGVBQWVELElBQUlFLFFBQVE7WUFDakMsTUFBTUMsY0FBY0gsSUFBSUksV0FBVztZQUVuQyxNQUFNVyx1QkFBdUJELE9BQU94QixNQUFNLENBQUMwQixDQUFBQTtnQkFDdkMsTUFBTVgsSUFBSSxJQUFJWixLQUFLdUIsRUFBRXJCLElBQUk7Z0JBQ3pCLE9BQU9VLEVBQUVILFFBQVEsT0FBT0QsZ0JBQWdCSSxFQUFFRCxXQUFXLE9BQU9EO1lBQ2hFO1lBRUFuQyxZQUFZZ0IsQ0FBQUE7Z0JBQ1IsMEVBQTBFO2dCQUMxRSxrREFBa0Q7Z0JBQ2xELE1BQU1pQyxZQUFZakMsS0FBS00sTUFBTSxDQUFDRixDQUFBQSxJQUFLLENBQUNBLEVBQUU4QixJQUFJLENBQUNDLFVBQVUsQ0FBQztnQkFFdEQsb0JBQW9CO2dCQUNwQixNQUFNQyxjQUFjTCxxQkFBcUI1QixHQUFHLENBQUM2QixDQUFBQSxJQUFNO3dCQUFFLEdBQUdBLENBQUM7d0JBQUVqQyxJQUFJckIsNkRBQVVBO29CQUFHO2dCQUU1RSxPQUFPO3VCQUFJdUQ7dUJBQWNHO2lCQUFZO1lBQ3pDO1FBQ0osRUFBRSxPQUFPQyxLQUFVO1lBQ2Y1QyxhQUFhNEMsSUFBSUMsT0FBTyxJQUFJO1FBQ2hDLFNBQVU7WUFDTi9DLGFBQWE7UUFDakI7SUFDSjtJQUVBLE1BQU1nRCxtQkFBbUI7UUFDckJ2RCxZQUFZLEVBQUU7SUFDbEI7SUFFQSxxQkFDSSw4REFBQ0wsZUFBZTZELFFBQVE7UUFBQ0MsT0FBTztZQUM1QjFEO1lBQVVhO1lBQVlLO1lBQWVJO1lBQ3JDRTtZQUFlUTtZQUFpQk87WUFBZWhDO1lBQVdFO1lBQVcrQztRQUN6RTtrQkFDS3pEOzs7Ozs7QUFHYixFQUFFO0dBcEdXRDtLQUFBQTtBQXNHTixNQUFNNkQsY0FBYzs7SUFDdkIsTUFBTUMsVUFBVXBFLGlEQUFVQSxDQUFDSTtJQUMzQixJQUFJLENBQUNnRSxTQUFTLE1BQU0sSUFBSWYsTUFBTTtJQUM5QixPQUFPZTtBQUNYLEVBQUU7SUFKV0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbnRleHQvRXhwZW5zZUNvbnRleHQudHN4PzkwOTEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xyXG5cclxuaW1wb3J0IFJlYWN0LCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7IEV4cGVuc2UgfSBmcm9tICdAL3R5cGVzL2V4cGVuc2UnO1xyXG5pbXBvcnQgeyBnZW5lcmF0ZUlkIH0gZnJvbSAnQC91dGlscy9nZW5lcmF0ZUlkJztcclxuXHJcbmludGVyZmFjZSBFeHBlbnNlQ29udGV4dFR5cGUge1xyXG4gICAgZXhwZW5zZXM6IEV4cGVuc2VbXTtcclxuICAgIGFkZEV4cGVuc2U6IChleHBlbnNlOiBPbWl0PEV4cGVuc2UsICdpZCc+KSA9PiB2b2lkO1xyXG4gICAgdXBkYXRlRXhwZW5zZTogKGlkOiBzdHJpbmcsIHVwZGF0ZXM6IFBhcnRpYWw8RXhwZW5zZT4pID0+IHZvaWQ7XHJcbiAgICBkZWxldGVFeHBlbnNlOiAoaWQ6IHN0cmluZykgPT4gdm9pZDtcclxuICAgIGdldERhaWx5VG90YWw6ICgpID0+IG51bWJlcjtcclxuICAgIGdldE1vbnRobHlUb3RhbDogKCkgPT4gbnVtYmVyO1xyXG4gICAgc3luY1NwbGl0d2lzZTogKCkgPT4gUHJvbWlzZTx2b2lkPjtcclxuICAgIGlzU3luY2luZzogYm9vbGVhbjtcclxuICAgIHN5bmNFcnJvcjogc3RyaW5nIHwgbnVsbDtcclxuICAgIGNsZWFyQWxsRXhwZW5zZXM6ICgpID0+IHZvaWQ7XHJcbn1cclxuXHJcbmNvbnN0IEV4cGVuc2VDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxFeHBlbnNlQ29udGV4dFR5cGUgfCB1bmRlZmluZWQ+KHVuZGVmaW5lZCk7XHJcblxyXG5leHBvcnQgY29uc3QgRXhwZW5zZVByb3ZpZGVyOiBSZWFjdC5GQzx7IGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGUgfT4gPSAoeyBjaGlsZHJlbiB9KSA9PiB7XHJcbiAgICBjb25zdCBbZXhwZW5zZXMsIHNldEV4cGVuc2VzXSA9IHVzZVN0YXRlPEV4cGVuc2VbXT4oKCkgPT4ge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuIFtdO1xyXG4gICAgICAgIGNvbnN0IHNhdmVkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2xpZmUtb3MtZXhwZW5zZXMnKTtcclxuICAgICAgICByZXR1cm4gc2F2ZWQgPyBKU09OLnBhcnNlKHNhdmVkKSA6IFtdO1xyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgW2lzU3luY2luZywgc2V0SXNTeW5jaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IFtzeW5jRXJyb3IsIHNldFN5bmNFcnJvcl0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcclxuXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdsaWZlLW9zLWV4cGVuc2VzJywgSlNPTi5zdHJpbmdpZnkoZXhwZW5zZXMpKTtcclxuICAgIH0sIFtleHBlbnNlc10pO1xyXG5cclxuICAgIGNvbnN0IGFkZEV4cGVuc2UgPSAoZXhwZW5zZTogT21pdDxFeHBlbnNlLCAnaWQnPikgPT4ge1xyXG4gICAgICAgIGNvbnN0IG5ld0V4cGVuc2U6IEV4cGVuc2UgPSB7IC4uLmV4cGVuc2UsIGlkOiBnZW5lcmF0ZUlkKCkgfTtcclxuICAgICAgICBzZXRFeHBlbnNlcyhwcmV2ID0+IFsuLi5wcmV2LCBuZXdFeHBlbnNlXSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IHVwZGF0ZUV4cGVuc2UgPSAoaWQ6IHN0cmluZywgdXBkYXRlczogUGFydGlhbDxFeHBlbnNlPikgPT4ge1xyXG4gICAgICAgIHNldEV4cGVuc2VzKHByZXYgPT4gcHJldi5tYXAoZSA9PlxyXG4gICAgICAgICAgICBlLmlkID09PSBpZCA/IHsgLi4uZSwgLi4udXBkYXRlcyB9IDogZVxyXG4gICAgICAgICkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCBkZWxldGVFeHBlbnNlID0gKGlkOiBzdHJpbmcpID0+IHtcclxuICAgICAgICBzZXRFeHBlbnNlcyhwcmV2ID0+IHByZXYuZmlsdGVyKGUgPT4gZS5pZCAhPT0gaWQpKTtcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgZ2V0RGFpbHlUb3RhbCA9ICgpOiBudW1iZXIgPT4ge1xyXG4gICAgICAgIGNvbnN0IHRvZGF5ID0gbmV3IERhdGUoKS50b0RhdGVTdHJpbmcoKTtcclxuICAgICAgICByZXR1cm4gZXhwZW5zZXNcclxuICAgICAgICAgICAgLmZpbHRlcihlID0+IG5ldyBEYXRlKGUuZGF0ZSkudG9EYXRlU3RyaW5nKCkgPT09IHRvZGF5KVxyXG4gICAgICAgICAgICAucmVkdWNlKCh0b3RhbCwgZSkgPT4gdG90YWwgKyBlLmFtb3VudCwgMCk7XHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IGdldE1vbnRobHlUb3RhbCA9ICgpOiBudW1iZXIgPT4ge1xyXG4gICAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XHJcbiAgICAgICAgY29uc3QgY3VycmVudE1vbnRoID0gbm93LmdldE1vbnRoKCk7XHJcbiAgICAgICAgY29uc3QgY3VycmVudFllYXIgPSBub3cuZ2V0RnVsbFllYXIoKTtcclxuICAgICAgICByZXR1cm4gZXhwZW5zZXNcclxuICAgICAgICAgICAgLmZpbHRlcihlID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGQgPSBuZXcgRGF0ZShlLmRhdGUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGQuZ2V0TW9udGgoKSA9PT0gY3VycmVudE1vbnRoICYmIGQuZ2V0RnVsbFllYXIoKSA9PT0gY3VycmVudFllYXI7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5yZWR1Y2UoKHRvdGFsLCBlKSA9PiB0b3RhbCArIGUuYW1vdW50LCAwKTtcclxuICAgIH07XHJcblxyXG4gICAgY29uc3Qgc3luY1NwbGl0d2lzZSA9IGFzeW5jICgpID0+IHtcclxuICAgICAgICBzZXRJc1N5bmNpbmcodHJ1ZSk7XHJcbiAgICAgICAgc2V0U3luY0Vycm9yKG51bGwpO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIC8vIEZldGNoIGV4cGVuc2VzIGZvciBcIlNlcGFsIGNvbWJpbmVkIGV4cGVuc2VzXCIgZ3JvdXAgKElEOiA5MDk4ODQxOSlcclxuICAgICAgICAgICAgLy8gTGltaXQgdG8gMjAwIHRvIGVuc3VyZSB3ZSBnZXQgZW5vdWdoIGZvciB0aGUgbW9udGhcclxuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goJy9hcGkvZXhwZW5zZXMvc3luYz9ncm91cF9pZD05MDk4ODQxOSZsaW1pdD0yMDAnKTtcclxuICAgICAgICAgICAgaWYgKCFyZXMub2spIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXMuanNvbigpO1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGRhdGEuZXJyb3IgfHwgJ0ZhaWxlZCB0byBzeW5jIFNwbGl0d2lzZScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHN5bmNlZDogT21pdDxFeHBlbnNlLCAnaWQnPltdID0gYXdhaXQgcmVzLmpzb24oKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEZpbHRlciBmb3IgQ1VSUkVOVCBNT05USCBvbmx5XHJcbiAgICAgICAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRNb250aCA9IG5vdy5nZXRNb250aCgpO1xyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50WWVhciA9IG5vdy5nZXRGdWxsWWVhcigpO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgY3VycmVudE1vbnRoRXhwZW5zZXMgPSBzeW5jZWQuZmlsdGVyKHMgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZCA9IG5ldyBEYXRlKHMuZGF0ZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZC5nZXRNb250aCgpID09PSBjdXJyZW50TW9udGggJiYgZC5nZXRGdWxsWWVhcigpID09PSBjdXJyZW50WWVhcjtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBzZXRFeHBlbnNlcyhwcmV2ID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBhbGwgZXhpc3RpbmcgU3BsaXR3aXNlIGV4cGVuc2VzICh0byBhdm9pZCBkdXBsaWNhdGVzL3N0YWxlIGRhdGEpXHJcbiAgICAgICAgICAgICAgICAvLyBXZSBpZGVudGlmeSB0aGVtIGJ5IHRoZSBub3RlIHByZWZpeCBbU3BsaXR3aXNlXVxyXG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxPbmx5ID0gcHJldi5maWx0ZXIoZSA9PiAhZS5ub3RlLnN0YXJ0c1dpdGgoJ1tTcGxpdHdpc2VdJykpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEFkZCBuZXcgc3luYyBkYXRhXHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdFeHBlbnNlcyA9IGN1cnJlbnRNb250aEV4cGVuc2VzLm1hcChzID0+ICh7IC4uLnMsIGlkOiBnZW5lcmF0ZUlkKCkgfSkpO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBbLi4ubG9jYWxPbmx5LCAuLi5uZXdFeHBlbnNlc107XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XHJcbiAgICAgICAgICAgIHNldFN5bmNFcnJvcihlcnIubWVzc2FnZSB8fCAnU3luYyBmYWlsZWQnKTtcclxuICAgICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgICAgICBzZXRJc1N5bmNpbmcoZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgY2xlYXJBbGxFeHBlbnNlcyA9ICgpID0+IHtcclxuICAgICAgICBzZXRFeHBlbnNlcyhbXSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPEV4cGVuc2VDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt7XHJcbiAgICAgICAgICAgIGV4cGVuc2VzLCBhZGRFeHBlbnNlLCB1cGRhdGVFeHBlbnNlLCBkZWxldGVFeHBlbnNlLFxyXG4gICAgICAgICAgICBnZXREYWlseVRvdGFsLCBnZXRNb250aGx5VG90YWwsIHN5bmNTcGxpdHdpc2UsIGlzU3luY2luZywgc3luY0Vycm9yLCBjbGVhckFsbEV4cGVuc2VzXHJcbiAgICAgICAgfX0+XHJcbiAgICAgICAgICAgIHtjaGlsZHJlbn1cclxuICAgICAgICA8L0V4cGVuc2VDb250ZXh0LlByb3ZpZGVyPlxyXG4gICAgKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCB1c2VFeHBlbnNlcyA9ICgpID0+IHtcclxuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KEV4cGVuc2VDb250ZXh0KTtcclxuICAgIGlmICghY29udGV4dCkgdGhyb3cgbmV3IEVycm9yKCd1c2VFeHBlbnNlcyBtdXN0IGJlIHVzZWQgd2l0aGluIGFuIEV4cGVuc2VQcm92aWRlcicpO1xyXG4gICAgcmV0dXJuIGNvbnRleHQ7XHJcbn07XHJcbiJdLCJuYW1lcyI6WyJSZWFjdCIsImNyZWF0ZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwidXNlRWZmZWN0IiwidXNlU3RhdGUiLCJnZW5lcmF0ZUlkIiwiRXhwZW5zZUNvbnRleHQiLCJ1bmRlZmluZWQiLCJFeHBlbnNlUHJvdmlkZXIiLCJjaGlsZHJlbiIsImV4cGVuc2VzIiwic2V0RXhwZW5zZXMiLCJzYXZlZCIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJKU09OIiwicGFyc2UiLCJpc1N5bmNpbmciLCJzZXRJc1N5bmNpbmciLCJzeW5jRXJyb3IiLCJzZXRTeW5jRXJyb3IiLCJzZXRJdGVtIiwic3RyaW5naWZ5IiwiYWRkRXhwZW5zZSIsImV4cGVuc2UiLCJuZXdFeHBlbnNlIiwiaWQiLCJwcmV2IiwidXBkYXRlRXhwZW5zZSIsInVwZGF0ZXMiLCJtYXAiLCJlIiwiZGVsZXRlRXhwZW5zZSIsImZpbHRlciIsImdldERhaWx5VG90YWwiLCJ0b2RheSIsIkRhdGUiLCJ0b0RhdGVTdHJpbmciLCJkYXRlIiwicmVkdWNlIiwidG90YWwiLCJhbW91bnQiLCJnZXRNb250aGx5VG90YWwiLCJub3ciLCJjdXJyZW50TW9udGgiLCJnZXRNb250aCIsImN1cnJlbnRZZWFyIiwiZ2V0RnVsbFllYXIiLCJkIiwic3luY1NwbGl0d2lzZSIsInJlcyIsImZldGNoIiwib2siLCJkYXRhIiwianNvbiIsIkVycm9yIiwiZXJyb3IiLCJzeW5jZWQiLCJjdXJyZW50TW9udGhFeHBlbnNlcyIsInMiLCJsb2NhbE9ubHkiLCJub3RlIiwic3RhcnRzV2l0aCIsIm5ld0V4cGVuc2VzIiwiZXJyIiwibWVzc2FnZSIsImNsZWFyQWxsRXhwZW5zZXMiLCJQcm92aWRlciIsInZhbHVlIiwidXNlRXhwZW5zZXMiLCJjb250ZXh0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/context/ExpenseContext.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/context/TaskContext.tsx":
/*!*************************************!*\
  !*** ./src/context/TaskContext.tsx ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TaskProvider: function() { return /* binding */ TaskProvider; },\n/* harmony export */   useTasks: function() { return /* binding */ useTasks; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _components_RolloverDialog__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/components/RolloverDialog */ \"(app-pages-browser)/./src/components/RolloverDialog.tsx\");\n/* harmony import */ var _services_PredictionService__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/services/PredictionService */ \"(app-pages-browser)/./src/services/PredictionService.ts\");\n/* harmony import */ var _utils_generateId__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/utils/generateId */ \"(app-pages-browser)/./src/utils/generateId.ts\");\n/* __next_internal_client_entry_do_not_use__ TaskProvider,useTasks auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\n\n// Helper to get YYYY-MM-DD\nconst toDateKey = (d)=>d.toISOString().split(\"T\")[0];\nconst TaskContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nconst TaskProvider = (param)=>{\n    let { children } = param;\n    _s();\n    const [tasks, setTasks] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(()=>{\n        if (false) {}\n        const saved = localStorage.getItem(\"life-os-tasks\");\n        return saved ? JSON.parse(saved) : [];\n    });\n    const [missedTasks, setMissedTasks] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [isSyncing, setIsSyncing] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [syncError, setSyncError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        localStorage.setItem(\"life-os-tasks\", JSON.stringify(tasks));\n    }, [\n        tasks\n    ]);\n    // Check for missed tasks on mount\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const today = new Date().setHours(0, 0, 0, 0);\n        const missed = tasks.filter((t)=>{\n            const taskDate = new Date(t.scheduledDate || t.createdAt).setHours(0, 0, 0, 0);\n            return t.status === \"pending\" && taskDate < today;\n        });\n        if (missed.length > 0) {\n            setMissedTasks(missed);\n        }\n    }, []); // Run once on mount\n    const handleRollover = (ids)=>{\n        setTasks((prev)=>prev.map((t)=>ids.includes(t.id) ? {\n                    ...t,\n                    createdAt: new Date().toISOString()\n                } : t));\n        setMissedTasks([]);\n    };\n    const handleClear = (ids)=>{\n        setTasks((prev)=>prev.filter((t)=>!ids.includes(t.id)));\n        setMissedTasks([]);\n    };\n    const requestNotificationPermission = ()=>{\n        if (\"Notification\" in window) {\n            Notification.requestPermission();\n        }\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const interval = setInterval(()=>{\n            const now = new Date();\n            tasks.forEach((task)=>{\n                if (task.status === \"pending\" && task.dueTime) {\n                    const due = new Date(task.dueTime);\n                    if (due <= now && due.getTime() > now.getTime() - 60000) {\n                        if (Notification.permission === \"granted\") {\n                            new Notification(\"Task Due!\", {\n                                body: \"It's time for: \".concat(task.title),\n                                icon: \"/icon-192x192.png\"\n                            });\n                        }\n                    }\n                }\n            });\n        }, 60000);\n        return ()=>clearInterval(interval);\n    }, [\n        tasks\n    ]);\n    const addTask = (title, scheduledDate, dueTime)=>{\n        const newTask = {\n            id: (0,_utils_generateId__WEBPACK_IMPORTED_MODULE_4__.generateId)(),\n            title,\n            status: \"pending\",\n            dueTime,\n            scheduledDate: scheduledDate || toDateKey(new Date()),\n            createdAt: new Date().toISOString()\n        };\n        setTasks((prev)=>[\n                ...prev,\n                newTask\n            ]);\n        if ( true && \"Notification\" in window && Notification.permission === \"default\") {\n            requestNotificationPermission();\n        }\n    };\n    const toggleTaskCompletion = (id)=>{\n        setTasks((prev)=>prev.map((task)=>{\n                if (task.id === id) {\n                    const newStatus = task.status === \"completed\" ? \"pending\" : \"completed\";\n                    if (newStatus === \"completed\") {\n                        _services_PredictionService__WEBPACK_IMPORTED_MODULE_3__.PredictionService.recordCompletion(task.title);\n                    }\n                    return {\n                        ...task,\n                        status: newStatus\n                    };\n                }\n                return task;\n            }));\n    };\n    const updateTask = (id, updates)=>{\n        setTasks((prev)=>prev.map((task)=>task.id === id ? {\n                    ...task,\n                    ...updates\n                } : task));\n    };\n    const deleteTask = (id)=>{\n        setTasks((prev)=>prev.filter((task)=>task.id !== id));\n    };\n    const syncReminders = async ()=>{\n        setIsSyncing(true);\n        setSyncError(null);\n        try {\n            const res = await fetch(\"/api/tasks/sync\");\n            if (!res.ok) {\n                const data = await res.json();\n                throw new Error(data.error || \"Failed to sync reminders\");\n            }\n            const remoteTasks = await res.json();\n            setTasks((prev)=>{\n                const existingTitles = new Set(prev.map((t)=>t.title.toLowerCase()));\n                const newTasks = remoteTasks.filter((t)=>!existingTitles.has(t.title.toLowerCase()));\n                return [\n                    ...prev,\n                    ...newTasks\n                ];\n            });\n        } catch (err) {\n            setSyncError(err.message || \"Sync failed\");\n        } finally{\n            setIsSyncing(false);\n        }\n    };\n    const clearTasksByDate = (date)=>{\n        setTasks((prev)=>prev.filter((t)=>{\n                const taskDate = t.scheduledDate || toDateKey(new Date(t.createdAt));\n                return taskDate !== date;\n            }));\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(TaskContext.Provider, {\n        value: {\n            tasks,\n            addTask,\n            toggleTaskCompletion,\n            deleteTask,\n            updateTask,\n            requestNotificationPermission,\n            syncReminders,\n            isSyncing,\n            syncError,\n            clearTasksByDate\n        },\n        children: [\n            missedTasks.length > 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_RolloverDialog__WEBPACK_IMPORTED_MODULE_2__.RolloverDialog, {\n                missedTasks: missedTasks,\n                onRollover: handleRollover,\n                onClear: handleClear\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\kharw\\\\OneDrive\\\\Desktop\\\\ai-assistant\\\\src\\\\context\\\\TaskContext.tsx\",\n                lineNumber: 171,\n                columnNumber: 17\n            }, undefined),\n            children\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\kharw\\\\OneDrive\\\\Desktop\\\\ai-assistant\\\\src\\\\context\\\\TaskContext.tsx\",\n        lineNumber: 166,\n        columnNumber: 9\n    }, undefined);\n};\n_s(TaskProvider, \"M8CSHZnMhHpwuW82QZb77jUf2pc=\");\n_c = TaskProvider;\nconst useTasks = ()=>{\n    _s1();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(TaskContext);\n    if (!context) throw new Error(\"useTasks must be used within a TaskProvider\");\n    return context;\n};\n_s1(useTasks, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"TaskProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb250ZXh0L1Rhc2tDb250ZXh0LnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBRThFO0FBRWpCO0FBQ0k7QUFDakI7QUFFaEQsMkJBQTJCO0FBQzNCLE1BQU1RLFlBQVksQ0FBQ0MsSUFBWUEsRUFBRUMsV0FBVyxHQUFHQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUU7QUFlNUQsTUFBTUMsNEJBQWNYLG9EQUFhQSxDQUE4Qlk7QUFFeEQsTUFBTUMsZUFBd0Q7UUFBQyxFQUFFQyxRQUFRLEVBQUU7O0lBQzlFLE1BQU0sQ0FBQ0MsT0FBT0MsU0FBUyxHQUFHYiwrQ0FBUUEsQ0FBUztRQUN2QyxJQUFJLEtBQWtCLEVBQWEsRUFBVTtRQUM3QyxNQUFNYyxRQUFRQyxhQUFhQyxPQUFPLENBQUM7UUFDbkMsT0FBT0YsUUFBUUcsS0FBS0MsS0FBSyxDQUFDSixTQUFTLEVBQUU7SUFDekM7SUFFQSxNQUFNLENBQUNLLGFBQWFDLGVBQWUsR0FBR3BCLCtDQUFRQSxDQUFTLEVBQUU7SUFDekQsTUFBTSxDQUFDcUIsV0FBV0MsYUFBYSxHQUFHdEIsK0NBQVFBLENBQUM7SUFDM0MsTUFBTSxDQUFDdUIsV0FBV0MsYUFBYSxHQUFHeEIsK0NBQVFBLENBQWdCO0lBRTFERCxnREFBU0EsQ0FBQztRQUNOZ0IsYUFBYVUsT0FBTyxDQUFDLGlCQUFpQlIsS0FBS1MsU0FBUyxDQUFDZDtJQUN6RCxHQUFHO1FBQUNBO0tBQU07SUFFVixrQ0FBa0M7SUFDbENiLGdEQUFTQSxDQUFDO1FBQ04sTUFBTTRCLFFBQVEsSUFBSUMsT0FBT0MsUUFBUSxDQUFDLEdBQUcsR0FBRyxHQUFHO1FBQzNDLE1BQU1DLFNBQVNsQixNQUFNbUIsTUFBTSxDQUFDQyxDQUFBQTtZQUN4QixNQUFNQyxXQUFXLElBQUlMLEtBQUtJLEVBQUVFLGFBQWEsSUFBSUYsRUFBRUcsU0FBUyxFQUFFTixRQUFRLENBQUMsR0FBRyxHQUFHLEdBQUc7WUFDNUUsT0FBT0cs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a0IsTUFBTSxHQUFHLG1CQUNsQiw4REFBQ3BDLHNFQUFjQTtnQkFDWGtCLGFBQWFBO2dCQUNidUUsWUFBWXBEO2dCQUNacUQsU0FBUy9DOzs7Ozs7WUFHaEJqQzs7Ozs7OztBQUdiLEVBQUU7R0F6SldEO0tBQUFBO0FBMkpOLE1BQU1rRixXQUFXOztJQUNwQixNQUFNQyxVQUFVL0YsaURBQVVBLENBQUNVO0lBQzNCLElBQUksQ0FBQ3FGLFNBQVMsTUFBTSxJQUFJakIsTUFBTTtJQUM5QixPQUFPaUI7QUFDWCxFQUFFO0lBSldEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb250ZXh0L1Rhc2tDb250ZXh0LnRzeD8xM2QyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcclxuXHJcbmltcG9ydCBSZWFjdCwgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgeyBUYXNrIH0gZnJvbSAnQC90eXBlcy90YXNrJztcclxuaW1wb3J0IHsgUm9sbG92ZXJEaWFsb2cgfSBmcm9tICdAL2NvbXBvbmVudHMvUm9sbG92ZXJEaWFsb2cnO1xyXG5pbXBvcnQgeyBQcmVkaWN0aW9uU2VydmljZSB9IGZyb20gJ0Avc2VydmljZXMvUHJlZGljdGlvblNlcnZpY2UnO1xyXG5pbXBvcnQgeyBnZW5lcmF0ZUlkIH0gZnJvbSAnQC91dGlscy9nZW5lcmF0ZUlkJztcclxuXHJcbi8vIEhlbHBlciB0byBnZXQgWVlZWS1NTS1ERFxyXG5jb25zdCB0b0RhdGVLZXkgPSAoZDogRGF0ZSkgPT4gZC50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF07XHJcblxyXG5pbnRlcmZhY2UgVGFza0NvbnRleHRUeXBlIHtcclxuICAgIHRhc2tzOiBUYXNrW107XHJcbiAgICBhZGRUYXNrOiAodGl0bGU6IHN0cmluZywgc2NoZWR1bGVkRGF0ZT86IHN0cmluZywgZHVlVGltZT86IHN0cmluZykgPT4gdm9pZDtcclxuICAgIHRvZ2dsZVRhc2tDb21wbGV0aW9uOiAoaWQ6IHN0cmluZykgPT4gdm9pZDtcclxuICAgIHVwZGF0ZVRhc2s6IChpZDogc3RyaW5nLCB1cGRhdGVzOiBQYXJ0aWFsPFRhc2s+KSA9PiB2b2lkO1xyXG4gICAgZGVsZXRlVGFzazogKGlkOiBzdHJpbmcpID0+IHZvaWQ7XHJcbiAgICByZXF1ZXN0Tm90aWZpY2F0aW9uUGVybWlzc2lvbjogKCkgPT4gdm9pZDtcclxuICAgIHN5bmNSZW1pbmRlcnM6ICgpID0+IFByb21pc2U8dm9pZD47XHJcbiAgICBpc1N5bmNpbmc6IGJvb2xlYW47XHJcbiAgICBzeW5jRXJyb3I6IHN0cmluZyB8IG51bGw7XHJcbiAgICBjbGVhclRhc2tzQnlEYXRlOiAoZGF0ZTogc3RyaW5nKSA9PiB2b2lkO1xyXG59XHJcblxyXG5jb25zdCBUYXNrQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8VGFza0NvbnRleHRUeXBlIHwgdW5kZWZpbmVkPih1bmRlZmluZWQpO1xyXG5cclxuZXhwb3J0IGNvbnN0IFRhc2tQcm92aWRlcjogUmVhY3QuRkM8eyBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlIH0+ID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xyXG4gICAgY29uc3QgW3Rhc2tzLCBzZXRUYXNrc10gPSB1c2VTdGF0ZTxUYXNrW10+KCgpID0+IHtcclxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBbXTtcclxuICAgICAgICBjb25zdCBzYXZlZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdsaWZlLW9zLXRhc2tzJyk7XHJcbiAgICAgICAgcmV0dXJuIHNhdmVkID8gSlNPTi5wYXJzZShzYXZlZCkgOiBbXTtcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IFttaXNzZWRUYXNrcywgc2V0TWlzc2VkVGFza3NdID0gdXNlU3RhdGU8VGFza1tdPihbXSk7XHJcbiAgICBjb25zdCBbaXNTeW5jaW5nLCBzZXRJc1N5bmNpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgY29uc3QgW3N5bmNFcnJvciwgc2V0U3luY0Vycm9yXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xyXG5cclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2xpZmUtb3MtdGFza3MnLCBKU09OLnN0cmluZ2lmeSh0YXNrcykpO1xyXG4gICAgfSwgW3Rhc2tzXSk7XHJcblxyXG4gICAgLy8gQ2hlY2sgZm9yIG1pc3NlZCB0YXNrcyBvbiBtb3VudFxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBjb25zdCB0b2RheSA9IG5ldyBEYXRlKCkuc2V0SG91cnMoMCwgMCwgMCwgMCk7XHJcbiAgICAgICAgY29uc3QgbWlzc2VkID0gdGFza3MuZmlsdGVyKHQgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB0YXNrRGF0ZSA9IG5ldyBEYXRlKHQuc2NoZWR1bGVkRGF0ZSB8fCB0LmNyZWF0ZWRBdCkuc2V0SG91cnMoMCwgMCwgMCwgMCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0LnN0YXR1cyA9PT0gJ3BlbmRpbmcnICYmIHRhc2tEYXRlIDwgdG9kYXk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGlmIChtaXNzZWQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBzZXRNaXNzZWRUYXNrcyhtaXNzZWQpO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFtdKTsgLy8gUnVuIG9uY2Ugb24gbW91bnRcclxuXHJcbiAgICBjb25zdCBoYW5kbGVSb2xsb3ZlciA9IChpZHM6IHN0cmluZ1tdKSA9PiB7XHJcbiAgICAgICAgc2V0VGFza3MocHJldiA9PiBwcmV2Lm1hcCh0ID0+XHJcbiAgICAgICAgICAgIGlkcy5pbmNsdWRlcyh0LmlkKSA/IHsgLi4udCwgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgfSA6IHRcclxuICAgICAgICApKTtcclxuICAgICAgICBzZXRNaXNzZWRUYXNrcyhbXSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IGhhbmRsZUNsZWFyID0gKGlkczogc3RyaW5nW10pID0+IHtcclxuICAgICAgICBzZXRUYXNrcyhwcmV2ID0+IHByZXYuZmlsdGVyKHQgPT4gIWlkcy5pbmNsdWRlcyh0LmlkKSkpO1xyXG4gICAgICAgIHNldE1pc3NlZFRhc2tzKFtdKTtcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgcmVxdWVzdE5vdGlmaWNhdGlvblBlcm1pc3Npb24gPSAoKSA9PiB7XHJcbiAgICAgICAgaWYgKCdOb3RpZmljYXRpb24nIGluIHdpbmRvdykge1xyXG4gICAgICAgICAgICBOb3RpZmljYXRpb24ucmVxdWVzdFBlcm1pc3Npb24oKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XHJcbiAgICAgICAgICAgIHRhc2tzLmZvckVhY2godGFzayA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGFzay5zdGF0dXMgPT09ICdwZW5kaW5nJyAmJiB0YXNrLmR1ZVRpbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkdWUgPSBuZXcgRGF0ZSh0YXNrLmR1ZVRpbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkdWUgPD0gbm93ICYmIGR1ZS5nZXRUaW1lKCkgPiBub3cuZ2V0VGltZSgpIC0gNjAwMDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE5vdGlmaWNhdGlvbi5wZXJtaXNzaW9uID09PSAnZ3JhbnRlZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpZmljYXRpb24oJ1Rhc2sgRHVlIScsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBgSXQncyB0aW1lIGZvcjogJHt0YXNrLnRpdGxlfWAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWNvbjogJy9pY29uLTE5MngxOTIucG5nJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sIDYwMDAwKTtcclxuXHJcbiAgICAgICAgcmV0dXJuICgpID0+IGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xyXG4gICAgfSwgW3Rhc2tzXSk7XHJcblxyXG4gICAgY29uc3QgYWRkVGFzayA9ICh0aXRsZTogc3RyaW5nLCBzY2hlZHVsZWREYXRlPzogc3RyaW5nLCBkdWVUaW1lPzogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgY29uc3QgbmV3VGFzazogVGFzayA9IHtcclxuICAgICAgICAgICAgaWQ6IGdlbmVyYXRlSWQoKSxcclxuICAgICAgICAgICAgdGl0bGUsXHJcbiAgICAgICAgICAgIHN0YXR1czogJ3BlbmRpbmcnLFxyXG4gICAgICAgICAgICBkdWVUaW1lLFxyXG4gICAgICAgICAgICBzY2hlZHVsZWREYXRlOiBzY2hlZHVsZWREYXRlIHx8IHRvRGF0ZUtleShuZXcgRGF0ZSgpKSxcclxuICAgICAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgICAgfTtcclxuICAgICAgICBzZXRUYXNrcyhwcmV2ID0+IFsuLi5wcmV2LCBuZXdUYXNrXSk7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAnTm90aWZpY2F0aW9uJyBpbiB3aW5kb3cgJiYgTm90aWZpY2F0aW9uLnBlcm1pc3Npb24gPT09ICdkZWZhdWx0Jykge1xyXG4gICAgICAgICAgICByZXF1ZXN0Tm90aWZpY2F0aW9uUGVybWlzc2lvbigpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgdG9nZ2xlVGFza0NvbXBsZXRpb24gPSAoaWQ6IHN0cmluZykgPT4ge1xyXG4gICAgICAgIHNldFRhc2tzKHByZXYgPT4gcHJldi5tYXAodGFzayA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0YXNrLmlkID09PSBpZCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3U3RhdHVzID0gdGFzay5zdGF0dXMgPT09ICdjb21wbGV0ZWQnID8gJ3BlbmRpbmcnIDogJ2NvbXBsZXRlZCc7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKG5ld1N0YXR1cyA9PT0gJ2NvbXBsZXRlZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBQcmVkaWN0aW9uU2VydmljZS5yZWNvcmRDb21wbGV0aW9uKHRhc2sudGl0bGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiB7IC4uLnRhc2ssIHN0YXR1czogbmV3U3RhdHVzIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRhc2s7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCB1cGRhdGVUYXNrID0gKGlkOiBzdHJpbmcsIHVwZGF0ZXM6IFBhcnRpYWw8VGFzaz4pID0+IHtcclxuICAgICAgICBzZXRUYXNrcyhwcmV2ID0+IHByZXYubWFwKHRhc2sgPT5cclxuICAgICAgICAgICAgdGFzay5pZCA9PT0gaWQgPyB7IC4uLnRhc2ssIC4uLnVwZGF0ZXMgfSA6IHRhc2tcclxuICAgICAgICApKTtcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgZGVsZXRlVGFzayA9IChpZDogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgc2V0VGFza3MocHJldiA9PiBwcmV2LmZpbHRlcih0YXNrID0+IHRhc2suaWQgIT09IGlkKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IHN5bmNSZW1pbmRlcnMgPSBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgc2V0SXNTeW5jaW5nKHRydWUpO1xyXG4gICAgICAgIHNldFN5bmNFcnJvcihudWxsKTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaCgnL2FwaS90YXNrcy9zeW5jJyk7XHJcbiAgICAgICAgICAgIGlmICghcmVzLm9rKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzLmpzb24oKTtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihkYXRhLmVycm9yIHx8ICdGYWlsZWQgdG8gc3luYyByZW1pbmRlcnMnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCByZW1vdGVUYXNrczogVGFza1tdID0gYXdhaXQgcmVzLmpzb24oKTtcclxuXHJcbiAgICAgICAgICAgIHNldFRhc2tzKHByZXYgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdUaXRsZXMgPSBuZXcgU2V0KHByZXYubWFwKHQgPT4gdC50aXRsZS50b0xvd2VyQ2FzZSgpKSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdUYXNrcyA9IHJlbW90ZVRhc2tzLmZpbHRlcih0ID0+ICFleGlzdGluZ1RpdGxlcy5oYXModC50aXRsZS50b0xvd2VyQ2FzZSgpKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gWy4uLnByZXYsIC4uLm5ld1Rhc2tzXTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcclxuICAgICAgICAgICAgc2V0U3luY0Vycm9yKGVyci5tZXNzYWdlIHx8ICdTeW5jIGZhaWxlZCcpO1xyXG4gICAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgICAgIHNldElzU3luY2luZyhmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCBjbGVhclRhc2tzQnlEYXRlID0gKGRhdGU6IHN0cmluZykgPT4ge1xyXG4gICAgICAgIHNldFRhc2tzKHByZXYgPT4gcHJldi5maWx0ZXIodCA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhc2tEYXRlID0gdC5zY2hlZHVsZWREYXRlIHx8IHRvRGF0ZUtleShuZXcgRGF0ZSh0LmNyZWF0ZWRBdCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGFza0RhdGUgIT09IGRhdGU7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxUYXNrQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17e1xyXG4gICAgICAgICAgICB0YXNrcywgYWRkVGFzaywgdG9nZ2xlVGFza0NvbXBsZXRpb24sIGRlbGV0ZVRhc2ssIHVwZGF0ZVRhc2ssXHJcbiAgICAgICAgICAgIHJlcXVlc3ROb3RpZmljYXRpb25QZXJtaXNzaW9uLCBzeW5jUmVtaW5kZXJzLCBpc1N5bmNpbmcsIHN5bmNFcnJvciwgY2xlYXJUYXNrc0J5RGF0ZVxyXG4gICAgICAgIH19PlxyXG4gICAgICAgICAgICB7bWlzc2VkVGFza3MubGVuZ3RoID4gMCAmJiAoXHJcbiAgICAgICAgICAgICAgICA8Um9sbG92ZXJEaWFsb2dcclxuICAgICAgICAgICAgICAgICAgICBtaXNzZWRUYXNrcz17bWlzc2VkVGFza3N9XHJcbiAgICAgICAgICAgICAgICAgICAgb25Sb2xsb3Zlcj17aGFuZGxlUm9sbG92ZXJ9XHJcbiAgICAgICAgICAgICAgICAgICAgb25DbGVhcj17aGFuZGxlQ2xlYXJ9XHJcbiAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICApfVxyXG4gICAgICAgICAgICB7Y2hpbGRyZW59XHJcbiAgICAgICAgPC9UYXNrQ29udGV4dC5Qcm92aWRlcj5cclxuICAgICk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgdXNlVGFza3MgPSAoKSA9PiB7XHJcbiAgICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dChUYXNrQ29udGV4dCk7XHJcbiAgICBpZiAoIWNvbnRleHQpIHRocm93IG5ldyBFcnJvcigndXNlVGFza3MgbXVzdCBiZSB1c2VkIHdpdGhpbiBhIFRhc2tQcm92aWRlcicpO1xyXG4gICAgcmV0dXJuIGNvbnRleHQ7XHJcbn07XHJcbiJdLCJuYW1lcyI6WyJSZWFjdCIsImNyZWF0ZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwidXNlRWZmZWN0IiwidXNlU3RhdGUiLCJSb2xsb3ZlckRpYWxvZyIsIlByZWRpY3Rpb25TZXJ2aWNlIiwiZ2VuZXJhdGVJZCIsInRvRGF0ZUtleSIsImQiLCJ0b0lTT1N0cmluZyIsInNwbGl0IiwiVGFza0NvbnRleHQiLCJ1bmRlZmluZWQiLCJUYXNrUHJvdmlkZXIiLCJjaGlsZHJlbiIsInRhc2tzIiwic2V0VGFza3MiLCJzYXZlZCIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJKU09OIiwicGFyc2UiLCJtaXNzZWRUYXNrcyIsInNldE1pc3NlZFRhc2tzIiwiaXNTeW5jaW5nIiwic2V0SXNTeW5jaW5nIiwic3luY0Vycm9yIiwic2V0U3luY0Vycm9yIiwic2V0SXRlbSIsInN0cmluZ2lmeSIsInRvZGF5IiwiRGF0ZSIsInNldEhvdXJzIiwibWlzc2VkIiwiZmlsdGVyIiwidCIsInRhc2tEYXRlIiwic2NoZWR1bGVkRGF0ZSIsImNyZWF0ZWRBdCIsInN0YXR1cyIsImxlbmd0aCIsImhhbmRsZVJvbGxvdmVyIiwiaWRzIiwicHJldiIsIm1hcCIsImluY2x1ZGVzIiwiaWQiLCJoYW5kbGVDbGVhciIsInJlcXVlc3ROb3RpZmljYXRpb25QZXJtaXNzaW9uIiwid2luZG93IiwiTm90aWZpY2F0aW9uIiwicmVxdWVzdFBlcm1pc3Npb24iLCJpbnRlcnZhbCIsInNldEludGVydmFsIiwibm93IiwiZm9yRWFjaCIsInRhc2siLCJkdWVUaW1lIiwiZHVlIiwiZ2V0VGltZSIsInBlcm1pc3Npb24iLCJib2R5IiwidGl0bGUiLCJpY29uIiwiY2xlYXJJbnRlcnZhbCIsImFkZFRhc2siLCJuZXdUYXNrIiwidG9nZ2xlVGFza0NvbXBsZXRpb24iLCJuZXdTdGF0dXMiLCJyZWNvcmRDb21wbGV0aW9uIiwidXBkYXRlVGFzayIsInVwZGF0ZXMiLCJkZWxldGVUYXNrIiwic3luY1JlbWluZGVycyIsInJlcyIsImZldGNoIiwib2siLCJkYXRhIiwianNvbiIsIkVycm9yIiwiZXJyb3IiLCJyZW1vdGVUYXNrcyIsImV4aXN0aW5nVGl0bGVzIiwiU2V0IiwidG9Mb3dlckNhc2UiLCJuZXdUYXNrcyIsImhhcyIsImVyciIsIm1lc3NhZ2UiLCJjbGVhclRhc2tzQnlEYXRlIiwiZGF0ZSIsIlByb3ZpZGVyIiwidmFsdWUiLCJvblJvbGxvdmVyIiwib25DbGVhciIsInVzZVRhc2tzIiwiY29udGV4dCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/context/TaskContext.tsx\n"));

/***/ })

});